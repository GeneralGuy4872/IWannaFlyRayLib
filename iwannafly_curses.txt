/* Hey, you. yeah, you. who do you think I'm talking to; the mouse?
 *
 * you found the seeecret extended documentation, aka the source code!
 * the sorce code, and witty comments, are intended to supplement the
 * manpages, as well as give a deeper understanding of the program.
 */

/* the 3d version of Iwannafly started off as a general RT-RPG library that
 * then became narrowed to a specific game. this version was originally
 * supposed to be the same game reworked for ncurses,
 * but is now becoming closer to the general library concept,
 * similar to a RPG ruleset that allows creation of
 * your own setting and plot (you know the one).
 * a default one will be provided, however, based on the 3d game's concept,
 * but extended well beyond the projected capabilities of that engine.
 */

setlocale(LC_ALL, "");

/* because of the spelling based internals
 * of the CLI commands, translateing the library
 * would require rewriting large switch tables.
 *
 * ESC enters console mode, with the prompt symbol of :
 * fgets will get an input string
 * strtok will break up the string into words
 * the tokenized string is read according to mode and submode
 *
 * for toplevel commands and some specifiers,
 *  branching on getc will eventually turn words
 *  into enum tokens based on the mode.
 *  users need not type the entire command,
 *  just the unique part. this routine returns
 *  toplevel commands return a dispatch table index
 *  and set the main mode, specifiers set the submode
 *  and change an argument from it's default state.
 *
 * if the mode expects an in-game name,
 *  !(strcmp) is used on the relevant table
 *
 * if the mode expects a number, atoi is used.
 *
 */

#define BRIGHT 8
//example: BRIGHT+COLOR_RED

#include <math.h>
#ifndef M_SQRT2
#error enviroment is not sane (math.h)
#endif
//IT. HAS. ONE JOB. HERE.

#ifndef _XOPEN_SOURCE_EXTENDED
#define _XOPEN_SOURCE_EXTENDED
#endif

#ifndef _Rune
typedef unsigned short Rune //I'll do it this way and let C take it from there.
#endif

import //psudocode, not python
mainh__roll
mainh__bonus
mainh__flip
mainh__file_cat
/* note: my convention for C header is 2 underscores,
 * since there is no such thing in C and it thus has to be in the function's name
 */

pseudosubroutine ERROR_GRAPHIC("short text",int foo,int bar) //should also output __FILE__ and __LINE__, which will likely be the program's version of undecipherable hex codes to everyone but me
*╮  Error
╭┴╮  "short text"
│!│ N1 = foo
╰─╯ N2 = bar
File: file.c
Line: 19

playertyp PLAYER
roomtyp ROOM
unsigned long long TURN
unsigned char ROOMTURN
unsigned long KILLS
char* SAVEPATH
enttype *PURS_head //pursuers, i.e. paid assasins, ninjas, the reaper...
enttype *PURS_tail

struct coord3:
unsigned char x
unsigned char y
unsigned char z

struct coord2:
unsigned char x
unsigned char y

struct scoord3:
signed char x
signed char y
signed char z

struct scoord2:
signed char x
signed char y

struct diceodds:
unsigned char num : 3
unsigned char side : 5
unsigned char tobeat : 8

struct planecoord:
bool shadow : 1 //dark world
bool moon : 1 //are you on the moon?
bool shift : 1 //are you plane shifted?
unigned char az : 3 //azimuth on a plane chart
signed char el : 2

struct mapcoord: //surface terrain generation by dice roll from pregenerated blocks. doungeon generation by algorithem tbd. some coords will generate fixed special rooms
signed char lat
signed char lon
unsigned char dep
planecoord plane

/* when combined with shift, moon becomes outer planes, and shadow becomes off-plane
 *
 * az	elemental	afterlife	corrilation
 * 0	water		neutral good	nurturer
 * 1	ice		chaotic good	the ends justify the means
 * 2	air		chaotic neutral	those dang wind mages, always stealing princesses...
 * 3	electricity	chaotic evil	force lightning
 * 4	fire		neutral evil	obviously
 * 5	metal		lawful evil	greed
 * 6	earth		lawful neutral	stubborn
 * 7	trees		lawful good	knowladge
 *
 * az rotates by 45 degree steps and el by 90 degree steps.
 * a nonzero el causes az to gimbal lock.
 * also best not to think about where exactly -2 is pointing;
 * perhaps it's a doughnut?
 *
 * el	"		"		"
 * +1	light		true neutral	enlightenment
 * -1	darkness	mindless	mold can't see
 * -2	entropy		oathbreakers	abandon all hope ye who enter here
 *
 * by combining the shift and shadow fields, you can go to the
 * ethereal (inner) and asteral (outer) planes,
 * but only the worthy can withstand the inter-planer energy.
 * all others are instantly blasted with all permenent status effects, including stoning.
 *
 * errors related to this section generate the string "froze to death on pluto", N1=az,N2=el
 */

struct cylinder:
unsigned char r : 6
unsigned char z : 3
unsigned char _z : 3
bool show : 1
unsigned char color : 3
 /* cylinders, (the shape, not this datatype) are used extensively.
  * players move in cylindrical coordinate space.
  * event areas are specified as cylinders
  * monster aggro ranges are a cylinder
  */
struct aligntyp:
good : b1
evil : b1
law : b1
chaos : b1
nogood : b1
noevil : b1
nolaw : b1
nochaos : b1
/* used as a mask.
 * alignment is allowed to be any of the high nibble.
 * alignment may NOT be any of the low nibble, marked "no".
 * alignment may always be true neutral.
 */

fstab cli_dispatch = <pointers to command functions>

enum cli_modeid = <list of full command names>

struct cli_submode:
bool number
stabs* stabs_ptr

struct bitfield:
a : 1
b : 1
c : 1
d : 1
w : 1
x : 1
y : 1
z : 1

typedef char* stabs[256] //symbol table strings
typedef void* fstab[256] //filesystem table
typedef unsigned char symtabref //beware of missingno glitches!

stabs itemstabs //stuff that doesn't go anywhere else; i.e. arrows, keys, quest items
stabs spellstabs //spells
stabs weapstabs //weapons
stabs armstabs //armor
stabs shldstabs //shield, cannon, greeves
stabs baubstabs //rings and amulets
fstab itemtable
fstab spelltable
fstab weaptable
fstab armtable
fstab shldtable
fstab baubtable

char* legendstabs[16] = {"truthseeker"/*bow*/,"sword of justice","excalibur","sickle of chaos","stormbringer","devilfork","partisen of tyrants","deathscyth","sunray"/*spear*/,"nightedge","firebrand","tesla's mace","stormgale"/*bow*/,"frostpike","trident of the seas","groundshaker"}
legendtyp legendtable[16]

typedef classobjtyp:
classtyp
magictyp

typedef classtyp:
unsigned char type : 2
unsigned char class : 3
bool law_good : 1
bool neutral : 1
bool chaos_evil : 1

char* roguestabs[8] = {"changeling","rogue","thief","pirate","ninja","assasin","tourist","ronan"}
char* fighterstabs[8] = {"fighter","knight","paladin","valkyrie","viking","samuri","ranger","monk"}
char* magicuserstabs[8] = {"magic-user","wizard","illusionist","enchanter","black mage","red mage","psion","necromancer"}
char* healerstabs[8] = {"healer","cleric","priest","druid","alchemist","scholar","white mage","seer"}

playertyp classtable[4][8] //is freed after startup; initial values for PLAYER

stabs mon1stabs =
{"human","elf","dwarf","gnome","hobbit","half elf","drow","avian","half orc","half dragon","half celestial","half fiend","half air elemental","half water elemental","half earth elemental","half fire elemental",
"merfolk","seaelf","dryad","foocubus","faerie"}; //...
fstab mon1table
/* contains all polymorphable monsters, of type BASENTYPE.
 * Only C0 control characters may be initial races.
 * any polymorphable race can BECOME your base race...
 * polymorph autocomplete is implemented using switches.
 */
stabs mon2stabs //must include: chicken, duck, cow, pig
fstab mon2table

struct the8stats:
stren : 5
dex : 5
tough : 5
fort : 5
intl : 5
wis : 5
bluff : 5
cast : 5

struct conlangtype:
symtabref id : 6
bool r : 1
bool w : 1
//nothing to X-ecut, so no x

char* conlangtab[64] ={lingua franca,thieves cant,middle elvish,old elvish,dwarvish,gnomish,gothic,orkish,draconic,fey,celestic,blackspeech,skyspeak,waterspeak,earthspeak,firespeak}

struct playertyp:
classtyp class
symtabref startrace
symtabref polyrace
toomuchpolytyp polycounter
coord3 loc
paffectyp permenent
effectyp fromequip
scoord2 align
unsigned short hp //they're fun and easy to...wait
unsigned short mp
unsigned long xp
unsigned char lvl
signed short food
unsigned short gold
heldobjtyp *lang_head
heldobjtyp *lang_tail
heldobjtyp *spell_head
heldobjtyp *spell_tail
heldobjtyp *bag_head
heldobjtyp *bag_tail
subobjtyp weap_left	//weapon
subobjtyp weap_right	//weapon
subobjtyp shield	//shld
subobjtyp bow	//weapon
subobjtyp armor	//armor
subobjtyp cape	//armor
subobjtyp helm	//armor
subobjtyp gloves	//armor
subobjtyp cannon	//shld
subobjtyp boots	//armor
subobjtyp greev	//shld
subobjtyp amul	//baub
subobjtyp ringl	//baub
subobjtyp ringr	//baub
subobjtyp wristl	//baub
subobjtyp wristr	//baub

psudosubroutine update_player
/* resets .fromequip , then iterates through the entire equipment list to regenerate it.
 * must be called every time equipment is changed to ensure that it is up to date
 * effects in .permenent can only be removed by finding something that affects the opposite change
 * changes to your starting alignment or base race are generally rare and disasterous, as they represent
 * the corruption of the character in some way (i.e. if you recursively polymorph,
 * or are polymorphed while turning to stone, you may forget who you are. this does cure stoning.
 * if this happens and you become a race that is not a c0 control character,
 * your class will be set to $00:changling.)
 * other entities can only be polymorphed into things in their own symbol table.
 */

struct basentyp:
aligntyp alignmask
effectyp base
unsigned char spd //distance calculations use M_SQRT2 for diagonals
unsigned char fly
unsigned char hplvl
unsigned char mplvl
unsigned char xplvl
symtabref lang0 : 6
symtabref lang1 : 6
symtabref spell0
symtabref spell1
unsigned char color
Rune symbol

struct aggrotyp:
bool shiftable : 1 //look around and tell me where else to put it.
bool trig : 1
signed char peace : 2
unsigned char r : 6
unsigned char z : 3
unsigned char _z : 3

struct enttyp:
(self) *prev
(self) *next
aggrotyp aggro
unsigned char cooldown
symtabref race
coord3 loc
effectyp effect
unsigned short hp
unsigned short xp
unsigned char lvl
unsigned char gold
subobjtyp loot
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
subobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct heldobjtyp:
(self) *prev
(self) *next
objid type
void* data

struct subobjtyp:
symtabref itemid : 8
bool cursed : 1
bool oxide : 1
bool burned : 1
signed char bonus : 5
unsigned char metadata : 8 //secondary symtabref for legendary objects

struct magictyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1 //entropy is not light. entropy is not darkness. entropy is balance. entropy is fate; doom; *death*. not things you want to be on the wrong end of.
bool light : 1 //light is not necisarrily good
bool dark : 1 //dark is not necisarrily evil
bool planer : 1

struct toomuchpolytyp:
unsigned char count : 8
unsigned char depth : 8

struct spelltyp:
symtabref itemid
diceodds odds
unsigned char prof

struct basespelltyp:
bool poly : 1
bool heal : 1
unsigned char pow : 6
magictyp : 8
void* effect //either missiletyp or mapcoord; mapcoord always iff planer, set the type flag accordingly for the inner planes

struct missiletyp:
unsigned char damage : 6
signed char recoil : 7
unsigned char cost : 4
unsigned char spread : 2 //0 = line, 1 = narrow (1:3), 2 = wide (1:2), 3 = very wide (1:1)
unsigned char splash : 3 //radius of damage on impact
bool spz : 1 //spread and splash in the z plane. spread on the z plane is capped to ± spread (literal)
bool dig : 1 
//if (.spread != 0), slope = 4-.spreaad

struct baseweaptyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool unbreak : 1
unsigned char skill : 3
unsigned char damage : 8

legendtyp:
the8stats eight
resistyp resist
senstyp sense
skilltyp skill
legendflagtyp flags

legendflagtyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool unbreak : 1
bool vamp : 1
bool drain : 1
bool intrest : 1

struct basearmortyp:
effectyp
unsigned char def : 8
unsigned char spdef : 8
unsigned char extfort : 8

struct baseshldtyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool reflect : 1
bool entro : 1
bool light : 1
bool dark : 1
effectyp
unsigned char def : 8
unsigned char spdef : 8

struct stattyp:
caster
gills
wings
nolegs
psn
brn
blind
whoami

struct ailmntyp:
dizzy : u4
psn : u4
prlz : u4
frz : u4
brn : u4
stone : u4
slp : u8
blind : u8
poly : u8

struct cursetyp:
dizzy : b
psn : b
prlz : b
frz : b
brn : b
stone : b
slp : b
blind : b

struct elixtyp:
cursetyp type
unsigned char poly
signed char lvl

struct resistyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool stoneproof : 1
bool polyproof : 1
bool sleepproof : 1
bool poisonproof : 1

struct sensetyp:
trouble
hidden
invis
infra
good
evil
law
chaos

struct effectyp:
the8stats eight
stattyp stat
ailmntyp ails_ya
resistyp resist
senstyp sense
skilltyp skill
magictyp asp
signed char atk
signed char spatk
signed char def
signed char spdef

struct paffectyp
the8stats eight
stattyp stat
cursetyp curse
resistyp resist
senstyp sense
skilltyp skill
magictyp asp

struct potiontyp:
stattyp stat
elixtyp ails_ya
resistyp resist
senstyp sense
signed short hp
signed short mp
diceodds odds

struct skilltyp:
nibble sword
nibble stave
nibble club
nibble shield
nibble bow
nibble throw
nibble locks
nibble monk

readtyp:
unsigned char locale : 6
bool multiuse : 1
bool scroll : 1
unsigned char subject : 2 //0 = calculus, 1 = weapons, 2 = language, 3 = spellcraft
unsigned char uses : 6
*void contents

char* wandmaterials[16] = {"oak","ash","yew","honeylocust","silver","bronze","iron","orichalcum","marble","bone","dragon fang","unicorn horn","glass","lead crystal","adamantine","stardust"} //stoning -> marble

wandtyp:
unsigned char matter : 4
unsigned char uses : 4
*spelltyp bound //null is a valid value, meaning empty

char* baubmaterials[8] = {"yew","bronze","silver","gold","plastic","ivory","obsidian","stardust"} //stoning -> obsidian

baubtype :
signed char type : 2 //0=ring, 1=amulet, -1=amulet, -2=disappearing amulet
unsigned char matter : 3
unsigned char color : 3
paffectyp enchnt

struct room: //top-down display of a 3d space
mapcoord latlon
char pallette[2][8]
tileset *lowtiles
tileset *hightiles
signed char *tiledata[8][16][80]
signed char *ground
enttype *ent_head
enttype *ent_tail
mapobjtyp *obj_head
mapobjtyp *obj_tail
coord2 downstair
coord3 upstair
coord3 home
/* z coord of the upstair is the maximum height of the map, obviously.
 * upstair is not rendered on dep=0, but must still be present.
 * if invalid coords are given for a warp (typically {$FF,$FF}),
 * then the player is dumped at the location indicated by home.
 *
 * if the player has invalid coords, then the error string "fell out of terminal",N1=x,N2=y is generated.
 */

/*      .r8 : binary data that is organized into 8 bit segments
 *     .r16 : binary data that is organized into 16 bit segments
 *     .hex : binary data that is not organized
 *     .csv : text data seperated with commas and line breaks
 *     .dat : text data seperated with line breaks only
 *     .tsv : text data seperated with tabs and line breaks
 *     .tab : text data seperated with tabs and line breaks that represents a string table
 *  .tar.gz : by default, each room's directory is automatically compressed using an os call to prevent disk hogging (tar -xzf to open, or tar -czf to store)
 * .tar.bz2 : by default, each plane's directory is further compressed (tar -xzf to open, or tar -czf to store)
 */

typedef tilemeta* tileset[128]

struct tilemeta:
bool climb
bool solid
bool water
bool hot
bool cold
bool elec
bool hurts
bool breaks
unsigned char color
Rune symbol

pseudosubroutine getsym
	{
	if (sym < 0)
		{
		cursesprint(.hightiles[sym^-128]) //xor intentional
		}
	else
		{
		cursesprint(.lowtiles[sym])
		}
	}

struct mapobjtyp:
(self) *prev
(self) *next
coord3 pos
objid type
void* data
bool qflag : 1
bool good : 1
bool evil : 1
bool law : 1
bool chaos : 1
bool noneutral : 1
unsigned char class : 2

struct eventtyp:
(self) *prev
(self) *next
Rune symbol
triggerfunc ifthis(unsigned short,unsigned short,unsigned short,unsigned short)
eventfunc dothis(unsigned short,unsigned short,unsigned short,unsigned short)
unsigned short params[4]
const char* name
cylinder dim
unsigned short duration

struct traptyp:
(self) *prev
(self) *next
unsigned char color
Rune symbol
coord3 loc
unsigned short duration
magictyp
stattyp stat
elixtyp ails_ya
diceodds odds
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool tamperproof
bool stoneproof
bool warded
bool multiuse
senstyp sense
signed short hp
signed short mp

struct warptyp:
(self) *prev
(self) *next
unsigned char color
Rune symbol
mapcoord latlon
coord3 loc
coord3 dest
unsigned short duration

char* gemcolors[8] = {"jet","sapphire","emerald","turquoise","ruby","amythest","heliodor","diamond"} //stoning has no effect
/* cut varys by color:
 * diamond = {uncut,cushion-cut,princess-cut,perfect-cut}
 * beryls,emerald={uncut,oval-cut,emerald-cut,teardrop} redundancy of emerald-cut emerald is redundant
 * amythest={geode,prismatic,cushion-cut,teardrop}
 * jet,turquoise={piece of,byzantine,polyhedral,carved relif in}
 */

struct gemstonetyp:
nibble color : 3
unsigned char quality : 2
unsigned char cut : 2

struct meattyp:
symtabref race : 8
bool hightable : 1
unsigned char sellby : 7
unsigned char amount : 8

struct foodtyp:
symtabref itemid
symtabref metadata
unsigned char sellby
unsigned char amount

foodbasetyp:
paffectyp effect
diceodds odds
unsigned char keepsfor
unsigned char hp
unsigned char nutri

always (unsigned short,unsigned short,unsigned short,unsigned short) {return 1}

enum objid:
WEAPON_FLAG : contains subobjtyp calling baseweaptyp
POTION_FLAG : contains potiontyp
READ_FLAG : contains readtyp
FOOD_FLAG : contains subobjtyp containing foodtyp
MEAT_FLAG : contains subobjtyp containing meattyp
ARMOR_FLAG : contains subobjtyp calling basearmortyp
SHLD_FLAG : contains subobjtyp calling baseshldtyp
BAUB_FLAG : contains subobjtyp calling baubtyp
CONLANG_FLAG : contains conlangtyp
SPELL_FLAG : contains spelltyp
SPECIAL_FLAG : contains specitemtyp
GEM_FLAG : contains gemstonetyp
TRAP_FLAG : contains traptyp
EVENT_FLAG : contains eventtyp
WARP_FLAG : contains warptyp
GOLD_FLAG : contains an unsigned interger stored as a pointer

pseudosubroutine radius
uses floats to define a circle,
terminating on the pixal that is
GE than the input. one function won't
cover all use cases.

each layer is drawn translated +1y if it is above the player and -1y if it is below.
a shadow is drawn under the player
layers are drawn from ground to sky; if the player or their shadow would be covered by a tile,
drawing is stopped and the player is drawn if they have not been already
to avoid confusion, by default the player always uses a unique character: ☻, and their shadow: ☺.
(humans,elves,seaelvs,drow,halfelves are otherwise represented by the traditional @
other playable races are as follows: § avian,halfdragon,halfelemental,halfoutsider
other playable races as follows: & foocubus  n faerie,merfolk,dryad  d dwarf  g gnome  o halforc)
¶ is the shadow of something with wings, ␀ is the shadow of something that...err...doesn't.
♠ represents weapons. [ is armor. ] is a shield, cannons, or greeves. ♮ represents tools.
¿ represents potions. ∫ is a scroll. ≣ represents books,tablets. $ is gold. ◊ is a gemstone.
° is a ring. º is a bracelet. ª is an amulet. / is a wand. ~ is a liquid. ∧ is spikes.
␣ is a chair. ⋎ is a fountain. ⌁ is fire or electricity. * is ice. ⏍ is a chest.
⍝ is a sign or tombstone. ? is invisible. ! is a quest. ␋ is a light. ⌘ is a misc item.
␥ is a locked door. ⌥ is a key or lockpick. ⍰ is a missingno.

(recommended font: GNU fixed or the unifont; glyphs used are guarunteed to display properly in these fonts.
recommended terminal: xterm 256colors, what else would I be using?)

unsigned char getsixbit_template() {
switch (getc(stdin)) {
	case '!' :
		return 01;
		break;
	case '"' :
		return 02;
		break;
	case '#' :
		return 03;
		break;
	case '$' :
		return 04;
		break;
	case '%' :
		return 05;
		break;
	case '&' :
		return 06;
		break;
	case '\'' : noop();
	case '`' :
		return 07;
		break;
	case '(' :
		return 010;
		break;
	case ')' :
		return 011;
		break;
	case '*' :
		return 012;
		break;
	case '+' :
		return 013;
		break;
	case ',' :
		return 014;
		break;
	case '-' :
		return 015;
		break;
	case '.' :
		return 016;
		break;
	case '/' :
		return 017;
		break;
	case '0' :
		return 020;
		break;
	case '1' :
		return 021;
		break;
	case '2' :
		return 022;
		break;
	case '3' :
		return 023;
		break;
	case '4' :
		return 024;
		break;
	case '5' :
		return 025;
		break;
	case '6' :
		return 026;
		break;
	case '7' :
		return 027;
		break;
	case '8' :
		return 030;
		break;
	case '9' :
		return 031;
		break;
	case ':' :
		return 032;
		break;
	case ';' :
		return 033;
		break;
	case '<' :
		return 034;
		break;
	case '=' :
		return 035;
		break;
	case '>' :
		return 036;
		break;
	case '?' :
		return 037;
		break;
	case '@' :
		return 040;
		break;
	case 'A' : noop();
	case 'a' :
		return 041;
		break;
	case 'B' : noop();
	case 'b' :
		return 042;
		break;
	case 'C' : noop();
	case 'c' :
		return 043;
		break;
	case 'D' : noop();
	case 'd' :
		return 044;
		break;
	case 'E' : noop();
	case 'e' :
		return 045;
		break;
	case 'F' : noop();
	case 'f' :
		return 046;
		break;
	case 'G' : noop();
	case 'g' :
		return 047;
		break;
	case 'H' : noop();
	case 'h' :
		return 050;
		break;
	case 'I' : noop();
	case 'i' :
		return 051;
		break;
	case 'J' : noop();
	case 'j' :
		return 052;
		break;
	case 'K' : noop();
	case 'k' :
		return 053;
		break;
	case 'L' : noop();
	case 'l' :
		return 054;
		break;
	case 'M' : noop();
	case 'm' :
		return 055;
		break;
	case 'N' : noop();
	case 'n' :
		return 056;
		break;
	case 'O' : noop();
	case 'o' :
		return 057;
		break;
	case 'P' : noop();
	case 'p' :
		return 060;
		break;
	case 'Q' : noop();
	case 'q' :
		return 061;
		break;
	case 'R' : noop();
	case 'r' :
		return 062;
		break;
	case 'S' : noop();
	case 's' :
		return 063;
		break;
	case 'T' : noop();
	case 't' :
		return 064;
		break;
	case 'U' : noop();
	case 'u' :
		return 065;
		break;
	case 'V' : noop();
	case 'v' :
		return 066;
		break;
	case 'W' : noop();
	case 'w' :
		return 067;
		break;
	case 'X' : noop();
	case 'x' :
		return 070;
		break;
	case 'Y' : noop();
	case 'y' :
		return 071;
		break;
	case 'Z' : noop();
	case 'z' :
		return 072;
		break;
	case '[' : noop();
	case '{' :
		return 073;
		break;
	case '\' : noop();
	case '|' :
		return 074;
		break;
	case ']' : noop();
	case '}' :
		return 075;
		break;
	case '^' : noop();
	case '~' :
		return 076;
		break;
	case '_' :
		return 077;
		break;
	default :
		return 0;
		break;
	}
}

foods (* = uses meta)
hardtak tortilla cornmeal cornbread
flour cheese wine bread
mead ale scotch ethenol
grapes fig date plum
apple banana apricot papaya
orange pear pinapple coconut
kiwi dragonfruit durin peach
grapefruit lemon lime citron
spinach artichoke asparagus bamboo
cucumbers zuccini pickles squash
carrot corn potato celery
brocoli lettuce cabbage kale
cauliflower raddish turnip beets
rhubarb pumpkin avacodo jalapenos
beans greenbeans tomato eggplant
blackolives greenolives garlic onions
watercress chives ketchup mustard
parsly sage rosmary thyme
basil oregano allspice nutmeg
salt bellpeppers peppercorns redpepper
vanillabean cinnimonstick cocoabean sugarbeet
walnut pecan cashew peanut
sunflowerseed pistachio almond chestnuts
cranberrys blueberrys raspberry blackberry
strawberry cherry peppermint pawpaw
sugarcane syrup* molasses honey
seseme poppy fennel eyeofnewt
mushroom* truffel penecillin yeast
barly wheat rye rice
ginger sasafrass blueraspberries bubbles 
geletin starch creamoftartar bakingpowder
vinager bakingsoda calciumhydroxide hemlock
popcorn nachos cookies milk
pasta(uncooked) pasta ramen(uncooked) ramen*
dumplings(uncooked) dumplings* tofu(uncooked) tofu
meatballs marinara alfredosauce parmisian
lasagnia* pizza* spaghetti alfredo
spaghetti&meatballs ramen&dumplings chickenalfredo brocllialfredo
guacamole nachos* chili salsa
pie* cake* soda* chips
salad* hotdog* hamburger* fries
vanilla cinnimon chocolate sugar
cocoapowder cocoabutter cocoaliquor fudge
egg shortening/fat* caramel butterscotch
sourcream butter mayo dressing*
pie* piealamode* englishfruitcake bread*
cake* pancake* waffle* stackofpancakes*
frozenpancake frozenwaffle flavoredmilk* juice*
roast* gravy xandgravy* xchicken*
bakedpotato loadedbakedpotato mashpotatos tatties&neeps
sunnysideup overeasy scrambled hardboiled
bacon sausage jerky* spam
nutbrittle* trailmix rasin* peanutbuttersandwich*
baconlettucetomatosandwich clubsandwich fingersandwich* coldcutsandwich*
milkshake* icecream* sorbet* icecreamfloat*
icecreamcone* banannasplit neopolitan rockyroad
gumdrop* hardcandy* candycane filledchocolate*
jelly* jam* preserves* peanutbutter
icecube snow ember dropletoflifeforce
broth* stew* ration mistake
