/* Hey, you. yeah, you. who do you think I'm talking to; the mouse?
 *
 * you found the seeecret extended documentation, aka the source code!
 * the sorce code, and witty comments, are intended to supplement the
 * manpages, as well as give a deeper understanding of the program.
 *
 * enviromental requirements:
 * - UTF-8 terminal of at least 25*80 characters
 * 	"Fixed" font is recommended (specifically because
 * 		it is a raster font; monospaced raster fonts are more uniform in width than the majority of vector so-called "monospaced" fonts;
 * 		it is unicode, having a wide range of characters; and
 * 		it is extreamly common, being the default font for the linux console, xterm, and urxvt)
 * - 16 or more fg colors, 8 or more bg colors, said colors are CGA compatible
 * 	(ncurses should take care of this, but ncurses only requires 8 fg colors)
 * - Bold, Underline, Reverse, Blink, Invisible text effects
 * 	(ncurses will take care of this)
 * - Full Keyboard, Mouse
 * 	(most keyboard layouts with all ASCII characters *should*
 * 	work, but only QWERTY (US-ANSI) was used in design because
 * 	I don't have access to any others, so at best controls may
 * 	be strange on them.
 * 	want to eventually guaruntee support for other keymappings;
 * 	not just for other QWERTY layouts, but also for QWERTZ, AZERTY,
 * 	and Dvorak, by request and/or the ability to remap keys
 * 	by dotfiles.)
 *
 * Controls:
 * - number keys or arrow keys move in xy
 * - page up and page down move in z
 * - spacebar or 5 idle
 * - ! shows or hides sense trouble
 * - . picks up items
 * - \ initiates the command console
 * more tbd
 *
 * new saved worlds will be generated by a seperate program.
 *
 * depending on RAM or Disk usage of the final program, it may be necissary
 * to run early versions in the system console to prevent resource starvation,
 * or to use a dedicated memory stick for the save files for the same reason.
 * if such requirements arise, they will be considered a severe flaw and work
 * will focus on fixing them as soon as possible.
 *
 * most variables can change at runtime, especially linked lists.
 *
 * currently, the following OS calls are used to expidite a proof-of-concept.
 * ideally, these will all be internalized later (...okay, MUCH later):
 *
 * beep
 * tar, both bz2 and gz in different cases
 *
 * this list may also include cat if the internalized drop-in replacement barfs during testing
 * note that some distrobutions have screwy perms for beep, which will result in
 * sound only being avalible for root; this is a bug beyond my relm of influence.
 * these distros will probably not support sound after beep has been replaced with
 * a midi library either.
 */

/**standard libraries**/
#ifndef _XOPEN_SOURCE_EXTENDED
#define _XOPEN_SOURCE_EXTENDED
#endif
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <math.h>
#define SQRT3 1.732050807568877293528
#include <limits.h>
#include <time.h>
#include <string.h>

#ifndef __STDC_ISO_10646__
#warning This program MUST HAVE UNICODE. Are you SURE this system has it?
#endif

/**system libraries**/
#include <unistd.h>
#include <signal.h>
//#include <regex.h>
//#include <sys/types.h>
//#include <sys/ioctl.h>
//#include <fcntl.h>
//#include <sys/stat.h>

/**ncurses libraries**/
#include <ncursesw/ncurses.h>
#include <menu.h>
/**curses libforms**/
#include <forms.h>

/*ENVIROMENTALS*/
#define BUFFER_MAX 512
#define GAMENAME "Default Game"
#define GM_VERSION "0.0"
#define DEVEL_STATE "Prealpha"
#define SAVE_FORMAT "original archived raw dump"
#define COMPR_VERS "system call - "COMPRESSIONCALL
#define SND_VERS "system call - "SNDCALL
#define REV_RULES "0.0"
#define REV_EVENTS "0.0"
#define REV_FILES "0.0"
/* version: Major.Minor.Hotfix
 * revision: Changes.Fixes
 */

/*FUNCTION MACROS*/
#define BRIGHT 010
#define BACKGROUND 0x10
/* example: (BACKGROUND*COLOR_BLUE)+BRIGHT+COLOR_RED
 * color pairs are a complete 16 * 8 CGA color combination grid
 */

#define MAX(A,B) (A > B ? A : B)
#define MIN(A,B) (A < B ? A : B)
#define CLAMP(N,A,B) MIN(MAX(N,A),B)
#define ≥ >=
#define ≤ <=
#define COMPR_CALL "tar"
#define COMPR_FLAGOPENSMALL "xjf"
#define COMPR_FLAGOPENFAST "xzf"
#define COMPR_FLAGCLOSESMALL "cjf"
#define COMPR_FLAGCLOSEFAST "czf"
#define SND_CALL "beep"

//ℰ will be used to abbriviate "and" the conjunction, to avoid ambiguity with the usage of & and && as "and" the function

/*TYPES*/
#define uchar16t unsigned char16_t
#define uint unsigned int
#define sint signed int
#define uchar unsigned char
#define schar signed char
#define ushort unsigned short
#define sshort signed short
#define ulong unsigned long
#define slong signed long
#define ulonglong unsigned long long
#define slonglong signed long long
typedef uchar16t Rune
#define tern schar

/* the 3d version of Iwannafly started off as a general RT-RPG library that
 * then became narrowed to a specific game. this version was originally
 * supposed to be the same game reworked for ncurses,
 * but is now becoming closer to the general library concept,
 * similar to a RPG ruleset that allows creation of
 * your own setting and plot (you know the one).
 * a default one will be provided, however, based on the 3d game's story,
 * but extended well beyond the projected capabilities of that engine.
 */

setlocale(LC_ALL, "");
cbreak();
noecho();
keypad(stdscr, TRUE);

/* backslash enters console mode. characters are fetched and printed
 * with ncurses, as well as stored in a temporary file.
 * autocomplete will be implemented, using a gradually diminishing
 * linked list of sixbit matches between your ascii and the command's
 * radix-50 name. once only one match remains, it will be shown
 * on-screen in reverse video mode, and can be inserted with tab.
 * autocomplete is not implemented for item or entity names;
 * spaces in these are replaced by underscore.
 *
 * once the enter key is pressed, the temp file is rewound.
 * fscanf is used to process tokens.
 * interpretation mode will change depending on the syntax.
 * invalid commands may produce the response
 * "Don't know how to <command>", amoungst others.
 *
 * a command will be provided to dump objects as ini, json, or xml.
 * text fields will show both their raw value and their text
 * value in the correct encoding. using this comand to get
 * out-of-character information is cheating, but no penalty
 * can be implemented, as it would effect it's functionality.
 *
 * only a number of expected variables may be dumped this way;
 * true debugging should use GDB.
 */

enum cli_argstypes
/* used to specify the type of the buffer that tokens are
 * parsed into. types can be:
 *
 * argstype_wish (*heldobjtyp) (*heldobjtyp)[2] (*heldobjtyp)[4]
 * argstyp_ent symtabref argstyp_equip equipenum
 *
 * container types will also allocate suitable contents
 * once objid has been resolved
 */

typedef cli_func *int(*void)

enum commandenum
uchar16t commandstabs[256][4] //uchar16t[4] easily converts to fourbysix[3]
cli_func commandtable[256]
cli_argstypes commandargs[256]

struct cli_matches {
(self) *prev
(self) *next
fourbysix text[3]
symtabref id
}

struct argstyp_wish {
uchar stack
objid type
void* data
}

struct argstyp_ent {
bool shift
uchar race
bool stoned
}

struct argstyp_equip {
equipenum slot
heldobjtyp* item
}

struct hintyp {
(self) *prev
(self) *next
eventidentyp eventident
char* text
}
//initially loaded from a C0-deliminated .dat file; manipulated by events.

struct 

/* typedef struct Rune {
 * ulong sym : 24;
 * bool bold : 1;
 * bool italic : 1;
 * bool under : 1;
 * bool strike : 1;
 * bool over : 1;
 * bool reverse : 1;
 * bool blink : 1;
 * bool invis : 1;
 * } Rune; //not needed
 */

struct fourbysix {
uchar a : 6
uchar b : 6
uchar c : 6
uchar d : 6
}

uchar16t squoze(string)
char string[3]
{
uchar char1
uchar char2
uchar char3
switch (string[0]) {
	case 'A' : noop();
	case 'a' :
		char1=01;
		break;
	case 'B' : noop();
	case 'b' :
		char1=02;
		break;
	case 'C' : noop();
	case 'c' :
		char1=03;
		break;
	case 'D' : noop();
	case 'd' :
		char1=04;
		break;
	case 'E' : noop();
	case 'e' :
		char1=05;
		break;
	case 'F' : noop();
	case 'f' :
		char1=06;
		break;
	case 'G' : noop();
	case 'g' :
		char1=07;
		break;
	case 'H' : noop();
	case 'h' :
		char1=010;
		break;
	case 'I' : noop();
	case 'i' :
		char1=011;
		break;
	case 'J' : noop();
	case 'j' :
		char1=012;
		break;
	case 'K' : noop();
	case 'k' :
		char1=013;
		break;
	case 'L' : noop();
	case 'l' :
		char1=014;
		break;
	case 'M' : noop();
	case 'm' :
		char1=015;
		break;
	case 'N' : noop();
	case 'n' :
		char1=016;
		break;
	case 'O' : noop();
	case 'o' :
		char1=017;
		break;
	case 'P' : noop();
	case 'p' :
		char1=020;
		break;
	case 'Q' : noop();
	case 'q' :
		char1=021;
		break;
	case 'R' : noop();
	case 'r' :
		char1=022;
		break;
	case 'S' : noop();
	case 's' :
		char1=023;
		break;
	case 'T' : noop();
	case 't' :
		char1=024;
		break;
	case 'U' : noop();
	case 'u' :
		char1=025;
		break;
	case 'V' : noop();
	case 'v' :
		char1=026;
		break;
	case 'W' : noop();
	case 'w' :
		char1=027;
		break;
	case 'X' : noop();
	case 'x' :
		char1=030;
		break;
	case 'Y' : noop();
	case 'y' :
		char1=031;
		break;
	case 'Z' : noop();
	case 'z' :
		char1=032;
		break;
	case '$' :
		char1=033;
		break;
	case '.' :
		char1=034;
		break;
	case '%' :
		char1=035;
		break;
	case '0' :
		char1=036;
		break;
	case '1' :
		char1=037;
		break;
	case '2' :
		char1=040;
		break;
	case '3' :
		char1=041;
		break;
	case '4' :
		char1=042;
		break;
	case '5' :
		char1=043;
		break;
	case '6' :
		char1=044;
		break;
	case '7' :
		char1=045;
		break;
	case '8' :
		char1=046;
		break;
	case '9' :
		char1=047;
		break;
	default :
		char1=0;
		break;
	}
switch (string[1]) {
	case 'A' : noop();
	case 'a' :
		char2=01;
		break;
	case 'B' : noop();
	case 'b' :
		char2=02;
		break;
	case 'C' : noop();
	case 'c' :
		char2=03;
		break;
	case 'D' : noop();
	case 'd' :
		char2=04;
		break;
	case 'E' : noop();
	case 'e' :
		char2=05;
		break;
	case 'F' : noop();
	case 'f' :
		char2=06;
		break;
	case 'G' : noop();
	case 'g' :
		char2=07;
		break;
	case 'H' : noop();
	case 'h' :
		char2=010;
		break;
	case 'I' : noop();
	case 'i' :
		char2=011;
		break;
	case 'J' : noop();
	case 'j' :
		char2=012;
		break;
	case 'K' : noop();
	case 'k' :
		char2=013;
		break;
	case 'L' : noop();
	case 'l' :
		char2=014;
		break;
	case 'M' : noop();
	case 'm' :
		char2=015;
		break;
	case 'N' : noop();
	case 'n' :
		char2=016;
		break;
	case 'O' : noop();
	case 'o' :
		char2=017;
		break;
	case 'P' : noop();
	case 'p' :
		char2=020;
		break;
	case 'Q' : noop();
	case 'q' :
		char2=021;
		break;
	case 'R' : noop();
	case 'r' :
		char2=022;
		break;
	case 'S' : noop();
	case 's' :
		char2=023;
		break;
	case 'T' : noop();
	case 't' :
		char2=024;
		break;
	case 'U' : noop();
	case 'u' :
		char2=025;
		break;
	case 'V' : noop();
	case 'v' :
		char2=026;
		break;
	case 'W' : noop();
	case 'w' :
		char2=027;
		break;
	case 'X' : noop();
	case 'x' :
		char2=030;
		break;
	case 'Y' : noop();
	case 'y' :
		char2=031;
		break;
	case 'Z' : noop();
	case 'z' :
		char2=032;
		break;
	case '$' :
		char2=033;
		break;
	case '.' :
		char2=034;
		break;
	case '%' :
		char2=035;
		break;
	case '0' :
		char2=036;
		break;
	case '1' :
		char2=037;
		break;
	case '2' :
		char2=040;
		break;
	case '3' :
		char2=041;
		break;
	case '4' :
		char2=042;
		break;
	case '5' :
		char2=043;
		break;
	case '6' :
		char2=044;
		break;
	case '7' :
		char2=045;
		break;
	case '8' :
		char2=046;
		break;
	case '9' :
		char2=047;
		break;
	default :
		char2=0;
		break;
	}
switch (string[3]) {
	case 'A' : noop();
	case 'a' :
		char3=01;
		break;
	case 'B' : noop();
	case 'b' :
		char3=02;
		break;
	case 'C' : noop();
	case 'c' :
		char3=03;
		break;
	case 'D' : noop();
	case 'd' :
		char3=04;
		break;
	case 'E' : noop();
	case 'e' :
		char3=05;
		break;
	case 'F' : noop();
	case 'f' :
		char3=06;
		break;
	case 'G' : noop();
	case 'g' :
		char3=07;
		break;
	case 'H' : noop();
	case 'h' :
		char3=010;
		break;
	case 'I' : noop();
	case 'i' :
		char3=011;
		break;
	case 'J' : noop();
	case 'j' :
		char3=012;
		break;
	case 'K' : noop();
	case 'k' :
		char3=013;
		break;
	case 'L' : noop();
	case 'l' :
		char3=014;
		break;
	case 'M' : noop();
	case 'm' :
		char3=015;
		break;
	case 'N' : noop();
	case 'n' :
		char3=016;
		break;
	case 'O' : noop();
	case 'o' :
		char3=017;
		break;
	case 'P' : noop();
	case 'p' :
		char3=020;
		break;
	case 'Q' : noop();
	case 'q' :
		char3=021;
		break;
	case 'R' : noop();
	case 'r' :
		char3=022;
		break;
	case 'S' : noop();
	case 's' :
		char3=023;
		break;
	case 'T' : noop();
	case 't' :
		char3=024;
		break;
	case 'U' : noop();
	case 'u' :
		char3=025;
		break;
	case 'V' : noop();
	case 'v' :
		char3=026;
		break;
	case 'W' : noop();
	case 'w' :
		char3=027;
		break;
	case 'X' : noop();
	case 'x' :
		char3=030;
		break;
	case 'Y' : noop();
	case 'y' :
		char3=031;
		break;
	case 'Z' : noop();
	case 'z' :
		char3=032;
		break;
	case '$' :
		char3=033;
		break;
	case '.' :
		char3=034;
		break;
	case '%' :
		char3=035;
		break;
	case '0' :
		char3=036;
		break;
	case '1' :
		char3=037;
		break;
	case '2' :
		char3=040;
		break;
	case '3' :
		char3=041;
		break;
	case '4' :
		char3=042;
		break;
	case '5' :
		char3=043;
		break;
	case '6' :
		char3=044;
		break;
	case '7' :
		char3=045;
		break;
	case '8' :
		char3=046;
		break;
	case '9' :
		char3=047;
		break;
	default :
		char3=0;
		break;
	}
}
return (char1*1600)+(char2*40)+char3
}

coord3 unsquoze(squozed)
uchar16t squozed
{
coord3 return
if (squozed > 63999) {ERROR_GRAPHIC("tried to unsquoze invalid RADIX-50 hash",squozed,63999,false}
tmp = div(squozed,1600)
char1 = tmp.quot
tmp = div(div.rem,40)
char2 = tmp.quot
char3 = tmp.rem
//convert back to ascii
}

char isosqueeze (unichar)
Rune unichar
{
if (unichar > UCHAR_MAX) {
	switch unichar {
	case 0x2301 : {return 0x04}	//add symbols for C0
	case 0x237E : {return '\a'}
	case 0x232B : {return '\b'}
	case 0x2318 : {return 0x11}
	case 0x21D1 : {return 0x12}
	case 0x2325 : {return 0x13}
	case 0x2324 : {return 0x14}
	case 0x238B : {return 033}
	case 0x20AC : {return 0x80}	//add a subset of windows-1252 since control codes are not being used
	case 0x0192 : {return 0x83}
	case 0x2026 : {return 0x85}
	case 0x2022 : {return 0x95}
	case 0x2030 : {return 0x89}
	case 0x0160 : {return 0x8A}
	case 0x0161 : {return 0x9A}
	case 0x2039 : {return 0x8B}
	case 0x203A : {return 0x9B}
	case 0x0152 : {return 0x8C}
	case 0x0153 : {return 0x9C}
	case 0x017D : {return 0x8E}
	case 0x017E : {return 0x9E}
	case 0x0178 : {return 0x9F}
	else {return 0x1A}	//C0 control character SUBstitute
else {return (char) (unichar | 0x00FF)}
}

Rune isoexpand (isochar,do_c0)
char isochar
bool do_c0
{
/*sanitize*/
if ((isochar < ' ') && !do_c0)
	switch isochar {
		case '\0' : {return 0x2400}
		case 0x04 : {return 0x2301}
		case '\a' : {return 0x237E}
		case '\b' : {return 0x232B}
		case '\t' : {return ' '}
		case '\n' : {return '\n'}
		case '\v' : {return '\n'}
		case '\f' : {return '\n'}
		case '\r' : {return '\n'}
		case 0x11 : {return 0x2318}
		case 0x12 : {return 0x21D1}
		case 0x13 : {return 0x2325}
		case 0x14 : {return 0x2324}
		case 033 : {return 0x238B}
		case 0x1C : {return '\n'}
		case 0x1D : {return ';'}
		case 0x1E : {return ','}
		case 0x1F : {return ' '}
		default : {return 0xFFFD}
	}
else if ((isochar > '\x7E') && (isochar < '\xA1')) {
	switch isochar {
		case 0x7F : {return 0x2326}
		case 0x80 : {return 0x20AC}
		case 0x83 : {return 0x0192}
		case 0x85 : {return 0x2026}
		case 0x95 : {return 0x2022}
		case 0x89 : {return 0x2030}
		case 0x8A : {return 0x0160}
		case 0x9A : {return 0x0161}
		case 0x8B : {return 0x2039}
		case 0x9B : {return 0x203A}
		case 0x8C : {return 0x0152}
		case 0x9C : {return 0x0153}
		case 0x8E : {return 0x017D}
		case 0x9E : {return 0x017E}
		case 0x9F : {return 0x0178}
		case 0xA0 : {return 0x237D}
		default : {return 0xFFFD}
	}
else if (isochar == 0xAD) {return '-'}
else {return isochar}
}

/* the game's internal representation uses 6 different character sets:
 * - UTF-8 for all input and output, as well as external text storage
 * - UCS-2 for internal unicode text
 * - ISO-8859-1 (with extentions from Windows-1252 and Mac-Roman) for most other internal text
 * - DEC-SIXBIT for 4:3 lossy compression of ascii text
 * - RADIX-50 (16 bit) for 3:2 lossy compression of ascii text
 *
 * the game does not use EBCDIC.
 */

uint mainh__roll (num,side,low)
uchar num;	//number of dice to roll
uchar side;	//sides on each die
bool low;	//low number on each die
{
uint accum;
uint tmp;
for (uchar n = 0;n<num;n++) {
	tmp = (rand() % side) + low;
	accum += tmp;
	}
return accum;
}
//XdN is (X,N,0), XDN is (X,N,1)

sshort mainh__bonus (num)
uchar num;
{
sshort accum;
schar tmp;
for (uchar n = 0;n<num;n++) {
	tmp = (rand() % 3) - 1;
	accum += tmp;
	}
return accum;
}

#define mainh__flip (rand() % 2)

#define MISSING_FILE(F) fprintf(stderr,"File \"%s\" not found",F); move(0,24); attron(COLOR_PAIR((BACKGROUND*COLOR_RED)+BRIGHT+COLOR_WHITE); printw("File \"%s\" not found",F); attroff(COLOR_PAIR((BACKGROUND*COLOR_RED)+BRIGHT+COLOR_WHITE);

file_cat (path)
const char *path;
{
FILE *tmp = fopen(path,"r");
int lines;
if (tmp == NULL) {
	MISSING_FILE(path);
	return -1;
	}
char tmpbuffer[BUFFER_MAX];
for (bool n = TRUE;n;noop()) {
	if (fgets(tmpbuffer,BUFFER_MAX,tmp) == NULL) {
		n = FALSE;
		} else {
		printf(tmpbuffer);
		lines++;
		}
	}
fclose(tmp);
return lines;
}

/* should also output __FILE__ and __LINE__, which will likely be the program's version of
 * undecipherable hex codes to anyone not extreamly fammiliar with the source. less severe
 * errors will prompt for [Q]uit, [A]bort, or [Z] continue. more severe ones will prompt
 * [Q]uit, [A]bort, [Z] restart. When other keyboard layout options are supported, QAZ will
 * be replaced with the left column of letters (under 1). replacements for QAZ might be:
 * QAY, AQW, "A:, FUJ. if Q or A are present in this group, they will be [Q]uit and [A]bort,
 * swapping places with the other option. otherwise, the quit-abort-option3 order will be kept.
 */
ERROR_GRAPHIC(string,num1,num2,hard)
char* string
ulong num1 num2 //since the program plays it fast and loose with number formatting and storage, only hex values are given
bool hard
{
char* opt3
if (hard) {
	attron(A_REVERSE,COLOR_PAIR((BACKGROUND*COLOR_RED)+BRIGHT+COLOR_YELLOW)
	opt3 = "Restart"
	}
else {
	attron(A_REVERSE,COLOR_PAIR(BRIGHT+COLOR_YELLOW)
	opt3 = "Continue"
	}

move( 0,0); printw("*┐  Error!")
move( 1,0); printw("▗█▖  \"%s\"",string)
move( 2,0); printw("███ N1 = $%08lX",num1,num1) //note: char is hh, short is h, long is l, long long is ll
move( 3,0); printw("▝█▘ N2 = $%08lX",num2,num2)

move( 5,0); printw("File: %s",__FILE__)
move( 6,0); printw("Line: %i",__LINE__)

move( 8,0); printw("[Q]uit?")
move( 9,0); printw(" [A]bort?")
move(10,0); printw("  [Z] %s?",opt3)

//keytrap stuff here
}

/*GLOBALS*/
#define GRAV 3.2174	/*if you backtrack this to determine the size of a grid unit, you're trying to hard*/
playertyp PLAYER
coord3 PLAYERSHD	//position of player's shadow, for renderer
latlontyp WORLD
roomtyp ROOM
roomgentyp MAPGENBYTES[ROOF][(EQUATOR/2)+1][EQUATOR]
#define MAX_X 64	//
#define MAX_Y 24	//MAX_X ≥ MAX_Y ≥ MAX_Z
#define MAX_Z 16	//
#define CEILING ROOM.upstair.z
#define ROOF 201	//it is decreed: mortals shall fly no higher. (this means you!)
#define EQUATOR 360	//the number of rooms in the circumfrence of the sphere
shadowmask SHADOWKNOWS
shadowmask SHINEALIGHT
ulonglong TURN
nibbles TIMER
schar ALARM = -1
turntyp DATE
uchar ROOMTURN
ulonglong KILLS
char* SAVEPATH
followtype *FOLLOW_ptr	//pursuers, i.e. paid assasins, ninjas, the reaper...
eventtyp *EVNT_ptr	//FOO_ptr refers to the doubly linked list's head. the tail is FOO_ptr->prev
placetyp *PLACE_ptr
placetyp *PLACE_ptr
hintyp *hint_ptr
globalbools GLOBREG	//set to true whenever you enter a room and every day at 6am
FILE* CLIBUFFER = tmpfile()
/*end GLOBALS*/

pseudosubroutine mapgenunderground
rooms:
for 0->50 do
	roll <FOOdBAR> -> index
	rotateby 1d4
	roll 1d(MAX_Y-subrooms[index].dim.y) -> posY
	roll 1d(MAX_X-subrooms[index].dim.x) -> posX
	roll 1d(8-subrooms[index].dim.z) -> posZ
	try put subrooms[index] at (posX,posY,posZ)
	if !overlapping
		draw room
		block (room)
		register (room's doors)

struct astarparamtyp {
schar mode : 2	//+>0=replace, 0=no replace no avoid, -<0=avoid nonzero or different
schar pathtype : 2	//1=indecisive astar, 0=normal astar, -1=dijkstra-recursive astar, -2=dijkstra
uchar weightnorm : 2	//norm used with the distance grid
uchar runningnorm : 2	//norm used to keep running distance
}

struct mazealignparamtyp {
bool xalign : 1	//align to !north or +south
uchar xoff : 7
bool yalign : 1	//align to !left or +right
uchar yoff : 7
}

the following algorithems can be combined to generate terrain:
/* ortho: disallow diagonal steps.
 * internal calculations might be done as intergers if there is no reason to expect floats
 */

test_dijkstra(bool ortho,schar mode,uchar runningnorm,coord3 pointa,coord3 pointb)	//replace && taxicab && ortho would equal norm1 exactly
dijkstra(bool ortho,schar mode,uchar runningnorm,schar tile,coord3 pointa,coord3 pointb)
	//nearest node first, no information about room or relative location.

test_astar(bool ortho,astarparamtyp params,coord3 pointa,coord3 pointb)	//replace && !(taxicab || ortho) would approximate to norm2, replace && taxicab && ortho would equal norm1 exactly
astar(bool ortho,astarparamtyp params,schar tile,coord3 pointa,coord3 pointb)
	/* - operates with knowlage of the norm distance to the destination
	 * 	path heads try to move closer first, whenever possible.
	 * 	should generalize an unobstructed path to a raster line if norm distance is calculated in norm2
	 * - does not switch to a different path head until one is exausted
	 * 	(exausted: no more avalible moves, finds target, or reaches the length of the previously selected best path)
	 * 	other heads are selected longest-first; when a winning path has been found, all longer heads are dropped
	 * - when 2 equally weighted options are avalible, the head's execution continues on the path that has the most similar trajectory
	 *
	 * indecisive mode:
	 * 	- does not abort until all other active heads have reached the length of the chosen path
	 * 		node's parent is only replaced when it would result in a lower distance
	 * 		these distances are propagated by re-placing a sethydra entry at the point of update
	 *
	 * recursive mode:
	 * 	- populates the grid using dijkstra from point b instead of norm distance from b.
	 *
	 * if mode is given as -2, gives soft warning (called wrong pathfinder function, n1ℰn2 = most negative number) and then calls dijkstra()
	 */

prim(bool ortho,astarparamtyp params,schar tile,setcoord3 *coordlist)	//ortho is inherintly true
random_prim(bool ortho,astarparamtyp params,schar tile,setcoord3 *coordlist)

revkruskal(bool ortho,astarparamtyp params,schar tile,setcoord3 *coordlist)	//ortho is inherintly true
random_revkruskal(bool ortho,astarparamtyp params,schar tile,setcoord3 *coordlist)

cubefill(bool replace,schar tile,coord3 pointa,coord3 pointb)
cubeshell(bool replace,schar tile,coord3 pointa,coord3 pointb)
normfill(bool replace,schar tile,normenum norm,coord3 center,float radius)
normshell(bool replace,schar tile,normenum norm,coord3 center,float radius)

setcoord3* makemaze(uchar ceilheight,bool do_upstair,bool do_downstair,uchar gridspacing,mazealignparamtyp maze)	//sets basic aspects of the room, generates a grid of points, puts upstair, downstair, and home on that grid.

addwalls(schar tile,coord3 pointa,coord3 pointb)	//outlines all currently generated tiles inside pointa and pointb
replacetiles(schar foo,schar bar)

attractor(bool replace,schar tile,setcoord *coordlist,uchar iterations,bool invert)
	/* uchar xcoord = roll 1dMAX_X
	 * uchar ycoord = roll 1dMAX_Y
	 * uchar zcoord = roll 1dCEILING
	 *
	 * uint rotate = random()
	 * for (;rotate;rotate--) {coordlist = coordlist->next}
	 * xcoord = (xcoord + list->x) / 2
	 * ycoord = (ycoord + list->y) / 2
	 * zcoord = (zcoord + list->z) / 2
	 * if ( (!tile(xcoord,ycoord,zcoord) || (replace) ) {put tile (xcoord,ycoord,zcoord)}
	 *
	 * for (;iterations;iterations--) {
	 * 	uint rotate = random()
	 * 	for (;rotate;rotate--) {coordlist = coordlist->next}
	 * 	xcoord = (xcoord + list->x) / 2
	 * 	ycoord = (ycoord + list->y) / 2
	 * 	zcoord = (zcoord + list->z) / 2
	 * 	if ( (!tile(xcoord,ycoord,zcoord) || (replace) ) {put tile(xcoord,ycoord,zcoord)}
	 *	}
	 */

spikenoise(replace,tile,floor or ceiling)
	/* generate a (MAX_X/4) by (MAX_Y/4) array of random vector2's. 
	 * make an 8*8 gradient from a vector.
	 * sum it onto a MAX_X*MAX_Y array of values, spaced every 4 lines, each quadrent overlapping.
	 * values of less than zero are flat, values greater are spikes.
	 */

hailofdice(replace,tile,number)
	//while number { roll(1dMAX_X,1dMAX_Y,1dCEILING); put tile; number--; }

/* If no room exists, check ║2║∞ radius for existing or fixed rooms,
 * generate any rooms in a ║1║∞ radius of these rooms && a ║1║∞ radius
 * of the room to be generated, with borders saned. THEN check a ║1║∞
 * radius for existing rooms, and generate the room with borders saned.
 * While this is being done, show "Generating map..." at line 13, col 5.
 * Since it involves not just file operations, but also tar, this will
 * be painfully slow, but otherwise could cause players to end up inside
 * a wall or outside the map when rooms are panned.
 *
 * ("saned" borders prevent this by making edge obstructions unbreakable.
 * floor heights are also uniform accross spherical shells when possible.)
 */

/* ai can use modifyed versions of dijkstra or any of tha astar varients
 * particularly, they must be able to handle multiple destinations for the aggro ais
 * or the ability to cycle through a list of checkpoints for passive ais
 */

struct turntyp:
uchar sec : 6
uchar min : 6
uchar hour : 5
uchar day : 5
uchar weekday : 3
uchar month : 4
ushort year : 11

bool ticktock() {
TURN++;
TIMER.lo++;
if ((TIMER.lo == TIMER.hi) && (ALARM ≥ 0)) {ALARM++}
if (ROOMTURN < 200) {ROOMTURN++;}
DATE.sec += 6;
if (DATE.sec ≥ 60) {
	DATE.sec = 0;
	DATE.min++;
	if (DATE.min ≥ 60) {
		DATE.min = 0;
		DATE.hour++;
		if (DATE.hour ≥ 24) {
			DATE.hour = 0;
			DATE.weekday++
			if (DATE.weekday ≥ 7) {DATE.weekday = 0;}
			DATE.day++;
			if (DATE.day ≥ 30) {
				DATE.day = 0;
				DATE.month++;
				if (DATE.month ≥ 12) {
					DATE.month = 0;
					DATE.year++;
				}
			}
		}
	}

GLOBREG.MIDNIT = ((DATE.hour == 0) && !(DATE.min))
GLOBREG.MORN = ((DATE.hour == 6) && !(DATE.min))
GLOBREG.NOON = ((DATE.hour == 12) && !(DATE.min))
GLOBREG.EVE = ((DATE.hour == 18) && !(DATE.min))
GLOBREG.DAY = ((6 ≤ DATE.hour) && (DATE.hour < 18))
GLOBREG.NIGHT = ((DATE.hour < 6) || (18 ≤ DATE.hour))
}

//cartesian projection, →x ↓y ↑z (+y=-z)

struct coord3:
uchar x
uchar y
uchar z

struct coord2:
uchar x
uchar y

struct scoord3:
schar x
schar y
schar z

struct scoord2:
schar x
schar y

struct mapcoord3:
uchar x : 6
uchar y : 5
uchar z : 4
bool w : 1

struct paramtyp {
ushort a
ushort b
ushort c
ushort d
eventidentyp eventident
}

struct nibbles {
uchar lo : 4
uchar hi : 4
}

struct vector2:
float x
float y

struct vector3:
float x
float y
float z
/* used for velocity, a parameter that holds
 * motion that carries accross turns. this motion
 * is not always cleared after being done; horizontal
 * velocity persists until a tile with friction is
 * encountered, while downwards vertical velocity 
 * accumulates and persists until the ground is encountered.
 */

struct pvector {
unsigned char az : 4
unsigned char r : 12
}

struct polar {
uchar az : 3	//azimuth
schar el : 2	//elevation
schar slope : 3	//negative is inverse slope, most negative is undefined. defines a cone.
uchar r : 5	//radius
bool omni : 1	//omnidirectional
bool not : 1	//invert the mask defined by slope
bool behind : 1	//EQUATOR/2 degrees are added to azimuth
}
/* amoungst other uses, defines the cone of vision
 * and used to generate magic beams
 *
 * for all azimuths:
 *
 * 701
 * 6 2
 * 543
 *
 * for all elevations:
 *
 * +1
 *  0  ?-2?
 * -1
 */

struct setcoord3:
(self) *prev
(self) *next
uchar x
uchar y
uchar z

struct patrolistyp {
(self) *prev
(self) *next
setcoord3* start

struct setpoints:
(self) *prev
(self) *next
coord3 pointa
coord3 pointb

struct setpathnode {
bool dead : 1	//no avalible paths
bool win : 1	//selected path
unsigned char az : 3	//az and el point to parent; ((az+4)%8,-el) is the trajectory of the node.
signed char el : 3	// -2,-1,0,1,2 are valid, 3 is starting point
float runningdist	//calculated running shortest-path distance from point a.
float goaldist	//norm distance from point b

struct sethydra:
(self) *prev
(self) *next
setpathnode* node

//some specific uses call for spheres. these are simply numeric types.

float norm2(pointa,pointb)
coord3 pointa
coord3 pointb
{
sshort xrel = pointb.x - pointa.x;
sshort yrel = pointb.y - pointa.y;
sshort zrel = pointb.z - pointa.z;
return root( ((float) xrel * xrel) + ((float) yrel * yrel) + ((float) zrel * zrel) );
}

ushort norm1(pointa,pointb)
coord3 pointa
coord3 pointb
{
sshort xrel = pointb.x - pointa.x;
sshort yrel = pointb.y - pointa.y;
sshort zrel = pointb.z - pointa.z;
return (ushort) (abs(xrel) + abs(yrel) + abs(zrel));
}

ushort normINF(pointa,pointb)
coord3 pointa
coord3 pointb
{
sshort xrel = pointb.x - pointa.x;
sshort yrel = pointb.y - pointa.y;
sshort zrel = pointb.z - pointa.z;
return MAX(MAX(abs(xrel),abs(yrel)),abs(zrel));
}

struct diceodds:
uchar num : 3
uchar side : 5
uchar tobeat : 8

struct latlontyp {
uchar dep : 8	//0 ≤ dep ≤ 201
schar lat : 8	//-90 ≤ lat ≤ 90
sshort lon : 9	//-180 ≤ lon < 180
bool shift : 1	//are you plane shifted?
bool moon : 1	//are you on the moon?
uchar az : 3	//azimuth on a plane chart
schar el : 2
}
/* in-game altitude is given as the distance from layer 100
 *
 * when combined with shift, moon becomes outer planes
 *
 * az	elemental	afterlife	corrilation
 * 0	water		neutral good	nurturer
 * 1	ice		chaotic good	the ends justify the means
 * 2	air		chaotic neutral	princess stealing
 * 3	electricity	chaotic evil	force lightning
 * 4	fire		neutral evil	obviously
 * 5	metal		lawful evil	greed
 * 6	earth		lawful neutral	stubborn
 * 7	trees		lawful good	knowladge
 *
 * az rotates by 45 degree steps and el by 90 degree steps.
 * a nonzero el causes az to gimbal lock.
 * also best not to think about where exactly -2 is pointing.
 *
 * el	"		"		"
 * +1	light		true neutral	enlightenment
 * -1	darkness	uncomitted	meh, I'll think of one later
 * -2	entropy		oathbreakers	abandon all hope ye who enter here
 *
 * errors related to this section may generate one of 2 errors:
 * "fell off the edge of the world", N1=lat,N2=lon
 * "froze to death on pluto", N1=az,N2=el
 */

struct placetyp {
(self) *prev
(self) *next
long id
latlontyp latlon
coord3 pos
}
/* used to register places
 * if the commandline catches hex where it expects coords,
 * it searches for a place.
 *
 * names are given as 2 sets of 4 hex digits,
 * the 2 fields seperated by a hyphen. names should be unique;
 * when looking for a place by name, searching stops at the first
 * match.
 */

struct cylinder:
uchar r : 8
uchar up : 4
uchar down : 4
 /* cylinders, (the shape, not this datatype) are used extensively.
  * players move in cylindrical coordinate space.
  * event areas are specified as cylinders
  * monster aggro ranges are a cylinder
  */

struct moneytyp:
ushort gp : 17 //max 100,000
uchar cp : 7 //1 gp = 100 cp

/* crossbar logic operations are used for alignment masks.
 * these are union or intersection on special case subsets of a gridlike set of elements.
 * each operation takes subsets that are rows or columns in the grid.
 * crossbar "OR", symbol ↔∪↕, selects the entire row of elements and entire column of elements
 * crossbar "AND", symbol ↔∩↕, selects only elements that are at intersections, usu. a single element.
 * by defining a NOT operator, all other binary operators (NAND,NOR,XOR,XNOR/IFF) could be constructed.
 * since the set is cartesian, fuzzy matching of ↔∩↕ could also be used by specifying a norm and a distance.
 */
struct aligntyp:
good : b1
evil : b1
law : b1
chaos : b1
nogood : b1
noevil : b1
nolaw : b1
nochaos : b1
/* used as a mask.
 * starting alignment must be one of the high nibble (crossbar "OR" ↔∪↕ if one or more than 2 are selected, crossbar AND ↔∩↕ ║2║1 if exactly 2 are selected, true neutral ║1║1 if none are selected).
 * alignment may NEVER enter any of the low nibble, marked "no" (crossbar "OR" ↔∪↕ always, overrides whitelist).
 *
 * there are other ways that alignment masks may be specified,
 * all of which have finer grained control.
 */

struct bitfield:
a : 1
b : 1
c : 1
d : 1
w : 1
x : 1
y : 1
z : 1

struct globalbools {
NEW
FIRST
DAY
NIGHT
MORN
NOON
EVE
MIDNIT

typedef char* stabs[256] //symbol table strings
typedef void* fstab[256] //filesystem table
typedef uchar symtabref //beware of missingno glitches!

enum item_enum
enum spell_enum
enum weap_enum
enum arm_enum
enum shld_enum
enum baub_enum
stabs itemstabs //stuff that doesn't go anywhere else; i.e. arrows, keys, quest items
stabs spellstabs //spells
stabs weapstabs //weapons
stabs armstabs //armor
stabs shldstabs //shield, cannon, greeves
stabs baubstabs //rings, amulets, bracelets, tiaras
fstab itemtable
fstab spelltable
fstab weaptable
fstab armtable
fstab shldtable
fstab baubtable

char* legendstabs[20] = {"truthseeker","sword of justice","excalibur","thunderbolt"/*torch of smiting*/,"sickle of chaos"/*+drain*/,"stormbringer"/*+drain*/,"devilfork"/*+fire*/,"partisen of tyrants","deathscyth"/*+drain*/,"sunray"/*spear + solar flare*/,"nightedge"/*sword + moonbeam*/,"staff of merlin"/*staff of magic missile*/,"firebrand"/*sword + fireball*/,"tesla's mace"/*+spark*/,"stormgale"/*bow*/,"frostpike"/*+frostbite*/,"trident of the seas"/*+tsunami*/,"staff of the forest"/*staff of animante kudzu*/,"groundshaker"/*+earthquake*/,"imperial baton"/*staff of antagonizing*/}
legendtyp legendtable[20]

char* psystabs[8] = {"detect alignment","charm","hold","sleep","mind blast","passify","unhinge","terrify"}

pseudo psionic(id)
uchar id
//switch case for each psionic ability

typedef multiclasstyp:
(self) *prev
(self) *next
classtyp class

typedef classobjtyp:
classtyp class
magictyp element

typedef classtyp {
unchar role : 2
bool override : 1 //0=blacklist overrides, 1=whitelist overrides
bool wl_mode : 1 //whitelist mode: 0=crossbar "or", 1=crossbar "and"
unchar class : 3
bool trueneutral : 1
bool good : 1
bool evil : 1
bool law : 1
bool chaos : 1
bool nogood : 1
bool noevil : 1
bool nolaw : 1
bool nochaos : 1

char* roguestabs[8] = {"changeling","rogue","thief","pirate","ninja","assasin","tourist","ronan"}
char* fighterstabs[8] = {"fighter","knight","paladin","valkyrie","viking","samuri","ranger","monk"}
char* magicuserstabs[8] = {"magic-user","wizard","illusionist","enchanter","black mage","red mage","psion","necromancer"}
char* healerstabs[8] = {"healer","cleric","priest","druid","alchemist","scholar","white mage","seer"}

paffect	classtable[4][8]

enum mon1_enum
stabs mon1stabs =	//"final name", /*placeholder name*/
{"human",	"elf",		"dwarf",	"gnome",	"hobbit",	"half elf",	"drow",		/*avian*/,	"half orc",	"half dragon",	/*half celestial*/,	"tiefling",	"half air elemental",		"half water elemental",	"half earth elemental",		"half fire elemental",
"merfolk",	"seaelf",	"satyr",	"fairy",	"pixie",	"naiad",	"naga",		"dryad",	"orc",		"kobald",	"centaur",		"sphinx",	"half electric elemental",	"half ice elemental",	"half nature elemental",	"half metal elemental",
};

fstab mon1table
/* contains all polymorphable monsters, of type BASENTYPE.
 * all C0 controls should be valid starting races, or left empty,
 * any polymorphable race can BECOME your base race...
 * 
 * if you become polylocked to a non-player race, your class will be removed.
 * becoming polylocked to one of the C0 entrys has no negative effects.
 * commands can change your base race without negative side effects
 *
 * polymorph autocomplete is implemented using switches.
 *
 * entities can only be polymorphed into things in their own table.
 * this is due to a software limitation that will not be fixed,
 * as it enables species to easily be sorted into polymorphable
 * and non polymorphable by placing them on the low or high tables
 */
enum mon2_enum
stabs mon2stabs
fstab mon2table

/* MONSTERS BY LETTER
 * &: horned devil, balrog, pit feind, imp, homunculus, jubilix, drider
 * @: human, elf, half elf, drow, seaelf
 * A: astral, ætherial, celestial, archon
 * a: newt, salamander, frog, 
 * B: bear, polar bear, bugbear, owlbear,
 * b: mockingbird, parakeet, parrot, macaw, cockatoo, songbird, sparrow, starling,
 * C: satyr, centaur,
 * c: raven, rook, jackdaw, crow, jay, magpie,
 * D: wyrm, great wyrm, (△red,↯copper,◬white,*cyan,▽blue,♠green,⍫brown,$gold,☽black,☼silver,∅purple) dragon, hydra,
 * d: hellhound, wolf, dire wolf, dog, fox, cyote,
 * E: <elementals>, stalker,
 * e: floating eye,
 * F: turkey, rooster, chicken, peacock, duck, goose, swan, albatross, gull,
 * f: panther, lion, tiger, manticore, cat, lynx, bobcat, displacer beast,
 * G: ghost, banshee, revenent, barrow wight,
 * g: gremlin, gargoyle, winged gargoyle,
 * H: giant, cyclops,
 * h: dwarf, gnome, hobbit,
 * I: giant ant, giant roach, giant scarab, giant wasp, giant scorpion, giant spider,
 * i: ant, roach, scarab, wasp, scorpion, spider, firefly
 * J: djinn,
 * j: lichen, yellow mold, green mold, black mold, gelatinous cube, green slime, brown pudding, black pudding, ocher jelly, spotted jelly, blue jelly,
 * K: chickatrice, cockatrice, pyrolisk,
 * k: kobold,
 * L: skeleton, lich,
 * l: leprachaun,
 * M: gorgon,
 * m: <mummies>
 * N: naga,
 * n: merfolk, naiad, dryad,
 * O: <letter O considered harmful>
 * o: orc, half orc, uruk-hai, ogre,
 * P: fairy, pixie,
 * p: dolphin, narwhal, orca, beluga,
 * Q: elephant, mammoth, rhino,
 * q: cow, pig, buffalo,
 * R: eagle, falcon, owl, kite, vulture, phoenix,
 * r: rat, dire rat, raccoon, platypus,
 * S: cracken, shark, octopus, giant squid,
 * s: copperhead, cobra, rattlesnake, python,
 * T: lurker above, trapper, wallmaster, rust monster,
 * t: troll,
 * U: umber hulk,
 * u: unicorn, pegasus, zebra, griphon, hippogriph,
 * V: vampire, wolfman,
 * v: bat,
 * W: half dragon, half celestial, tiefling, avian, erinys, harpy, tengu,
 * w: purple worm,
 * X: velociraptor, tyrannasaurus,
 * x: grue,
 * Y: yeti, bigfoot,
 * y: ape, monkey, gorilla,
 * Z: mind flayer,
 * z: <zombies>
 * {: (flesh, straw, clay, stone, glass, paper, leather) golem, (gold, copper) automaton, hungry chest, chest monster,
 * £: justice. (has Beethoven's 5th as a lietmotif. is lawful.)
 * ∞: retribution. (has Summer - Presto as a lietmotif. is chaotic.)
 * ∈: <half elementals>
 * ☠: death. (has Toccata and Fugue in D minor as a lietmotif. bane of the strong. is true neutral.)
 * ♞: nightmare, quarterhorse, draft horse, miniature horse,
 * ⏍: hungry chest, chest monster,
 */

struct the8stats:	//8* 5D6
stren : 5
psy : 5
dex : 5
con : 5
fort : 5
intl : 5
wis : 5
bluff : 5


struct conlangtype:
symtabref id : 5
bool r : 1
bool w : 1
bool x : 1	//can be written with claws or talons

char* conlangtab[32] = {"common language","middle elvish","old elvish","dwarvish", "gnomish","gothic","orkish","draconic", "fey","celestic","demonic","blackspeech", "skyspeak","waterspeak","earthspeak","firespeak",
	"thieves cant",/*?*/,/*?*/,/*?*/, /*?*/,/*?*/,/*?*/,/*?*/, /*?*/,/*?*/,/*?*/,/*?*/, "electric","icespeak","treespeak","metallic"}
bitfield conlangx[4] = {{false,false,true,true, true,true,true,true},{false,false,true,true, true,false,true,true},{true, },{, true,true,true,true}}

struct playertyp:
classobjtyp class
multiclasstyp *MULTICLASS
symtabref baserace
symtabref polyrace
shiftertyp polycounter
coord3 loc
polar facing
vector3 velo
float carryover	//leftover moves; never exceeds 2
paffectyp permenent
effectyp fromequip
scoord2 align
ushort hp	//they're fun and easy to...wait
ushort mp
uchar air
ushort uptime
ulong xp
uchar lvl
sshort food
moneytyp gold
heldobjtyp *lang_ptr
heldobjtyp *spell_ptr
heldobjtyp *bag_ptr
bitfield psyattack
subobjtyp weap_left	//weapon
subobjtyp weap_right	//weapon
subobjtyp shield	//shld
subobjtyp bow	//weapon
subobjtyp armor	//armor
subobjtyp cape	//armor
oneobjtyp helm	//any item
subobjtyp gloves	//armor
subobjtyp cannon	//shld
subobjtyp boots	//armor
subobjtyp greev	//shld
subobjtyp amul	//baub
subobjtyp ringl	//baub
subobjtyp ringr	//baub
subobjtyp wristl	//baub
subobjtyp wristr	//baub

enum equipenum = {ENUM_WEAP_LEFT,ENUM_WEAP_RIGHT,ENUM_SHIELD_ENUM_BOW,ENUM_ARMOR,ENUM_CAPE,ENUM_HELM,
ENUM_GLOVES,ENUM_CANNON,ENUM_BOOTS,ENUM_GREEV,ENUM_AMUL,ENUM_RING_LEFT,ENUM_RING_RIGHT,ENUM_WRIST_LEFT,
ENUM_WRIST_RIGHT}

psudo update_player
/* resets .fromequip , then iterates through the entire equipment list to regenerate it.
 * must be called every time equipment is changed to ensure that it is up to date
 * effects in .permenent can only be removed by finding something that affects the opposite change
 * changes to your starting alignment or role are generally rare and disasterous, as they represent
 * the corruption of the character in some way. changes to your race may also be inconvenient,
 * but not necissarily bad. (I.E. late game events may change a player into a powerful
 * non-starting race as part of the story, such as a drider, full elemental, or dragon.)
 *
 * this may be done automatically when you sleep.
 */

pseudo inventsort
/* compresses stackable items into stacks, sorts items by objid and itemid.
 * more computationally expensive than update_player.
 */

pseudo force_global
/* forces some queued globals to be loaded. takes a very long time, but can
 * sometimes be necissary if the global buffer is bogged down.

int itemswap (item1,item2)
heldobjtyp *item1
heldobjtyp *item2
{
heldobjtyp *prev1 = item1->prev
heldobjtyp *prev2 = item2->prev
heldobjtyp *next1 = item1->next
heldobjtyp *next2 = item2->next
if (item1->next = item2) {
	prev1->next = item2
	item2->prev = prev1

	item2->next = item1
	item1->prev = item2

	next2->prev = item1
	item1->next = next2
	}
if (item2->next = item1) {
	prev2->next = item1
	item1->prev = prev2

	item1->next = item2
	item2->prev = item1

	next1->prev = item2
	item2->next = next1
	}
else {
	prev1->next = item2
	item2->prev = prev1

	next1->prev = item2
	item2->next = next1

	prev2->next = item1
	item1->prev = prev2

	next2->prev = item1
	item1->next = next2
	}
}

struct basentyp:
aligntyp alignmask
aggrotype aggro	//here, shiftable denotes a monster's aggro state is locked. also gives the value that patience is set to when a monster calms down, the value that cooldown is set to when it is angered, and the default AI.
paffectyp base
venomtyp venom
uchar spd	//distance calculations use M_SQRT2 for diagonals
uchar hplvl
uchar mplvl
uchar xplvl
uchar airmax	//how long you can hold your breath
symtabref lang0 : 6
symtabref lang1 : 6
symtabref spell0
symtabref spell1
symtabref spell2
symtabref spell3
bitfield psyattack
Rune unichar
bool unaligned : 1
bool keepindark : 1
schar size : 2
uchar color : 8
/* entitys of size 1 or -2 cannot use armor.
 * entitys of larger size automaticly win grapples.
 * entitys of 2 sizes smaller can be picked up and thrown.
 * entitys of size 1 can instakill entitys of size -2. squish.
 * size 1: dragon, size 0: human, size -1: dwarf, size -2: pixie
 */

struct aggrotyp:
bool shiftable : 1	//nowhere else to put it.
uchar patience : 3
uchar ai_type : 4
uchar anger : 7
bool unhinged : 1

struct enttyp:
(self) *prev
(self) *next
classobjtyp class
aggrotyp aggro
setcoord3* coordlist
symtabref race
coord3 loc
polar facing
vector3 velo
float carryover
paffectyp paffect
effectyp effect
ushort hp
uchar air
ushort xp
uchar lvl
moneytyp gold
subobjtyp loot
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
hattyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct followtyp:
eventidentyp eventident
classobjtyp class
aggrotyp aggro
symtabref baserace
symtabref polyrace
shiftertyp polycounter
coord3 loc
polar facing
vector3 velo
float carryover
paffectyp permenent
effectyp fromequip
scoord2 align
ushort hp
ushort mp
uchar air
ulong xp
uchar lvl
sshort food
moneytyp gold
heldobjtyp *spell_ptr
bitfield psyattack
oneobjtyp holding
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
oneobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct spawntyp:
classobjtyp class
aggrotyp aggro
symtabref baserace
paffectyp paffect
effectyp effect
oneobjtyp loot
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
oneobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct oneobjtyp {
objid type
void* data
}

struct heldobjtyp:
(self) *prev
(self) *next
uchar stack //stack+1 items are present. lumping them together is a complicated operation. 
objid type
void* data

struct subobjtyp:
symtabref itemid : 8
bool cursed : 1
bool oxide : 1
bool burned : 1
schar bonus : 5
uchar metadata : 8 //secondary symtabref for legendary objects

struct magictyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1 //entropy is not light. entropy is not darkness. entropy is balance. entropy is fate; doom; *death*. not things you want to be on the wrong end of.
bool light : 1 //light is not necisarrily good
bool dark : 1 //dark is not necisarrily evil
bool planer : 1

struct shiftertyp {
uchar polytimer : 8	//time remaining in the current polymorph. if non-zero, polyrace is used instead of baserace.
uchar polydepth : 4	//polymorphing more than 10 times without returning to your base form first change your base form to the 15th one
uchar polycount : 4	//repeating the same polymorph 10 times will make it permenant
uchar altertimer : 8	//time remaining in the current alteration.
uchar gills : 4	//using an alteration spell, including intrensics from polymorph spells, 10 times will make them permenent.
uchar lungs : 4	//these counters can be reset by rest or spells
uchar wings : 4
uchar tail : 4
uchar claws : 4
uchar fangs : 4
bodytyp alterations	//keeps track of changes. if a change becomes permenent, it is moved to paffect.
}
/* non-player, non-follower entitys do not have this field,
 * and any polymorph or alteration is permenent. this may be
 * changed in future if memory footprint allows.
 */

struct spelltyp:
symtabref itemid
diceodds odds
uchar prof

struct basespelltyp:
bool poly : 1
bool self : 1
uchar lvl : 6
magictyp type : 8
schar cost_typ : 2 //0 = at will, 1 = gold, -1 = mp, -2 = hp
uchar cost_amnt : 6
potiontyp effect
missiletyp delivery
symtabref polyref

struct psytyp:
schar cost_typ : 2 //0 = at will, 1 = gold, -1 = mp, -2 = hp
uchar cost_amnt : 6
potiontyp effect
missiletyp delivery

struct missiletyp:
bool psion : 1
bool vamp : 1
uchar damage : 8
schar recoil : 7
uchar spread : 2 //0 = line, 1 = narrow (1:3), 2 = wide (1:2), 3 = very wide (1:1)
uchar splash : 3 //radius of damage on impact
bool spz : 1 //spread and splash in the z plane.
bool dig : 1 
//if (.spread != 0), slope = 4-.spreaad

struct wavetyp {
speed : 2
sense : 2
phase : 1
direction : 3
thick : 1
tile : 7

struct baseweaptyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool illum : 1
uchar skill : 3
uchar damage : 8

legendtyp:
paffectyp magic
symtableref base
symtableref spell
legendflagtyp flags

legendflagtyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool unbreak : 1
bool infinate : 1
bool spelled : 1
bool vamp : 1
bool drain : 1
bool interest : 1
bool useless : 1
uchar powermag : 5

struct basearmortyp:
effectyp effect
uchar def
uchar spdef
uchar extfort

struct baseshldtyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool reflect : 1
bool entro : 1
bool light : 1
bool dark : 1
effectyp effect
uchar def : 8
uchar spdef : 8

struct bodytyp:
bool gills : 1	//effects breathing underwater
bool wings : 1	//effects flying
bool tail : 1	//effects unarmed attacks, swimming, flying
bool claws : 1	//effects unarmed attacks, writing
bool hoof : 1	//effects walking, swimming, unarmed attacks
bool talon : 1	//effects walking, swimming, unarmed attacks 
bool fangs : 1	//effects unarmed attacks
bool quad : 1	//effects walking, swimming, unarmed attacks
bool nolegs : 1	//effects walking, swimming, unarmed attacks
bool noarms : 1	//effects walking, swimming, unarmed attacks
bool nolungs : 1	//effects breathing above water
bool noswim : 1	//effects swimming
bool atktail : 1	//effects unarmed attacks, swimming, flying
bool atkwing : 1	//effects unarmed attacks, swimming, flying
schar atkbite : 2	//effects unarmed attacks; +1 = swallow, -1 = bite, -2 = bite ℰ breath

struct venomtyp {
elixtyp claws
elixtyp talon
elixtyp fangs
elixtyp tail
elixtyp passive
}

struct stattyp:
dizzy : u4
psn : u4
prlz : u4
frz : u4
brn : u4
stone : u4
slp : u8
invis : u8
blind : u8
eaten : u8

struct elixtyp:
dizzy : b
psn : b
prlz : b
frz : b
brn : b
stone : b
slp : b
invis : b

struct cursetyp:
stattyp type
uchar polytimer
symtabref poly

struct resistyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool stoneproof : 1
bool polyproof : 1
bool sleepproof : 1
bool poisonproof : 1

struct sensetyp:
trouble
invis
infra
blind
good
evil
law
chaos

struct effectyp:
the8stats eight
bodytyp shape
stattyp stat
resistyp resist
senstyp sense
skilltyp skill
magictyp asp
schar atk
schar spatk
schar def
schar spdef

struct paffectyp
the8stats eight
bodytyp shape
elixtyp ails_ya
elixtyp curse
resistyp resist
senstyp sense
skilltyp skill
magictyp asp
schar atk
schar spatk
schar def
schar spdef

struct potiontyp:
bodytyp shape
elixtyp ails_ya
cursetyp curse
resistyp resist
senstyp sense
sshort hp
sshort mp
diceodds odds

struct skilltyp:
uchar sword : 3 //+skill to sword-type weapon attack
uchar knife : 3 //+skill to knife-type weapon attack
uchar stave : 3 //+skill to stave-type weapon attack
uchar spear : 3 //+skill to club-type weapon attack
uchar whip : 3 //+skill to whip-type weapon range (unused range added to attack)
uchar club : 2 //+skill to club-type weapon attack
uchar bow : 4 //+(2 * skill) to bow-type weapon range
uchar throw : 4 //+(2 * skill) to javalin-type weapon range
uchar monk : 4 //+(2*skill) to unarmed attack, unlocks more modes of attack.
uchar shield : 3 //skill in (damage-defense)+abs(damage-defense) chance of blocking
uchar locks : 3 //1 in 2^(lock.level - (skill)) chance of picking
uchar caster : 6 //-(skill-1)/4 to casting cost, +(skill-1)/4 to spatk and spdef, unlocks spells, 0 is non-caster
bool swim : 1 //learned in shallow water; may be lost by polymorphing to a form with different locomotion.
bool walk : 1 //learned on land; may be lost by polymorphing to a form with different locomotion.
uchar fly : 2 //0 = never had wings, 1 = slow falling, 2 = cannot gain altitude, 3 = free flight. lvl1 learned by falling

/* damage = MAX( incoming-defense , 0 )
 *
 * polyshock = -abs(base.hplvl-poly.hplvl) * !mainh__roll(1,20,0)
 * ⎧if n < -HPMAX     : Instakill (deathmessage: miscalculated a crucial equivilant-exchange parameter,hath choose...poorly)
 * ⎪if n = -HPMAX     : Stoning
 * ⎨if -HPMAX < n < 0 : abs(n) Damage (deathmessage: could not withstand the cost of transmutation)
 * ⎪if n = 0          : stun for 1D16 (standardmessage: your mind reels from the transformation...)
 * ⎩if n > 0          : success
 */

readtyp:
uchar locale : 6
bool multiuse : 1
bool scroll : 1
uchar subject : 2 //0 = cooking, 1 = weapons, 2 = language, 3 = spellcraft
uchar uses : 6
*void contents

char* wandmaterials[16] = {"oak","ash","yew","honeylocust","silver","bronze","iron","orichalcum","marble","bone","dragon fang","unicorn horn","glass","lead crystal","adamantine","stardust"} //stoning -> marble

wandtyp:
uchar matter : 4
uchar uses : 4
symtabref bound : 8

char* baubmaterials[8] = {"yew","bronze","silver","gold","soapstone","ivory","obsidian","stardust"} //stoning -> soapstone

baubtype :
schar type : 2 //0=ring, 1=bracelet, -1=amulet, -2=tiara
uchar matter : 3
uchar color : 3
paffectyp enchnt

struct roomtyp: //top-down display of a 3d space
tileset *hightiles
schar tiledata[MAX_Z][MAX_Y][MAX_X] //entity coords refer to the 3-grid boxes of a given coord, while tiles refer to a given xy square on the plane that is the lower bound of said boxes.
shadowmask seen
encontyp *encon_ptr
patrolistyp *patrol_ptr
enttyp *ent_ptr
mapobjtyp *obj_ptr
lightyp *lamp_ptr
coord2 downstair
coord3 upstair
coord3 home
bool do_upstair : 1
bool do_downstair : 1
bool visited : 1
bool blank : 1
uchar meta : 4 //may be used by events
/* z coord of the upstair is the maximum height of the map for underground levels
 * upstair is not rendered on dep=>0, but must still be present.
 * if invalid coords are given for a warp (typically {$FF,$FF}),
 * then the player is dumped at the location indicated by home.
 *
 * if the player has invalid coords, then the error string "fell out of terminal",N1=x,N2=y is generated.
 */

struct subroomtyp: //used by mapgen
schar tiledata[MAX_Z][MAX_Z][MAX_Z]	//cube of MAX_Z
coord3 dim
enttype *ent_ptr
mapobjtyp *obj_ptr
lightyp *lamp_ptr

/*      .r8 : binary data that is organized into 8 bit segments
 *     .r16 : binary data that is organized into 16 bit segments
 *     .hex : binary data that is organized into segments that are not 8 or 16 bits
 *     .csv : UTF-8 text record deliminated with commas and line breaks
 *     .tsv : UTF-8 text record deliminated with tabs and line breaks
 *     .dat : UTF-4 text record deliminated with non-printable C0 control characters
 *     .txt : UTF-8 text document. usually stored in the program's static files, which is CAT-ed to provide dialouge; also used in dumps of primatives
 *      .sh : a shell script; almost universally music for beep in this context
 *    .conf : plugin or configuration file. may also be a dotfile.
 *     .ini : key-value pairs. used in dumps of non-nested structs that do not contain pointers.
 *    .json : originally from javascript. used in data dumps of nested structs not containing pointers.
 *     .xml : used in data dumps for pointer-containing structs. will have an href= in the tag for the pointer, linked to the dump of the pointer's deref; /dev/null if null pointer.
 *  .tar.gz : by default, each room's directory is automatically compressed using an os call to prevent disk hogging (tar -xzf to open, or tar -czf to store)
 * .tar.bz2 : by default, each plane's directory is further compressed (tar -xjf to open, or tar -cjf to store). savefiles are also this format. all compression options are changeable before compile.
 *   .man.# : a manpage
 *    .html : extended documentation
 *      .md : extended documentation
 */

music shall be in a pthread. bgm loops for(;;). music is stopped by pthread_cancel. music is started by running a beep shell script.

struct mapgen_bordertyp {
tileset *hightiles_n
schar north[MAX_Z][MAX_X]
tileset *hightiles_s
schar south[MAX_Z][MAX_X]
tileset *hightiles_e
schar east[MAX_Z][MAX_Y]
tileset *hightiles_w
schar west[MAX_Z][MAX_Y]
tileset *hightiles_u
schar up[MAX_Y][MAX_X]
tileset *hightiles_d
schar down[MAX_Y][MAX_X]
}//only used during mapgen, freed immediatly

struct shadowmask bitfield[2][MAX_Y][MAX_X]

typedef tilemeta* tileset[128]

struct tilemeta {
bool ladder : 1
bool solid : 1
bool liquid : 1
bool conductive : 1
bool burns : 1
bool hypotherm : 1
bool sharp : 1
bool entropy : 1

bool freezes : 1
bool melts : 1
bool petrif : 1
bool dig : 1

uchar color : 7
symtabref ice : 7
symtabref melt : 7
symtabref stone : 7

Rune unichar : 16
}
/* tiles can be effected by stuff happening around them.
 *
 * if a tile is flammable, a fire is summoned when fire magic
 * enters the space or 1d6 chance if there is fire within 1 taxicab of it.
 *
 * if a tile is conductive, then electricity is summoned for the instant
 * that electrical magic strikes it, and propagates through contiguous tiles.
 *
 * if a tile can freeze, it's symtabref is changed to the number indicated by ice.
 * when ice magic intersects it.
 *
 * if a tile can melt, it's symtabref is changed to the number indicated by melt
 * when fire or electrical magic intersect it.
 *
 * if a tile can be petrified, it is changed to the tile indicated by stone.
 *
 * if a tile can be dug, using a ↧digging tool on it will remove it
 */

pseudo getsym
	{
	if (sym < 0)
		{
		cursesprint(.hightiles[sym^-128]) //xor intentional
		}
	else
		{
		cursesprint(.lowtiles[sym])
		}
	}

mapobjflags:
hidden : 1
moves : 1
class : 2
wl_fuzz : 2 //taxicab radius of whitelist, around square(s) indicated by crossbar "and" (↔∩↕)
bl_mode : 1 //0 = crossbar "or" (↔∪↕), 1 = crossbar "and" (↔∩↕)

bool neutral : 1
bool law : 1
bool chaos : 1
bool good : 1
bool evil : 1

bool nogood : 1
bool noevil : 1
bool nolaw : 1
bool nochaos : 1

struct mapobjtyp:
(self) *prev
(self) *next
coord3 pos
objid type
void* data
mapobjflags flags

struct lamptyp:
(self) *prev
(self) *next
coord3 pos
uchar lum

struct chestyp:
heldobjtyp *bag_ptr
cursetyp trap
locktype locked

struct doortyp {
bool open : 1
uchar hp : 7
locktype locked : 8

struct locktype {
bool locked : 1
bool level : 3
bool pin1 : 1
bool pin2 : 1
bool pin3 : 1
bool pin4 : 1
trapflag flags : 8
/* lockpicking requires the player to enter
 * 0 and + in the correct order to turn the
 * tumblers. in addition to making the correct
 * guess, one must make a skill check:
 * 1 in 2^(lock.level - (skill/2)) chance
 */

struct encontyp {
(self) *prev
(self) *next
eventidentyp eventident
uchar tobeat	//of 10D20
spawntyp spawn

struct miscitembasetyp:
bool key : 1
bool pick : 1
bool dig : 1
bool music : 1
bool light : 1
bool book : 1
bool spark : 1
bool quest : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool stoneproof : 1
bool arrow : 1
bool poisoned : 1
bool unbreak : 1
uchar uses : 8
uchar metadata : 8

eventidentyp {	//48bit identifyer based on storyline branch information.
uchar race : 5
uchar role : 2
uchar class : 3
bool and : 1
bool fuzzy : 1
bool law : 1
bool good : 1
bool neutral : 1
bool evil : 1
bool chaos : 1
bool water : 1
bool ice : 1
bool air : 1
bool electricity : 1
bool fire : 1
bool metal : 1
bool earth : 1
bool trees : 1
bool light : 1
bool darkness : 1
bool entropy : 1
ushort identnumber : 16

struct eventtyp:
(self) *prev
(self) *next
Rune unichar
eventidentyp eventident
triggertyp whenthis
triggerfunc ifthis()
eventfunc dothis(paramtyp)
paramtyp params
const char* name
cylinder dim
ulong duration
/* events call raw C functions, without any sort of restrictions on what they have
 * access to beyond what the program can give it. the idea is to provide a full
 * turing-complete interface by which the game's world can be altered according
 * to actions taken by the player. another use would be to show a cutscene rendered
 * with raw curses calls; an elaborate example of curses used in that manner
 * will be found in the game's introduction cutscene.
 */

enum triggerenum {ALWAYS_FLAG,ILLUM_FLAG,LOOK_FLAG,FARLOOK_FLAG,BUMP_FLAG,HIT_FLAG,FIRST_FLAG,NEW_FLAG,DAY_FLAG,TIME_FLAG,MORN_FLAG,NOON_FLAG,EVE_FLAG,MIDNITE_FLAG,DAY_FLAG,NIGHT_FLAG}

struct triggertyp {
triggerenum key : 4
uchar value : 4
}

struct qglobobj: //queued global object
(self) *prev
(self) *next
eventidentyp eventident
qglobflags flags
latlontyp latlon
coord3 pos
objid type
void* data

struct qglobflags {
race : 8
race-specific : 1
role : 2
class : 3
lawfulgood : 1
neutralgood : 1
chaoticgood : 1
lawfulneutral : 1
trueneutral : 1
chaoticneutral : 1
lawfulevil : 1
neutralevil : 1
chaoticevil : 1
canforceload : 1
}

struct traptyp:
(self) *prev
(self) *next
uchar color
Rune unichar
coord3 loc
ushort duration
magictyp
stattyp stat
cursetyp curse
diceodds odds
trapflags flags
senstyp sense
sshort hp
sshort mp

struct trapflags:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool tamperproof : 1
bool stoneproof : 1
bool warded : 1
bool multiuse : 1

struct warptyp:
(self) *prev
(self) *next
uchar color
Rune unichar
latlontyp glob_loc
coord3 loc
latlontyp glob_dest
coord3 dest
ushort duration

char* gemcolors[8] = {"jet","sapphire","emerald","turquoise","ruby","amythest","heliodor","diamond"} //stoning has no effect
/* cut varys by color:
 * diamond = {uncut,cushion-cut,princess-cut,perfect-cut}
 * beryls,emerald={uncut,oval-cut,emerald-cut,teardrop} redundancy of emerald-cut emerald is redundant
 * amythest={geode,prismatic,cushion-cut,teardrop}
 * jet,turquoise={piece of,byzantine,polyhedral,carved relif in}
 */

struct gemstonetyp:
uchar color : 3
uchar quality : 2
uchar cut : 2

struct meattyp:
symtabref race : 8
bool hightable : 1
uchar sellby : 7
uchar amount : 8

struct foodtyp:
symtabref itemid
symtabref metadata
uchar sellby
uchar amount

foodbasetyp:
effectyp effect
diceodds odds
uchar keepsfor
uchar hp
uchar nutri

always (ushort,ushort,ushort,ushort) {return 1}

enum objid:
WEAPON_FLAG : contains subobjtyp calling baseweaptyp
POTION_FLAG : contains potiontyp
READ_FLAG : contains readtyp
FOOD_FLAG : contains subobjtyp containing foodtyp
MEAT_FLAG : contains subobjtyp containing meattyp
ARMOR_FLAG : contains subobjtyp calling basearmortyp
SHLD_FLAG : contains subobjtyp calling baseshldtyp
BAUB_FLAG : contains subobjtyp calling baubtyp
CONLANG_FLAG : contains conlangtyp
SPELL_FLAG : contains spelltyp
MISC_FLAG : contains symtabref
GEM_FLAG : contains gemstonetyp
TRAP_FLAG : contains traptyp
EVENT_FLAG : contains eventtyp
QGLOB_FLAG : contains qglobobj
WARP_FLAG : contains warptyp
CHEST_FLAG : contains chestyp
DOOR_FLAG : contains doortyp
MONEY_FLAG : contains moneytyp
SPAWN_FLAG : contains spawntyp
WAVE_FLAG : contains wavetyp

pseudo radius
/* uses floats to define a circle,
 * terminating on the symbol that is
 * GE than the input. one function won't
 * cover all use cases.
 */

each layer is drawn translated +1y for each layer above the player and -1y for each layer below.
a shadow is drawn under the player
layers are drawn from ground to sky; if the player or their shadow would be covered by a tile,
drawing is stopped and the player is drawn if they have not been already
fluid tiles are transparent.

to avoid confusion, by default the player always uses a unique character: ☻

an UNDERLINE is a shadow

) is a sword or dagger. ⍏ is a polearm. ¦ is a staff. : is a club or mace. ℓ is a whip. ⦅ is a bow. ⇤ is an arrow.
⟦ is armor. [ is clothing. ] is a shield. ⟧ are cannons or greeves. % is meat. ⊞ is food (don't shoot it). $ is gold. ¢ is copper.
⌘ is a misc item. ↧ is a digging tool. ⌥ is a key or lockpick. ♪ is a music instrument. ⍖ is a writing instrument.
¿ are potions (fragile). ∫ is a scroll. ⊒ is a book. ∩ is a tablet. ° is a ring. º is a bracelet. ª is an amulet. ^ is a crown.
/ is a wand. ≣ is a ladder. ⋎ is a fountain or gyser. ⍾ is a bell. ⎋ is a clockface. ♠ ♣ ‡ are trees. ⋏ is fire. ♜ is a pedestal.
≃ is shallow liquid. ≈ is deep liquid's surface. ∬ is a waterfall. ~ is a liquid (as seen while submerged). ∿ is a wave.
⌁ is electricity. * is ice. ⎈ spider web. ⌬ beehive. ↥ are spikes. ⌸ is a door. ⍯ is a locked door. ⎕ is an open door.
? is invisible. ! is trouble. ⌑ is a light source. ⎙ ⍝ ⎍ ∎ ⎅ are tombstones or signs. ␥ is glass.
• is a boulder. . is a rock. ◇ is a gemstone. ◊ is a giant magic crystal. ⑆ are footprints.
∪ is a sink. ⏍ is a chest. ↯ (cyan) is the thunderbolt. ∅ is an anomaly (do not touch). < > are level stairs. 
← ↑ → ↓ ↖ ↗ ↘ ↙ are flying projectiles. ⇐ ⇑ ⇒ ⇓ ⇖ ⇗ ⇘ ⇙ are cannons (the kind that goes boom).
# █ ▓ ▒ ░ ▞ ▚ (etc) are thick walls or floor. ≋ is a cloud (no walking; keep your head out of them).
␣ is a hole. ' is a stalagtite or icicle. , is a plant. ; is a grain or sunflower (impassable).
box drawings are low walls or columns. ⑉ ⋮ are iron bars. · is an ember or star. ` ´ are flower petals.
✪ is a rune. ː ⍽ are traps. ‽ ¶ is gas. " deliminates text. \ deliminates commands.
⍰ is a missingno.

the symbol for gemstone and giant crystal has been the source of much headache,
but any truly monospace font should render their relative sizes correctly;
if the font is only pretending to be monospace (like the default github font),
you'll have bigger issues of non-uniform characters warping and tearing
the world's projection grid. it is for this reason that the recommended font
is a raster one.

box drawings:
 ╒╤╕     ╔╦╗
 ╞╪╡flat ╠╬╣upright
 ╘╧╛     ╚╩╝


BOLD symbols are petrified (statues).
BLINK is something that is out of view.
if something is not able to be seen, it is rendered INVISIBLE
REVERSE video is a magic spell's area of effect

rune symbols
◬ air, ⍫ earth, △ fire, ▽ water, ⍰ missingno
※ ice, ↯ (yellow) electricity, μ metal, ♠ nature
‽ status effect, ¶ stoning, ∅ entropy
☼ light, ☽ dark, § polymorph, ↹ planer
♥ healing

magic AOE symbols
≋ air, • earth, ⋏ fire, ≈ water
* ice, ⌁ electricity, $ metal, ♠ nature
‽ status effect, ¶ stoning, ∅ entropy
⌑ light, ⎈ dark, § polymorph

directional symbols:
←, ↑, →, ↓, ↖, ↗, ↘, ↙, direction in XY;
! far side; ↧, ↥, direction in Z;
↹ different plane;
◬, ⍫, △, ▽, ※, ↯, μ, ♠, ☼, ☽, ∅, inner planes;
£G, NG, CG, £N, CN, £E, NE, CE, TN, U, ☠, outer planes;

/* if digging causes a ≈ or ∬ to become uncontained, it will immediately spawn a ∿
 * which leaves ≃ or ∬ behind it when it moves. it's behavior differs depending on
 * the liquid's viscosity:
 * 	highly viscus (lava): deflected only by solid objects,
 * 	sensitive to edges at ║1║1. moves by ║1║∞.
 *
 * 	watery: meander by half wave on flat unobstructed ground. deflected
 * 	by any object, sensitive to edges at ║3║1. distance from starting position
 * 	to ending position is up to ║3║∞ in xy, and -9 in z
 *
 * 	           ≃≃≃                ≃≃
 * 	half wave: ∿ ≃ (horizontal) ; ∿  (diagonal)
 *
 * if the ∿ reaches an edge, it will queue itself to be loaded in the room it panned to.
 */

uchar getsixbit_template() {
switch (getc(stdin)) {
	case ' ' :
		return 0;
		break;
	case '!' :
		return 01;
		break;
	case '"' :
		return 02;
		break;
	case '#' :
		return 03;
		break;
	case '$' :
		return 04;
		break;
	case '%' :
		return 05;
		break;
	case '&' :
		return 06;
		break;
	case '\'' :
		return 07;
		break;
	case '(' :
		return 010;
		break;
	case ')' :
		return 011;
		break;
	case '*' :
		return 012;
		break;
	case '+' :
		return 013;
		break;
	case ',' :
		return 014;
		break;
	case '-' :
		return 015;
		break;
	case '.' :
		return 016;
		break;
	case '/' :
		return 017;
		break;
	case '0' :
		return 020;
		break;
	case '1' :
		return 021;
		break;
	case '2' :
		return 022;
		break;
	case '3' :
		return 023;
		break;
	case '4' :
		return 024;
		break;
	case '5' :
		return 025;
		break;
	case '6' :
		return 026;
		break;
	case '7' :
		return 027;
		break;
	case '8' :
		return 030;
		break;
	case '9' :
		return 031;
		break;
	case ':' :
		return 032;
		break;
	case ';' :
		return 033;
		break;
	case '<' :
		return 034;
		break;
	case '=' :
		return 035;
		break;
	case '>' :
		return 036;
		break;
	case '?' :
		return 037;
		break;
	case '@' : noop();
	case '`' :
		return 040;
		break;
	case 'A' : noop();
	case 'a' :
		return 041;
		break;
	case 'B' : noop();
	case 'b' :
		return 042;
		break;
	case 'C' : noop();
	case 'c' :
		return 043;
		break;
	case 'D' : noop();
	case 'd' :
		return 044;
		break;
	case 'E' : noop();
	case 'e' :
		return 045;
		break;
	case 'F' : noop();
	case 'f' :
		return 046;
		break;
	case 'G' : noop();
	case 'g' :
		return 047;
		break;
	case 'H' : noop();
	case 'h' :
		return 050;
		break;
	case 'I' : noop();
	case 'i' :
		return 051;
		break;
	case 'J' : noop();
	case 'j' :
		return 052;
		break;
	case 'K' : noop();
	case 'k' :
		return 053;
		break;
	case 'L' : noop();
	case 'l' :
		return 054;
		break;
	case 'M' : noop();
	case 'm' :
		return 055;
		break;
	case 'N' : noop();
	case 'n' :
		return 056;
		break;
	case 'O' : noop();
	case 'o' :
		return 057;
		break;
	case 'P' : noop();
	case 'p' :
		return 060;
		break;
	case 'Q' : noop();
	case 'q' :
		return 061;
		break;
	case 'R' : noop();
	case 'r' :
		return 062;
		break;
	case 'S' : noop();
	case 's' :
		return 063;
		break;
	case 'T' : noop();
	case 't' :
		return 064;
		break;
	case 'U' : noop();
	case 'u' :
		return 065;
		break;
	case 'V' : noop();
	case 'v' :
		return 066;
		break;
	case 'W' : noop();
	case 'w' :
		return 067;
		break;
	case 'X' : noop();
	case 'x' :
		return 070;
		break;
	case 'Y' : noop();
	case 'y' :
		return 071;
		break;
	case 'Z' : noop();
	case 'z' :
		return 072;
		break;
	case '[' : noop();
	case '{' :
		return 073;
		break;
	case '\' : noop();
	case '|' :
		return 074;
		break;
	case ']' : noop();
	case '}' :
		return 075;
		break;
	case '^' : noop();
	case '~' :
		return 076;
		break;
	case '_' :
		return 077;
		break;
	default :
		return 037;
		break;
	}
}

foods (* = uses meta)
hardtak tortilla cornmeal cornbread
flour cheese wine bread
mead ale scotch ethenol
grapes fig date plum
apple banana apricot papaya
orange pear pinapple coconut
kiwi dragonfruit durin peach
grapefruit lemon lime citron
spinach artichoke asparagus bamboo
cucumbers zuccini pickles squash
carrot corn potato celery
brocoli lettuce cabbage kale
cauliflower raddish turnip beets
rhubarb pumpkin avacodo jalapenos
beans greenbeans tomato eggplant
blackolives greenolives garlic onions
watercress chives ketchup mustard
parsly sage rosmary thyme
basil oregano allspice nutmeg
salt bellpeppers peppercorns redpepper
vanillabean cinnimonstick cocoabean sugarbeet
walnut pecan cashew peanut
sunflowerseed pistachio almond chestnuts
cranberrys blueberrys raspberry blackberry
strawberry cherry peppermint pawpaw
sugarcane syrup* molasses honey
seseme poppy fennel eyeofnewt
mushroom* truffel penecillin yeast
barly wheat rye rice
ginger sasafrass blueraspberries bubbles 
geletin starch creamoftartar bakingpowder
vinager bakingsoda calciumhydroxide hemlock
popcorn nachos cookies milk*
pasta(uncooked) pasta ramen(uncooked) ramen*
dumplings(uncooked) dumplings* tofu(uncooked) tofu
meatballs marinara alfredosauce parmisian
lasagnia* pizza* spaghetti alfredo
spaghettiℰmeatballs ramenℰdumplings chickenalfredo brocllialfredo
guacamole nachos* chili salsa
pie* cake* soda* chips
salad* hotdog* hamburger* fries
vanilla cinnimon chocolate sugar
cocoapowder cocoabutter cocoaliquor fudge
egg fat* caramel butterscotch
sourcream butter/shortening* mayo dressing*
pie* pie_alamode* englishfruitcake bread*
cake* pancake* waffle* stackofpancakes*
frozenpancake frozenwaffle flavoredmilk* juice*
roast* gravy fooℰgravy* foo_chicken*
bakedpotato loadedbakedpotato mashpotatos tattiesℰneeps
sunnysideup overeasy scrambled hardboiled
bacon* sausage* jerky* spam
nutbrittle* trailmix rasin* peanutbuttersandwich*
baconlettucetomatosandwich clubsandwich fingersandwich* coldcutsandwich*
milkshake* icecream* sorbet* icecreamfloat*
icecreamcone* banannasplit neopolitan rockyroad
gumdrop* hardcandy* candycane filledchocolate*
jelly* jam* preserves* peanutbutter
icecube snow ember blacksoup
broth* stew* ration mistake

pseudosubroutine playermove(xmove,ymove,zmove)
schar xmove
schar ymove
schar zmove
{
velocitycheck()
xymovecheck(xmove,ymove)
zmovecheck(zmove)

PLAYER.pos.x += xmove
if (PLAYER.pos.x < 0) {
	PLAYER.pos.x = mapscroll(-1,0).x
	
	}
else if (PLAYER.pos.x ≥ MAX_X) {
	PLAYER.pos.x = mapscroll(1,0).x
	}

PLAYER.pos.y += ymove
if (PLAYER.pos.y < 0) {
	PLAYER.pos.y = mapscroll(0,-1).y
	}
else if (PLAYER.pos.y ≥ MAX_Y) {
	PLAYER.pos.y = mapscroll(0,1).y
	}

PLAYER.pos.z += zmove
}

pseudosubroutine playervelocitycheck() velocitycheck(*entity)
	- moves you by a vector defined by velocity,
	  checking each space for friction. if friction
	  is encountered, assume it is infinate.

pseudosubroutine xymovecheck(xmove,ymove)
	- aborts if you're flying
	- checks to make sure you're not walking off a cliff,
	  asks for confirmation if you are.
	- automatically steps if only 1 block of z difference
	  to another solid block in direction of travel,
	  moving by a distance of SQRT3 if on an XY diagonal,
	  M_SQRT2 if on an XY orthogonal.
	- updates your direction
	- if you're on ice, adds your movement to your velocity.

pseudosubroutine zmovecheck(zmove)
	- checks if you can fly
	  if you can't fly, adds -grav to your z velocity
	- checks to make sure you are not flying through a solid block
	- if ≥ floor 100 and at top of room, calls mapscrollz(0,1)
	- if > floor 100 and at bottom of room, calls mapscrollz(1,1)
	- if the above 2 don't apply, checks for holes. if none are present,
	  keeps you from flying out of the room.

pseudosubroutine newtonlaw(xmove,ymove,zmove)
	- checks if you're flying magically, on ice, or in a liquid
	- if you are, adds {-xmove,-ymove,-zmove} to your velocity
	  (half this value in liquids)

pseudosubroutine mapscroll(latmove,lonmove)
schar latmove
schar lonmove
{
saveroom()
WORLD.coord.lat += latmove
if (WORLD.coord.lat > EQUATOR/4) {
	WORLD.coord.lat = EQUATOR/2 - WORLD.coord.lat
	WORLD.coord.lon += EQUATOR/2
	if (WORLD.coord.lon > EQUATOR/2) {
		WORLD.coord.lon += -EQUATOR
		}
	}
else if (WORLD.coord.lat < -EQUATOR/4) {
	WORLD.coord.lat = -EQUATOR/2 - WORLD.coord.lat
	WORLD.coord.lon += EQUATOR/2
	if (WORLD.coord.lon > EQUATOR/2) {
		WORLD.coord.lon += -EQUATOR
		}
	}

WORLD.coord.lon += lonmove
if (WORLD.coord.lon ≥ EQUATOR/2) {
	WORLD.coord.lon += -EQUATOR
	}
else if (WORLD.coord.lon < -EQUATOR/2) {
	WORLD.coord.lon += EQUATOR
	}

loadroom()

GLOBREG.NEW = true
GLOBREG.FIRST = !(visited)
ROOM.visited = true
}

pseudosubroutine mapscrollz(depmove,hole)
bool depmove
bool hole
{
saveroom()

if (depmove && (WORLD.coord.dep = 0)) {
	depmove = 1
	WORLD.coord.lat = -WORLD.coord.lat
	if (WORLD.coord.lon == -EQUATOR/2) {WORLD.coord.lon = 0}
	else {WORLD.coord.lon = -WORLD.coord.lon}
	}

else if (!depmove && (WORLD.coord.dep = ROOF)) {
	/* death message (one of the following):
	 * flew too close to the sun
	 * was smited for rising too high
	 * grew too proud
	 * passed out in space and burned up on reentry
	 * froze to death in outer space
	 * became lost...in...spaaace!
	 */
	}

else if (!depmove) {
	WORLD.coord.dep -= 1
	}

else if (depmove) {
	WORLD.coord.dep += 1
	}

loadroom()

if (depmove) {
	if (!hole) {
		PLAYER.pos.x = ROOM.upstair.x
		PLAYER.pos.y = ROOM.upstair.y
		}
	PLAYER.pos.z = CEILING
	}
else {
	if (!hole) {
		PLAYER.pos.x = ROOM.downstair.x
		PLAYER.pos.y = ROOM.downstair.y
		}
	PLAYER.pos.z = 0
	}

GLOBREG.NEW = true
GLOBREG.FIRST = !(visited)
ROOM.visited = true
}

pseudosubroutine mapwarp(lat_dest,lon_dest,dep_dest,tocoord)
schar lat_dest
schar lon_dest
schar dep_dest
coord3 tocoord
{
saveroom()

WORLD.coord.dep = dep_dest

WORLD.coord.lat = lat_dest
if (WORLD.coord.lat > EQUATOR/4) {
	WORLD.coord.lat = EQUATOR/2 - WORLD.coord.lat
	WORLD.coord.lon += EQUATOR/2
	if (WORLD.coord.lon > EQUATOR/2) {
		WORLD.coord.lon += -EQUATOR
		}
	}
else if (WORLD.coord.lat < -EQUATOR/4) {
	WORLD.coord.lat = -EQUATOR/2 - WORLD.coord.lat
	WORLD.coord.lon += EQUATOR/2
	if (WORLD.coord.lon > EQUATOR/2) {
		WORLD.coord.lon += -EQUATOR
		}
	}

WORLD.coord.lon = lon_dest
if (WORLD.coord.lon ≥ EQUATOR/2) {
	WORLD.coord.lon += -EQUATOR
	}
else if (WORLD.coord.lon < -EQUATOR/2) {
	WORLD.coord.lon += EQUATOR
	}

loadroom()

if ((tocoord.x ≥ MAX_X) || (tocoord.y ≥ MAX_Y) || (tocoord.z ≥ CEILING)) {
	PLAYER.pos.x = ROOM.home.x
	PLAYER.pos.y = ROOM.home.y
	PLAYER.pos.z = ROOM.home.z
	}
else {
	PLAYER.pos.x = tocoord.x
	PLAYER.pos.y = tocoord.y
	PLAYER.pos.z = tocoord.z
	}
}

pseudosubroutine saveroom()
/* clears screen
 * prints "  LOADING..." on line 13
 * prints a hint on line 22.
 *   hints are stored in a struct
 * overwrites files in tmp
 * tar's the files and saves the archive in the savefile
 * frees any data that is no longer neccisary
 */

pseudosubroutine loadroom()
/* unarchives files to tmp
 * loads files into memory
 */

pseudosubroutine saveworld()
pseudosubroutine loadworld()
/* same as saveroom/loadroom; except
 * manipulates files for planes
 */

pseudosubroutine savestate()
pseudosubroutine loadstate()
//saves or loads globals

uchar pseudosubroutine castshadow(xpos,ypos,zpos)
uchar xpos
uchar ypos
uchar zpos
{
if (zpos == 0) {
	return zpos
	}
else if (mapderef(xpos,ypos,zpos-1).solid) {
	underline(xpos,ypos,zpos)
	return zpos
	}
else {
	zpos--
	for (;zpos!=0;zpos--) {
		if (mapderef(xpos,ypos,zpos-1).solid) {
			underline(xpos,ypos,zpos)
			return zpos
			}
		else if (mapderef(xpos,ypos,zpos-1).liquid) {
			underline(xpos,ypos,zpos)
			}
		}
	underline(xpos,ypos,zpos) //escape zpos==0
	return zpos
	}

bool maskfetch(zcoord,ycoord,xcoord,mask)
uchar zcoord
uchar ycoord
uchar xcoord
shadowmask mask
{
div_t tmp = div(zcoord,8)
switch (tmp.rem) : {
	case 0 : return mask[tmp.quot][ycoord][xcoord].a;
	case 1 : return mask[tmp.quot][ycoord][xcoord].b;
	case 2 : return mask[tmp.quot][ycoord][xcoord].c;
	case 3 : return mask[tmp.quot][ycoord][xcoord].d;
	case 4 : return mask[tmp.quot][ycoord][xcoord].w;
	case 5 : return mask[tmp.quot][ycoord][xcoord].x;
	case 6 : return mask[tmp.quot][ycoord][xcoord].y;
	case 7 : return mask[tmp.quot][ycoord][xcoord].z;
	default : return 0;
	}
}

maskwrite(zcoord,ycoord,xcoord,mask,value)
uchar zcoord;
uchar ycoord;
uchar xcoord;
shadowmask mask;
bool value;
{
div_t tmp = div(zcoord,8)
switch (tmp.rem) : {
	case 0 : mask[tmp.quot][ycoord][xcoord].a = value; break;
	case 1 : mask[tmp.quot][ycoord][xcoord].b = value; break;
	case 2 : mask[tmp.quot][ycoord][xcoord].c = value; break;
	case 3 : mask[tmp.quot][ycoord][xcoord].d = value; break;
	case 4 : mask[tmp.quot][ycoord][xcoord].w = value; break;
	case 5 : mask[tmp.quot][ycoord][xcoord].x = value; break;
	case 6 : mask[tmp.quot][ycoord][xcoord].y = value; break;
	case 7 : mask[tmp.quot][ycoord][xcoord].z = value; break;
	default : return 1;
	}
return 0;
}

uchar defaulthightget(zcoord)
uchar zcoord
{
if (zcoord ≥ 100) {return MAX_Z - 1;}
div_t tmp = div(zcoord,2)
if (tmp.quot > 50) {ERROR_GRAPHIC("math: heisenbug",(tmp.quot * 2) + tmp.rem,MAX(zcoord,99),false); return false}
switch (tmp.rem) : {
	case 0 : return MAPGENHIGHTS[tmp.quot].lo;
	case 1 : return MAPGENHIGHTS[tmp.quot].hi;
	default : ERROR_GRAPHIC("math: invalid remainder",temp.rem,2,true); return 0;
	}
}

bool langetx(id)
uchar id
{
if (id > 31) {ERROR_GRAPHIC("math: out of bounds",id,31,false); return false}
div_t tmp = div(id,8)
if (tmp.quot > 3) {ERROR_GRAPHIC("math: heisenbug",(tmp.quot * 8) + tmp.rem,MAX(id,31),false); return false}
switch (tmp.rem) : {
	case 0 : return conlangx[tmp.quot].a;
	case 1 : return conlangx[tmp.quot].b;
	case 2 : return conlangx[tmp.quot].c;
	case 3 : return conlangx[tmp.quot].d;
	case 4 : return conlangx[tmp.quot].w;
	case 5 : return conlangx[tmp.quot].x;
	case 6 : return conlangx[tmp.quot].y;
	case 7 : return conlangx[tmp.quot].z;
	default : ERROR_GRAPHIC("math: invalid remainder",temp.rem,8,true); return 0;
	}
}

plugin and conf interface {

KEY=value is a key-value pair
COMMAND: is a command

bool is a true flag
!bool is a false flag
-bool is a negative flag

"string" is a string
'/foo/bar/baz' is a path

1234 is a decimal interger
-1234 is a negative decimal interger
12.34 is a float
-12.34 is a negative float
$1234 is a hex interger
0x1234 is also a hex interger
@1234 is an octal interger
0o1234 is also an octal interger
%1010 is a binary interger 
0b1010 is also a binary interger
\n is an escape
`æ is a UCS-2 value

leading zeros can cause a slight decrease in performance
only decimal numbers may be negative.

@foo is a raw internal variable. can include pointer, deref, array, or structure operators.

# is a preprocessor directive

simple code can also be included:
	+ - * ** / % ++ --
	> < ≥ ≤ != ==
	&& || ! !&& !|| <> 
	& | ~ ~& ~| ^ ~^
	log() lb() ln() sqrt() fact()
	floor() ceil() sgn() nPr nCr
	M_E M_PI M_2_PI M_PI_2 M_PI_4 M_SQRT2 M_SQRT1_2 INFINITY NAN
	USHORT_MAX SHORT_MAX SHORT_MIN UCHAR_MAX CHAR_MAX CHAR_MIN
	ULONG_MAX LONG_MAX LONG_MIN NULL	//some C macro constants
	PI TAU SQRT3 SQRT2 SQRT1_2 GRATIO SRATIO TRUE FALSE	//some more macro constants
	MAX_X MAX_Y MAX_Z BUFFERMAX ROOF EQUATOR GRAV ...	//some enviromental constants
	CEILING	GLOBREG WORLD TIMER TURN ROOMTURN KILLS ALARM DATE ...	//some parameters (nonfixed values)
	break noop
	() ? (;)
	if () {}
	else {}
	for (;;) {}
	forever {}	//forever {...} expands to for (;;) {...}
	while () {}
	until () {}	//until (foo) {...} expands to while (!(foo)) {...}
	switch () {}
	case foo : {}
	return ()
	goto()
	¶label

comments may take one of the forms:
//foo
§foo
/*foo*/
}

main () {
if (GLOBREG.NEW) {
	checkglobal(NEW_FLAG,true)
	GLOBREG.NEW = false
	}
checkevents()	//check event triggers
wavecheck()	//check waves
player_act()	//player's turn
follow_iter()	//iterate through follower entities
ent_iter()	//iterate through local entities
encounter(1D6,1d100)	//generate up to 1D6 of monster number 1d100
}

pseudo <follow|ent>_iter () {
<ent|follow>typ* ptr = <head>
while (ptr != NULL) {
	<follow|ent>_act(&ptr) //&ptr's turn
	ptr = ptr->next
	}
}

pseudo encounter(count,tableid)
uchar count
uchar tableid
{
encontyp *ptr = ROOM.encon_head
for (;tableid != 0;tableid--) {
	ptr = ptr->next
	}
uchar try;
for (;count != 0;count--) {
	try = mainh_roll(10,20,1)
	if (try > ptr->tobeat) {
		summonfunc(ptr->spawn)
		}
	}
}

pseudo render() {
/* flush THESHADOWKNOWS and SHINEALIGHT
 * translate the view so that the player is on line 13
 * cast shadows and record the player's shadow
 * illuminate the player according to their view range
 * illuminate all lights in the room.
 * get the player's view information. only draw tiles that can be seen.
 * draw each layer of the room one at a time, making sure the player and their shadow are not covered, and doing out-of-view substitution.
 * draw the player
 * draw other entitys that can be seen
 * add shadows
 */

enum roomgenenum {FIXED_GEN_FLAG,SKY_GEN_FLAG,VILLAGE_GEN_FLAG,PLAIN_GEN_FLAG,FOREST_GEN_FLAG,HILL_GEN_FLAG,MOUNTAIN_GEN_FLAG,DESERT_GEN_FLAG,VOLCANO_GEN_FLAG,BEACH_GEN_FLAG,OCEAN_GEN_FLAG,MAZE_GEN_FLAG,MAZE_ROOMS_GEN_FLAG,PATH_GEN_FLAG,PATH_ROOMS_GEN_FLAG,LAVA_MAZE_GEN_FLAG,LAVA_MAZE_ROOMS_GEN_FLAG,LAVA_PATH_GEN_FLAG,LAVA_PATH_ROOMS_GEN_FLAG,MINES_GEN_FLAG,CAVE_GEN_FLAG,CANYON_GEN_FLAG,CAVE_NOFLOOR_GEN_FLAG,CAVE_NOCEIL_GEN_FLAG,CAVE_MASSIVE_FLAG,LAVA_MINES_GEN_FLAG}

struct roomgentyp
{
roomgenenum roomgen : 8
uchar height : 4
bool peacful : 1	//do not generate any monsters
bool dark : 1	//warn of and generate grue.
bool upstair : 1
bool downstair : 1
}

printf("\n\n \033[1;95m~~ Iwannafly Roguelike Engine : %s ~~\033[m\n\033[97m  gamemaster version: %s\n       savefile type: %s\n    compression type: %s\n     sound interface: %s\n\n \033[96m - %s -\033[m\n\033[97m      RPG rules revision: %s\nstory event API revision: %s\n   file handler revision: %s\n\n\033[37mCompiled on %s\033[23m\n\nthis program currently requires the ability to execute system calls; if it cannot, Bad Things may happen!\n\n\033m",GAMENAME,GM_VERSION,SAVE_FORMAT,COMPRESSION,DEVEL_STATE,REV_RULES,REV_EVENTS,REV_FILES,__DATE__);