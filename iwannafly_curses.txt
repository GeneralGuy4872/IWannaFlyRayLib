/* Hey, you. yeah, you. who do you think I'm talking to; the mouse?
 *
 * you found the seeecret extended documentation, aka the source code!
 * the sorce code, and witty comments, are intended to supplement the
 * manpages, as well as give a deeper understanding of the program.
 *
 * enviromental requirements:
 * - UTF-8
 * - "Fixed" font is recommended
 * - 25x80 chars term or bigger
 * - 16 or more fg colors
 * - 8 or more bg colors
 * - Bold, Underline, Reverse, Blink, Invisible
 * - Full Keyboard
 * - Mouse
 *
 * Controls:
 * - number keys or arrow keys move in xy
 * - page up and page down move in z
 * - \ initiates the command console
 * more tbd
 */

/**standard libraries**/
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <math.h>
#include <limits.h>
#include <time.h>
#include <string.h>

/**system libraries**/
#include <unistd.h>
#include <signal.h>
//#include <regex.h>
//#include <sys/types.h>
//#include <sys/ioctl.h>
//#include <fcntl.h>
//#include <sys/stat.h>

/**ncurses libraries**/
#include <ncursesw/ncurses.h>
#include <menu.h>
/**curses libforms**/
#include <forms.h>

#define BUFFER_MAX 512
#define SQRT3 1.732050807568877293528
#define GRAV 1.352
#define MAX(A,B) (A > B ? A : B)
#define MIN(A,B) (A < B ? A : B)
#define CLAMP(N,A,B) MIN(MAX(N,A),B)
#define ≥ >=
#define ≤ <=

/* the 3d version of Iwannafly started off as a general RT-RPG library that
 * then became narrowed to a specific game. this version was originally
 * supposed to be the same game reworked for ncurses,
 * but is now becoming closer to the general library concept,
 * similar to a RPG ruleset that allows creation of
 * your own setting and plot (you know the one).
 * a default one will be provided, however, based on the 3d game's story,
 * but extended well beyond the projected capabilities of that engine.
 */

setlocale(LC_ALL, "");
cbreak();
noecho();
keypad(stdscr, TRUE);

/* because of the internals of the CLI commands,
 * localization would require rewriting large
 * ASCII and DEC-SIXBIT switch tables.
 *
 * backslash enters console mode. characters are fetched and printed
 * with ncurses, as well as stored in a temporary file.
 * autocomplete will be implemented, using a DEC-SIXBIT
 * switch table, and can be invoked with tab.
 *
 * once the enter key is pressed, the temp file is rewound.
 * fscanf is used to process space-seperated tokens.
 * interpretation mode will change depending on the syntax.
 * invalid commands may produce the response
 * "Don't know how to <command>", amoungst others.
 */

enum cli_argstypes
/* used to specify the type of the buffer that tokens are
 * parsed into. types can be:
 *
 * argstype_wish (*heldobjtyp) (*heldobjtyp)[2] (*heldobjtyp)[4]
 * argstyp_ent symtabref argstyp_equip equipenum
 *
 * container types will also allocate suitable contents
 * once objid has been resolved
 */

typedef cli_func *int(*void)

enum command_enum
stabs commandstabs
cli_func commandtable[256]

struct argstyp_wish {
unsigned char stack
objid type
void* data
}

struct argstyp_ent {
bool shift
unsigned char race
bool stoned
}

struct argstyp_equip {
equipenum slot
heldobjtyp* item
}

#define MAINY 5
#define SIDEX 65
#define CMDY 24
#define BRIGHT 010
#define BACKGROUND 0x10
/* example: (BACKGROUND*COLOR_BLUE)+BRIGHT+COLOR_RED
 * color pairs are a complete 16 * 8 CGA color combination grid
 */

#ifndef _XOPEN_SOURCE_EXTENDED
#define _XOPEN_SOURCE_EXTENDED
#endif

/* typedef struct Rune {
 * unsigned long sym : 24;
 * bool bold : 1;
 * bool italic : 1;
 * bool under : 1;
 * bool strike : 1;
 * bool over : 1;
 * bool reverse : 1;
 * bool blink : 1;
 * bool invis : 1;
 * } Rune; //not needed
 */

unsigned int mainh__roll (num,side,low)
unsigned char num;
unsigned char side;
bool low;
{
unsigned int accum;
unsigned int tmp;
for (unsigned char n = 0;n<num;n++) {
	tmp = (rand() % side) + low;
	accum += tmp;
	}
return accum;
}

signed short mainh__bonus (num)
unsigned char num;
{
signed short accum;
tern tmp;
for (unsigned char n = 0;n<num;n++) {
	tmp = (rand() % 3) - 1;
	accum += tmp;
	}
return accum;
}

#define mainh__flip (rand() % 2)

#define MISSING_FILE(F) fprintf(stderr,"File \"%s\" not found",F); move(0,24); attron(COLOR_PAIR((BACKGROUND*COLOR_RED)+BRIGHT+COLOR_WHITE); printw("File \"%s\" not found",F); attroff(COLOR_PAIR((BACKGROUND*COLOR_RED)+BRIGHT+COLOR_WHITE);

file_cat (path)
const char *path;
{
FILE *tmp = fopen(path,"r");
int lines;
if (tmp == NULL) {
	MISSING_FILE(path);
	return -1;
	}
char tmpbuffer[BUFFER_MAX];
for (bool n = TRUE;n;noop()) {
	if (fgets(tmpbuffer,BUFFER_MAX,tmp) == NULL) {
		n = FALSE;
		} else {
		printf(tmpbuffer);
		lines++;
		}
	}
fclose(tmp);
return lines;
}

/* should also output __FILE__ and __LINE__, which will likely be the program's version of
 * undecipherable hex codes to anyone not extreamly fammiliar with the source. less severe
 * errors will prompt for [Q]uit, [A]bort, or [Z] continue. more severe ones will prompt
 * [Q]uit, [A]bort, [Z] restart.
 */
ERROR_GRAPHIC(string,num1,num2,hard)
char* string
int num1 num2
bool hard
{
char* opt3
if (hard) {
	attron(A_REVERSE,COLOR_PAIR((BACKGROUND*COLOR_RED)+BRIGHT+COLOR_YELLOW)
	opt3 = "Restart"
	}
else {
	attron(A_REVERSE,COLOR_PAIR(BRIGHT+COLOR_YELLOW)
	opt3 = "Continue"
	}

move(MAINY+00,0); printw("*┐  Error!")
move(MAINY+01,0); printw("▗█▖  \"%s\"",string)
move(MAINY+02,0); printw("███ N1 = %i",num1)
move(MAINY+03,0); printw("▝█▘ N2 = %i",num2)

move(MAINY+05,0); printw("File: %s",__FILE__)
move(MAINY+06,0); printw("Line: %i",__LINE__)

move(MAINY+08,0); printw("[Q]uit?")
move(MAINY+09,0); printw(" [A]bort?")
move(MAINY+10,0); printw("  [Z] %s?",opt3)

//keytrap stuff here
}

playertyp PLAYER
coord3 PLAYERSHD //position of player's shadow, for renderer
mapcoord WORLD
roomtyp ROOM
#define CEILING ROOM.upstair.z
shadowmask SHADOWKNOWS
shadowmask SHINEALIGHT
unsigned long long TURN
turntyp DATE
unsigned char ROOMTURN
unsigned long KILLS
char* SAVEPATH
enttype *PURS_head //pursuers, i.e. paid assasins, ninjas, the reaper...
enttype *PURS_tail
eventtyp *EVNT_head
eventtyp *EVNT_tail
bool NEW //set to true whenever you enter a room and every day at 6am
FILE* CLIBUFFER = tmpfile()

struct turntyp:
unsigned char sec : 6
unsigned char min : 6
unsigned char hour : 5
unsigned char day : 5
unsigned char weekday : 3
unsigned char month : 4
unsigned short year : 11

bool ticktock() {
TURN++;
if (ROOMTURN < 200) {ROOMTURN++;}
DATE.sec += 6;
if (DATE.sec ≥ 60) {
	DATE.sec = 0;
	DATE.min++;
	if (DATE.min ≥ 60) {
		DATE.min = 0;
		DATE.hour++;
		if (DATE.hour == 6) {NEW = true}
		if (DATE.hour ≥ 24) {
			DATE.hour = 0;
			DATE.weekday++
			if (DATE.weekday ≥ 7) {DATE.weekday = 0;}
			DATE.day++;
			if (DATE.day ≥ 30) {
				DATE.day = 0;
				DATE.month++;
				if (DATE.month ≥ 12) {
					DATE.month = 0;
					DATE.year++;
				}
			}
		}
	}
}

//cartesian projection, →x ↓y ↑z (+y=-z)

struct coord3:
unsigned char x
unsigned char y
unsigned char z

struct coord2:
unsigned char x
unsigned char y

struct scoord3:
signed char x
signed char y
signed char z

struct scoord2:
signed char x
signed char y

struct paramtyp:
coord2 lo
coord2 hi

struct vector2:
float x
float y

struct vector3:
float x
float y
float z
/* used for velocity, a parameter that holds
 * motion that carries accross turns. this motion
 * is not always cleared after being done; horizontal
 * velocity persists until a tile with friction is
 * encountered, while downwards vertical velocity 
 * accumulates and persists until the ground is encountered.
 */

struct polar {
unsigned char az : 3
signed char el : 2
unsigned char r : 5
signed char slope : 3 //negative is inverse slope, most negative is omnidirectional
unsigned char illum : 3
}
/* amoungst other uses, defines the cone of vision
 * and used to generate magic beams
 */

//some specific uses call for spheres. these are simply numeric types.

float norm2(xrel,yrel,zrel)
signed char xrel;
signed char yrel;
signed char zrel;
{return root( ((float) xrel * xrel) + ((float) yrel * yrel) + ((float) zrel * zrel) );}

unsigned short norm1(xrel,yrel,zrel)
signed char xrel;
signed char yrel;
signed char zrel;
{return abs(xrel) + abs(yrel) + abs(zrel);}

unsigned char normINF(xrel,yrel,zrel)
signed char xrel;
signed char yrel;
signed char zrel;
{return MAX(MAX(abs(xrel),abs(yrel)),abs(zrel));}

struct diceodds:
unsigned char num : 3
unsigned char side : 5
unsigned char tobeat : 8

struct planecoord:
bool moon : 1 //are you on the moon?
bool shift : 1 //are you plane shifted?
bool outer : 1 //inner planes or outer planes
unigned char az : 3 //azimuth on a plane chart
signed char el : 2

struct latlontyp:
signed char lat : 8
signed char lon : 8
signed char dep : 8

struct mapcoord: //surface terrain generation by dice roll from pregenerated blocks. doungeon generation by algorithem tbd. some coords will generate fixed special rooms
latlontyp latlon
planecoord plane

/* when combined with shift, moon becomes off-plane
 *
 * az	elemental	afterlife	corrilation
 * 0	water		neutral good	nurturer
 * 1	ice		chaotic good	the ends justify the means
 * 2	air		chaotic neutral	princess stealing
 * 3	electricity	chaotic evil	force lightning
 * 4	fire		neutral evil	obviously
 * 5	metal		lawful evil	greed
 * 6	earth		lawful neutral	stubborn
 * 7	trees		lawful good	knowladge
 *
 * az rotates by 45 degree steps and el by 90 degree steps.
 * a nonzero el causes az to gimbal lock.
 * also best not to think about where exactly -2 is pointing;
 * perhaps it's a doughnut?
 *
 * el	"		"		"
 * +1	light		true neutral	enlightenment
 * -1	darkness	uncomitted	meh, I'll think of one later
 * -2	entropy		oathbreakers	abandon all hope ye who enter here
 *
 * by combining the shift and moon fields, you can go to the
 * æthereal (inner) and asteral (outer) planes,
 * but only the worthy can withstand the inter-planer energy.
 * all others are instantly blasted with all permenent status effects, including stoning.
 *
 * errors related to this section generate the string "froze to death on pluto", N1=az,N2=el
 */

struct cylinder:
unsigned char r : 8
unsigned char up : 4
unsigned char down : 4
 /* cylinders, (the shape, not this datatype) are used extensively.
  * players move in cylindrical coordinate space.
  * event areas are specified as cylinders
  * monster aggro ranges are a cylinder
  */

struct aligntyp:
good : b1
evil : b1
law : b1
chaos : b1
nogood : b1
noevil : b1
nolaw : b1
nochaos : b1
/* used as a mask.
 * alignment is allowed to be any of the high nibble.
 * alignment may NOT be any of the low nibble, marked "no".
 * alignment may always be true neutral.
 */

struct bitfield:
a : 1
b : 1
c : 1
d : 1
w : 1
x : 1
y : 1
z : 1

typedef char* stabs[256] //symbol table strings
typedef void* fstab[256] //filesystem table
typedef unsigned char symtabref //beware of missingno glitches!

enum item_enum
enum spell_enum
enum weap_enum
enum arm_enum
enum shld_enum
enum baub_enum
stabs itemstabs //stuff that doesn't go anywhere else; i.e. arrows, keys, quest items
stabs spellstabs //spells
stabs weapstabs //weapons
stabs armstabs //armor
stabs shldstabs //shield, cannon, greeves
stabs baubstabs //rings, amulets, bracelets, tiaras
fstab itemtable
fstab spelltable
fstab weaptable
fstab armtable
fstab shldtable
fstab baubtable

char* legendstabs[20] = {"truthseeker","sword of justice","excalibur","thunderbolt"/*torch + lightningbolt (smiting)*/,"sickle of chaos"/*+drain*/,"stormbringer"/*+drain*/,"devilfork"/*+fire*/,"partisen of tyrants","deathscyth"/*+drain*/,"sunray"/*spear + solar flare*/,"nightedge"/*sword + moonbeam*/,"staff of merlin"/*staff of magic missile*/,"firebrand"/*sword + fireball*/,"tesla's mace"/*+spark*/,"stormgale"/*bow*/,"frostpike"/*+frostbite*/,"trident of the seas"/*+tsunami*/,"staff of the forest"/*staff of animante kudzu*/,"groundshaker"/*+earthquake*/,"imperial baton"/*staff of antagonizing*/}
legendtyp legendtable[20]

typedef classobjtyp:
classtyp
magictyp

typedef classtyp {
unsigned char type : 2
bool override : 1 //0=blacklist overrides, 1=whitelist overrides
bool wl_mode : 1 //whitelist mode: 0=or, 1=and
unsigned char class : 3
bool neutral : 1
bool good : 1
bool evil : 1
bool law : 1
bool chaos : 1
bool nogood : 1
bool noevil : 1
bool nolaw : 1
bool nochaos : 1

char* roguestabs[8] = {"changeling","rogue","thief","pirate","ninja","assasin","tourist","ronan"}
char* fighterstabs[8] = {"fighter","knight","paladin","valkyrie","viking","samuri","ranger","monk"}
char* magicuserstabs[8] = {"magic-user","wizard","illusionist","enchanter","black mage","red mage","psion","necromancer"}
char* healerstabs[8] = {"healer","cleric","priest","druid","alchemist","scholar","white mage","seer"}

playertyp classtable[4][8]	//is freed after startup; initial values for PLAYER

enum mon1_enum
stabs mon1stabs =	//"final name", /*placeholder name*/
{"human",	"elf",		"dwarf",	"gnome",	"hobbit",	"half elf",	"drow",		/*avian*/,	"half orc",	"half dragon",	/*half celestial*/,	"tiefling",	"half air elemental",		"half water elemental",	"half earth elemental",		"half fire elemental",
"merfolk",	"seaelf",	"satyr",	"fairy",	"pixie",	"naiad",	"naga",		"dryad",	"orc",		"kobald",	"centaur",		"sphinx",	"half electric elemental",	"half ice elemental",	"half nature elemental",	"half metal elemental",
};

fstab mon1table
/* contains all polymorphable monsters, of type BASENTYPE.
 * any polymorphable race can BECOME your base race...
 * polymorph autocomplete is implemented using switches.
 */
enum mon2_enum
stabs mon2stabs
fstab mon2table

/* MONSTERS BY LETTER
 * &: horned devil, balrog, pit feind, imp, homunculus, jubilix, drider
 * @: human, elf, half elf, drow, seaelf
 * A: astral, ætherial, celestial, archon
 * a: newt, salamander, frog, 
 * B: bear, polar bear, bugbear, owlbear,
 * b: mockingbird, parrot, macaw, cockatoo, songbird, sparrow, starling,
 * C: satyr, centaur,
 * c: raven, rook, jackdaw, crow, jay, magpie,
 * D: wyrm, great wyrm, (△red,↯copper,◬white,*cyan,▽blue,♠green,⍫brown,⍏gold,☽black,☼silver,☠purple,%grey) dragon, hydra,
 * d: hellhound, wolf, dire wolf, dog, fox, cyote,
 * E: <elementals>, stalker, grue,
 * e: floating eye,
 * F: turkey, rooster, chicken, peahen, peacock, duck, goose, albatross, gull,
 * f: panther, lion, tiger, manticore, cat, lynx, bobcat, displacer beast,
 * G: ghost, banshee, revenent, barrow wight,
 * g: gremlin, gargoyle, winged gargoyle,
 * H: giant, cyclops,
 * h: dwarf, gnome, hobbit,
 * I: giant ant, giant roach, giant scarab, giant wasp, giant scorpion, giant spider,
 * i: ant, roach, scarab, wasp, scorpion, spider, firefly
 * J: djinn,
 * j: lichen, yellow mold, green mold, black mold, gelatinous cube, green slime, brown pudding, black pudding, ocher jelly, spotted jelly, blue jelly,
 * K: chickatrice, cockatrice, pyrolisk,
 * k: kobold,
 * L: skeleton, lich,
 * l: leprachaun,
 * M: gorgon,
 * m: <mummies>
 * N: naga,
 * n: merfolk, naiad, dryad,
 * O: <boulder (letter O considered harmful)>
 * o: orc, half orc, uruk-hai, ogre,
 * P: fairy, pixie,
 * p: dolphin, narwhal, orca, beluga,
 * Q: elephant, mammoth, rhino,
 * q: cow, pig, buffalo,
 * R: eagle, falcon, owl, kite, vulture, phoenix,
 * r: rat, dire rat, raccoon, platypus,
 * S: cracken, shark, octopus, giant squid,
 * s: copperhead, cobra, rattlesnake, python,
 * T: lurker above, trapper, wallmaster, rust monster,
 * t: troll,
 * U: umber hulk,
 * u: unicorn, pegasus, zebra, griphon, hippogriph,
 * V: vampire, wolfman, manbat, mind flayer,
 * v: bat,
 * W: avian, erinys, harpy, tengu,
 * w: purple worm,
 * X: velociraptor, tyrannasaurus,
 * x: <corpses>
 * Y: yeti, bigfoot,
 * y: ape, monkey, gorilla,
 * Z: <sleeping gas>
 * z: <zombies>
 * ½: half dragon, half celestial, tiefling, <half elementals>,
 * ¶: death.
 * ♞: nightmare, quarterhorse, draft horse, miniature horse,
 * ♜: (flesh, straw, clay, stone, glass, paper, leather, gold) golem, automaton, hungry chest, chest monster,
 * ⏍: hungry chest, chest monster,
 */

struct the8stats:
stren : 5
dex : 5
tough : 5
fort : 5
intl : 5
wis : 5
bluff : 5
cast : 5

struct conlangtype:
symtabref id : 6
bool r : 1
bool w : 1
//nothing to X-ecut, so no x

char* conlangtab[64] ={"common language","thieves cant","middle elvish","old elvish","dwarvish","gnomish","gothic","orkish","draconic","fey","celestic","demonic","blackspeech","skyspeak","waterspeak","earthspeak","firespeak"}

struct playertyp:
classtyp class
symtabref startrace
symtabref polyrace
toomuchpolytyp polycounter
coord3 loc
polar facing
vector3 velo
paffectyp permenent
effectyp fromequip
scoord2 align
unsigned short hp	//they're fun and easy to...wait
unsigned short mp
unsigned char air
unsigned long xp
unsigned char lvl
signed short food
unsigned short gold
heldobjtyp *lang_head
heldobjtyp *lang_tail
heldobjtyp *spell_head
heldobjtyp *spell_tail
heldobjtyp *bag_head
heldobjtyp *bag_tail
subobjtyp weap_left	//weapon
subobjtyp weap_right	//weapon
subobjtyp shield	//shld
subobjtyp bow	//weapon
subobjtyp armor	//armor
subobjtyp cape	//armor
subobjtyp helm	//armor
subobjtyp gloves	//armor
subobjtyp cannon	//shld
subobjtyp boots	//armor
subobjtyp greev	//shld
subobjtyp amul	//baub
subobjtyp ringl	//baub
subobjtyp ringr	//baub
subobjtyp wristl	//baub
subobjtyp wristr	//baub
subobjtyp crown	//baub

enum equipenum = {ENUM_WEAP_LEFT,ENUM_WEAP_RIGHT,ENUM_SHIELD_ENUM_BOW,ENUM_ARMOR,ENUM_CAPE,ENUM_HELM,
ENUM_GLOVES,ENUM_CANNON,ENUM_BOOTS,ENUM_GREEV,ENUM_AMUL,ENUM_RING_LEFT,ENUM_RING_RIGHT,ENUM_WRIST_LEFT,
ENUM_WRIST_RIGHT,ENUM_CROWN}	//17?! REALLY?!?!

psudo update_player
/* resets .fromequip , then iterates through the entire equipment list to regenerate it.
 * must be called every time equipment is changed to ensure that it is up to date
 * effects in .permenent can only be removed by finding something that affects the opposite change
 * changes to your starting alignment or base race are generally rare and disasterous, as they represent
 * the corruption of the character in some way (i.e. if you recursively polymorph,
 * or are polymorphed while turning to stone, you may forget who you are. this does cure stoning.
 * if this happens and you become a race that is not a c0 control character,
 * your class will be set to changling.)
 * other entities can only be polymorphed into things in their own symbol table.
 */

pseudo inventsort
/* compresses stackable items into stacks, sorts items by objid and itemid.
 * more computationally expensive than update_player.
 */

int itemswap (item1,item2)
heldobjtyp *item1
heldobjtyp *item2
{
heldobjtyp *prev1 = item1->prev
heldobjtyp *prev2 = item2->prev
heldobjtyp *next1 = item1->next
heldobjtyp *next2 = item2->next
if (item1->next = item2) {
	prev1->next = item2
	item2->prev = prev1

	item2->next = item1
	item1->prev = item2

	next2->prev = item1
	item1->next = next2
	}
if (item2->next = item1) {
	prev2->next = item1
	item1->prev = prev2

	item1->next = item2
	item2->prev = item1

	next1->prev = item2
	item2->next = next1
	}
else {
	prev1->next = item2
	item2->prev = prev1

	next1->prev = item2
	item2->next = next1

	prev2->next = item1
	item1->prev = prev2

	next2->prev = item1
	item1->next = next2
	}
}

struct basentyp:
aligntyp alignmask
paffectyp base
unsigned char spd	//distance calculations use M_SQRT2 for diagonals
unsigned char fly
unsigned char hplvl
unsigned char mplvl
unsigned char xplvl
unsigned char airmax
symtabref lang0 : 6
symtabref lang1 : 6
symtabref spell0
symtabref spell1
char16_t Rune
bool eats_you : 1
bool shadow : 1
signed char size : 2
stattyp stats : 8
sensetyp sense : 8
resistyp resist : 8
unsigned char color : 8
/* entitys of size 1 or -2 cannot use armor.
 * entitys of larger size automaticly win grapples.
 * entitys of 2 sizes smaller can be picked up and thrown.
 * entitys of size 1 can instakill entitys of size -2. squish.
 * size 1: dragon, size 0: human, size -1: elf, size -2: pixie
 */

struct aggrotyp:
bool shiftable : 1	//nowhere else to put it.
unsigned char patience : 3
unsigned char ai_type : 4
unsigned char cooldown : 8

struct enttyp:
(self) *prev
(self) *next
aggrotyp aggro
symtabref race
unsigned char meta
coord3 loc
polar facing
vector3 velo
effectyp effect
unsigned short hp
unsigned char air
unsigned short xp
unsigned char lvl
unsigned char gold
subobjtyp loot
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
subobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr
subobjtyp crown

struct heldobjtyp:
(self) *prev
(self) *next
unsigned char stack //stack+1 items are present. lumping them together is a complicated operation. 
objid type
void* data

struct subobjtyp:
symtabref itemid : 8
bool cursed : 1
bool oxide : 1
bool burned : 1
signed char bonus : 5
unsigned char metadata : 8 //secondary symtabref for legendary objects

struct magictyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1 //entropy is not light. entropy is not darkness. entropy is balance. entropy is fate; doom; *death*. not things you want to be on the wrong end of.
bool light : 1 //light is not necisarrily good
bool dark : 1 //dark is not necisarrily evil
bool planer : 1

struct toomuchpolytyp:
unsigned char count : 8
unsigned char depth : 8

struct spelltyp:
symtabref itemid
diceodds odds
unsigned char prof

struct basespelltyp:
bool poly : 1
bool heal : 1
unsigned char pow : 6
magictyp type : 8
void* effect //either missiletyp or mapcoord; mapcoord always iff planer, set the type flag accordingly for the inner planes

struct missiletyp:
cursetyp curse
unsigned char damage : 6
signed char recoil : 7
unsigned char cost : 4
unsigned char spread : 2 //0 = line, 1 = narrow (1:3), 2 = wide (1:2), 3 = very wide (1:1)
unsigned char splash : 3 //radius of damage on impact
bool spz : 1 //spread and splash in the z plane. spread on the z plane is capped to ± spread (literal)
bool dig : 1 
//if (.spread != 0), slope = 4-.spreaad

struct baseweaptyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool illum : 1
unsigned char skill : 3
unsigned char damage : 8

legendtyp:
paffectyp magic
symtableref base
symtableref spell
legendflagtyp flags

legendflagtyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool unbreak : 1
bool infinate : 1
bool spelled : 1
bool vamp : 1
bool drain : 1
bool interest : 1
bool useless : 1
unsigned char times2pow : 5

struct basearmortyp:
effectyp
unsigned char def : 8
unsigned char spdef : 8
unsigned char extfort : 8

struct baseshldtyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool reflect : 1
bool entro : 1
bool light : 1
bool dark : 1
effectyp
unsigned char def : 8
unsigned char spdef : 8

struct stattyp:
caster
psion
gills
wings
nolegs
noarms
blind
whoami

struct ailmntyp:
dizzy : u4
psn : u4
prlz : u4
frz : u4
brn : u4
stone : u4
slp : u8
blind : u8
poly : u8
eaten : u8

struct cursetyp:
dizzy : b
psn : b
prlz : b
frz : b
brn : b
stone : b
slp : b
blind : b

struct elixtyp:
cursetyp type
unsigned char poly
signed char lvl

struct resistyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool stoneproof : 1
bool polyproof : 1
bool sleepproof : 1
bool poisonproof : 1

struct sensetyp:
trouble
hidden
invis
infra
good
evil
law
chaos

struct effectyp:
the8stats eight
stattyp stat
ailmntyp ails_ya
resistyp resist
senstyp sense
skilltyp skill
magictyp asp
signed char atk
signed char spatk
signed char def
signed char spdef

struct paffectyp
the8stats eight
stattyp stat
cursetyp curse
resistyp resist
senstyp sense
skilltyp skill
magictyp asp

struct potiontyp:
stattyp stat
elixtyp ails_ya
resistyp resist
senstyp sense
signed short hp
signed short mp
diceodds odds

struct skilltyp:
unsigned char sword : 3 //+skill to sword-type weapon attack
unsigned char knife : 2 //+skill to knife-type weapon attack
unsigned char stave : 3 //+skill to stave-type weapon attack
unsigned char spear : 3 //+skill to club-type weapon attack
unsigned char club : 2 //+skill to club-type weapon attack
unsigned char bow : 3 //+skill to bow-type weapon range
unsigned char throw : 3 //+skill to javalin-type weapon range
unsigned char monk : 4 //+(2*skill) to barehanded attack
unsigned char shield : 3 //skill in (damage-defense)+|damage-defense| chance of blocking
unsigned char locks : 3 //1 in 2^(lock.level - (skill)) chance of picking
unsigned char cast : 3 //-skill/2 to casting cost, +skill/2 to spatk, spdef
/* damage(incoming)-defense =
 * ⎰if >0: damage(target)
 * ⎱if ≤0: moot
 */

readtyp:
unsigned char locale : 6
bool multiuse : 1
bool scroll : 1
unsigned char subject : 2 //0 = cooking, 1 = weapons, 2 = language, 3 = spellcraft
unsigned char uses : 6
*void contents

char* wandmaterials[16] = {"oak","ash","yew","honeylocust","silver","bronze","iron","orichalcum","marble","bone","dragon fang","unicorn horn","glass","lead crystal","adamantine","stardust"} //stoning -> marble

wandtyp:
unsigned char matter : 4
unsigned char uses : 4
symtabref bound : 8

char* baubmaterials[8] = {"yew","bronze","silver","gold","soapstone","ivory","obsidian","stardust"} //stoning -> soapstone

baubtype :
signed char type : 2 //0=ring, 1=bracelet, -1=amulet, -2=tiara
unsigned char matter : 3
unsigned char color : 3
paffectyp enchnt

struct roomtyp: //top-down display of a 3d space
tileset *lowtiles
tileset *hightiles
signed char tiledata[8][18][64] //entity coords refer to the 3-grid boxes of a given coord, while tiles refer to a given xy square on the plane that is the lower bound of said boxes.
shadowmask seen
enttype *ent_head
enttype *ent_tail
mapobjtyp *obj_head
mapobjtyp *obj_tail
lightyp *lamp_head
lightyp *lamp_tail
coord2 downstair
coord3 upstair
coord3 home
unsigned char keynum
/* z coord of the upstair is the maximum height of the map, obviously.
 * upstair is not rendered on dep=>0, but must still be present.
 * if invalid coords are given for a warp (typically {$FF,$FF}),
 * then the player is dumped at the location indicated by home.
 *
 * if the player has invalid coords, then the error string "fell out of terminal",N1=x,N2=y is generated.
 */

/*      .r8 : binary data that is organized into 8 bit segments
 *     .r16 : binary data that is organized into 16 bit segments
 *     .hex : binary data that is not organized
 *     .csv : UTF-8 record seperated with commas and line breaks
 *     .tsv : UTF-8 record seperated with tabs and line breaks
 *     .dat : UTF-8 record seperated with control characters $1C-$1F and line breaks
 *     .txt : a plaintext document in UTF-8 encoding, usually stored in the program's static files, which is CAT-ed to provide dialouge.
 *    .ansi : an ansi-escaped text document in UTF-8 encoding, usually stored in the program's static files, which is CAT-ed to provide dialouge.
 *     .ini : key-value pairs.
 *    .conf : key-value pairs and SIMD operations. may also be a dotfile.
 *    .json : an s-expresson like data format, originally from javascript. used in core
 *  .tar.gz : by default, each room's directory is automatically compressed using an os call to prevent disk hogging (tar -xzf to open, or tar -czf to store)
 * .tar.bz2 : by default, each plane's directory is further compressed (tar -xjf to open, or tar -cjf to store). savefiles are also this format. all compression options are changeable before compile.
 *   .man.# : a manpage
 *    .html : extended documentation
 *      .md : extended documentation
 */

struct shadowmask bitfield[18][64]

typedef tilemeta* tileset[128]

struct tilemeta {
bool ladder : 1
bool solid : 1
bool fluid : 1
bool conductive : 1

bool burns : 1
bool hypotherm : 1
bool sharp : 1
bool singularity : 1

bool freezes : 1
bool melts : 1
bool petrif : 1
bool dig : 1

unsigned char color : 7
symtabref ice : 7
symtabref melt : 7
symtabref stone : 7

char16_t Rune : 16
}
/* tiles can be effected by stuff happening around them.
 *
 * if a tile is flammable, a fire is summoned when fire magic
 * enters the space or 1d6 chance if there is fire within 1 taxicab of it.
 *
 * if a tile is conductive, then electricity is summoned for the instant
 * that electrical magic strikes it, and propagates through contiguous tiles.
 *
 * if a tile can freeze, it's symtabref is changed to the number indicated by ice.
 * when ice magic intersects it.
 *
 * if a tile can melt, it's symtabref is changed to the number indicated by melt
 * when fire or electrical magic intersect it.
 *
 * if a tile can be petrified, it is changed to the tile indicated by stone.
 *
 * if a tile can be dug, using a ↧digging tool on it will remove it
 */

pseudo getsym
	{
	if (sym < 0)
		{
		cursesprint(.hightiles[sym^-128]) //xor intentional
		}
	else
		{
		cursesprint(.lowtiles[sym])
		}
	}

mapobjflags:
hidden : 1
class : 2
exneutral : 1
exlawgood : 1
exlawevil : 1
exchaosgood : 1
exchaosevil : 1

struct mapobjtyp:
(self) *prev
(self) *next
coord3 pos
objid type
void* data
mapobjflags flags
aligntyp align

struct mapobjtyp:
(self) *prev
(self) *next
coord3 pos
unsigned char lum

struct chestyp:
heldobjtyp *bag_head
heldobjtyp *bag_tail
cursetyp trap
locktype locked

struct locktype {
bool locked : 1
bool level : 3
bool pin1 : 1
bool pin2 : 1
bool pin3 : 1
bool pin4 : 1
/* lockpicking requires the player to enter
 * 0 and + in the correct order to turn the
 * tumblers. in addition to making the correct
 * guess, one must make a skill check:
 * 1 in 2^(lock.level - (skill/2)) chance
 */

miscitemtyp
symtabref itemid : 8

struct miscitembasetyp:
bool key : 1
bool pick : 1
bool dig : 1
bool music : 1
bool light : 1
bool book : 1
bool spark : 1
bool quest : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool stoneproof : 1
bool arrow : 1
bool poisoned : 1
bool unbreak : 1
unsigned char uses : 8
unsigned char meta : 8

struct eventtyp:
(self) *prev
(self) *next
char16_t Rune
triggerfunc ifthis()
eventfunc dothis(paramtyp)
paramtyp params
const char* name
cylinder dim
unsigned long duration
/* events call raw C functions, without any sort of restrictions on what they have
 * access to beyond what the program can give it. the idea is to provide a full
 * turing-complete interface by which the game's world can be altered according
 * to actions taken by the player. another use would be to show a cutscene rendered
 * with raw curses calls; an elaborate example of curses used in that manner
 * will be found in the game's introduction cutscene.
 */

struct qglobobj: //queued global object
(self) *prev
(self) *next
mapcoord glob_pos
coord3 pos
objid type
void* data

struct traptyp:
(self) *prev
(self) *next
unsigned char color
char16_t Rune
coord3 loc
unsigned short duration
magictyp
stattyp stat
elixtyp ails_ya
diceodds odds
trapflags flags
senstyp sense
signed short hp
signed short mp

struct trapflags:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool tamperproof : 1
bool stoneproof : 1
bool warded : 1
bool multiuse : 1

struct warptyp:
(self) *prev
(self) *next
unsigned char color
char16_t Rune
mapcoord glob_loc
coord3 loc
mapcoord glob_dest
coord3 dest
unsigned short duration

char* gemcolors[8] = {"jet","sapphire","emerald","turquoise","ruby","amythest","heliodor","diamond"} //stoning has no effect
/* cut varys by color:
 * diamond = {uncut,cushion-cut,princess-cut,perfect-cut}
 * beryls,emerald={uncut,oval-cut,emerald-cut,teardrop} redundancy of emerald-cut emerald is redundant
 * amythest={geode,prismatic,cushion-cut,teardrop}
 * jet,turquoise={piece of,byzantine,polyhedral,carved relif in}
 */

struct gemstonetyp:
unsigned char color : 3
unsigned char quality : 2
unsigned char cut : 2

struct meattyp:
symtabref race : 8
bool hightable : 1
unsigned char sellby : 7
unsigned char amount : 8

struct foodtyp:
symtabref itemid
symtabref metadata
unsigned char sellby
unsigned char amount

foodbasetyp:
effectyp effect
diceodds odds
unsigned char keepsfor
unsigned char hp
unsigned char nutri

always (unsigned short,unsigned short,unsigned short,unsigned short) {return 1}

enum objid:
WEAPON_FLAG : contains subobjtyp calling baseweaptyp
POTION_FLAG : contains potiontyp
READ_FLAG : contains readtyp
FOOD_FLAG : contains subobjtyp containing foodtyp
MEAT_FLAG : contains subobjtyp containing meattyp
ARMOR_FLAG : contains subobjtyp calling basearmortyp
SHLD_FLAG : contains subobjtyp calling baseshldtyp
BAUB_FLAG : contains subobjtyp calling baubtyp
CONLANG_FLAG : contains conlangtyp
SPELL_FLAG : contains spelltyp
MISC_FLAG : contains itemtyp
GEM_FLAG : contains gemstonetyp
TRAP_FLAG : contains traptyp
EVENT_FLAG : contains eventtyp
QGLOB_FLAG : contains qglobobj
WARP_FLAG : contains warptyp
CHEST_FLAG : contains chestyp
DOOR_FLAG : contains locktyp
GOLD_FLAG : contains an unsigned interger stored as a pointer

pseudo radius
/* uses floats to define a circle,
 * terminating on the symbol that is
 * GE than the input. one function won't
 * cover all use cases.
 */

each layer is drawn translated +1y for each layer above the player and -1y for each layer below.
a shadow is drawn under the player
layers are drawn from ground to sky; if the player or their shadow would be covered by a tile,
drawing is stopped and the player is drawn if they have not been already
fluid tiles are transparent.

to avoid confusion, by default the player always uses a unique character: ☻

an UNDERLINE is a shadow

) is a sword or dagger. ⍏ is a polearm or staff. ‡ is a club or mace. ⦅ is a bow. ⇤ is an arrow.
⟦ is armor. [ is clothing. ] is a shield. ⟧ are cannons or greeves.  % is food. $ is gold. · is a rock.
£ is a misc item. ↧ is a digging tool. ⌥ is a key or lockpick. ⌘ is a special item. ¿ are potions (fragile).
∫ is a scroll. ⊒ is a book. ∩ is a tablet. ◆ is a gemstone. ° is a ring. º is a bracelet. ª is an amulet.
^ is a crown. / is a wand. ~ is a liquid. ≈ is a liquid's surface. ≣ is a ladder. ⋎ is a fountain. ∪ is a sink. 
∿ is fire. ⌁ is electricity. * is ice. ⎈ spider web. ⋏ are spikes. ⌸ is a door. ⍯ is a locked door.
? is invisible. ! is trouble. ¤ is a light source. ⍝ is a tombstone. ⎅ is a signpost. ␥ is glass.
O is a boulder. ◊ is a giant magic crystal. ♠ ♣ are trees. ✪ is a trap. < > are level stairs.
← ↑ → ↓ ↖ ↗ ↘ ↙ are flying projectiles. ∅ is a pulsar (do not touch). ↯ the thunderbolt.
⇐ ⇑ ⇒ ⇓ ⇖ ⇗ ⇘ ⇙ are cannons. box drawings are low walls. █ is a thick wall. ⏍ is a chest. 
▓ is an unlit area that you have visited. ▒ is a lit area that you have visited.
☁ is a cloud (no walking and keep your head out). ␣ is a hole. ⍰ is a missingno.

BOLD symbols are petrified (statues).
BLINK is the edge of an illuminated area or something requiring your attention.
if something is not able to be seen, it is rendered INVISIBLE
REVERSE video is a magic spell's area of effect, an identified rune, or your cursor.

rune symbols
◬ air, ⍫ earth, △ fire, ▽ water, ⍰ missingno
* ice, ↯ electricity, ⍏ metal, ♠ nature
☠ poison, Z sleep/stoning (bold), % entropy
☼ light, ☽ dark, § polymorph, ↹ planer
♥ healing

magic AOE symbols
☁ air, ∅ earth, ∿ fire, ≈ water
* ice, ⌁ electricity, $ metal, ♠ or ♣ nature
☠ poison, Z sleep/stoning (bold), % entropy
¤ light, ▓ dark, § polymorph, ↹ planer


unsigned char getsixbit_template() {
switch (getc(stdin)) {
	case '!' :
		return 01;
		break;
	case '"' :
		return 02;
		break;
	case '#' :
		return 03;
		break;
	case '$' :
		return 04;
		break;
	case '%' :
		return 05;
		break;
	case '&' :
		return 06;
		break;
	case '\'' :
		return 07;
		break;
	case '(' :
		return 010;
		break;
	case ')' :
		return 011;
		break;
	case '*' :
		return 012;
		break;
	case '+' :
		return 013;
		break;
	case ',' :
		return 014;
		break;
	case '-' :
		return 015;
		break;
	case '.' :
		return 016;
		break;
	case '/' :
		return 017;
		break;
	case '0' :
		return 020;
		break;
	case '1' :
		return 021;
		break;
	case '2' :
		return 022;
		break;
	case '3' :
		return 023;
		break;
	case '4' :
		return 024;
		break;
	case '5' :
		return 025;
		break;
	case '6' :
		return 026;
		break;
	case '7' :
		return 027;
		break;
	case '8' :
		return 030;
		break;
	case '9' :
		return 031;
		break;
	case ':' :
		return 032;
		break;
	case ';' :
		return 033;
		break;
	case '<' :
		return 034;
		break;
	case '=' :
		return 035;
		break;
	case '>' :
		return 036;
		break;
	case '?' :
		return 037;
		break;
	case '@' : noop();
	case '`' :
		return 040;
		break;
	case 'A' : noop();
	case 'a' :
		return 041;
		break;
	case 'B' : noop();
	case 'b' :
		return 042;
		break;
	case 'C' : noop();
	case 'c' :
		return 043;
		break;
	case 'D' : noop();
	case 'd' :
		return 044;
		break;
	case 'E' : noop();
	case 'e' :
		return 045;
		break;
	case 'F' : noop();
	case 'f' :
		return 046;
		break;
	case 'G' : noop();
	case 'g' :
		return 047;
		break;
	case 'H' : noop();
	case 'h' :
		return 050;
		break;
	case 'I' : noop();
	case 'i' :
		return 051;
		break;
	case 'J' : noop();
	case 'j' :
		return 052;
		break;
	case 'K' : noop();
	case 'k' :
		return 053;
		break;
	case 'L' : noop();
	case 'l' :
		return 054;
		break;
	case 'M' : noop();
	case 'm' :
		return 055;
		break;
	case 'N' : noop();
	case 'n' :
		return 056;
		break;
	case 'O' : noop();
	case 'o' :
		return 057;
		break;
	case 'P' : noop();
	case 'p' :
		return 060;
		break;
	case 'Q' : noop();
	case 'q' :
		return 061;
		break;
	case 'R' : noop();
	case 'r' :
		return 062;
		break;
	case 'S' : noop();
	case 's' :
		return 063;
		break;
	case 'T' : noop();
	case 't' :
		return 064;
		break;
	case 'U' : noop();
	case 'u' :
		return 065;
		break;
	case 'V' : noop();
	case 'v' :
		return 066;
		break;
	case 'W' : noop();
	case 'w' :
		return 067;
		break;
	case 'X' : noop();
	case 'x' :
		return 070;
		break;
	case 'Y' : noop();
	case 'y' :
		return 071;
		break;
	case 'Z' : noop();
	case 'z' :
		return 072;
		break;
	case '[' : noop();
	case '{' :
		return 073;
		break;
	case '\' : noop();
	case '|' :
		return 074;
		break;
	case ']' : noop();
	case '}' :
		return 075;
		break;
	case '^' : noop();
	case '~' :
		return 076;
		break;
	case '_' :
		return 077;
		break;
	default :
		return 0;
		break;
	}
}

foods (* = uses meta)
hardtak tortilla cornmeal cornbread
flour cheese wine bread
mead ale scotch ethenol
grapes fig date plum
apple banana apricot papaya
orange pear pinapple coconut
kiwi dragonfruit durin peach
grapefruit lemon lime citron
spinach artichoke asparagus bamboo
cucumbers zuccini pickles squash
carrot corn potato celery
brocoli lettuce cabbage kale
cauliflower raddish turnip beets
rhubarb pumpkin avacodo jalapenos
beans greenbeans tomato eggplant
blackolives greenolives garlic onions
watercress chives ketchup mustard
parsly sage rosmary thyme
basil oregano allspice nutmeg
salt bellpeppers peppercorns redpepper
vanillabean cinnimonstick cocoabean sugarbeet
walnut pecan cashew peanut
sunflowerseed pistachio almond chestnuts
cranberrys blueberrys raspberry blackberry
strawberry cherry peppermint pawpaw
sugarcane syrup* molasses honey
seseme poppy fennel eyeofnewt
mushroom* truffel penecillin yeast
barly wheat rye rice
ginger sasafrass blueraspberries bubbles 
geletin starch creamoftartar bakingpowder
vinager bakingsoda calciumhydroxide hemlock
popcorn nachos cookies milk*
pasta(uncooked) pasta ramen(uncooked) ramen*
dumplings(uncooked) dumplings* tofu(uncooked) tofu
meatballs marinara alfredosauce parmisian
lasagnia* pizza* spaghetti alfredo
spaghetti&meatballs ramen&dumplings chickenalfredo brocllialfredo
guacamole nachos* chili salsa
pie* cake* soda* chips
salad* hotdog* hamburger* fries
vanilla cinnimon chocolate sugar
cocoapowder cocoabutter cocoaliquor fudge
egg fat* caramel butterscotch
sourcream butter/shortening* mayo dressing*
pie* pie_alamode* englishfruitcake bread*
cake* pancake* waffle* stackofpancakes*
frozenpancake frozenwaffle flavoredmilk* juice*
roast* gravy foo&gravy* foo_chicken*
bakedpotato loadedbakedpotato mashpotatos tatties&neeps
sunnysideup overeasy scrambled hardboiled
bacon* sausage* jerky* spam
nutbrittle* trailmix rasin* peanutbuttersandwich*
baconlettucetomatosandwich clubsandwich fingersandwich* coldcutsandwich*
milkshake* icecream* sorbet* icecreamfloat*
icecreamcone* banannasplit neopolitan rockyroad
gumdrop* hardcandy* candycane filledchocolate*
jelly* jam* preserves* peanutbutter
icecube snow ember blacksoup
broth* stew* ration mistake

pseudosubroutine playermove(xmove,ymove,zmove)
signed char xmove
signed char ymove
signed char zmove
{
velocitycheck()
xymovecheck(xmove,ymove)
zmovecheck(zmove)

PLAYER.pos.x += xmove
if (PLAYER.pos.x < 0) {
	PLAYER.pos.x = 63
	mapscroll(-1,0)
	}
else if (PLAYER.pos.x ≥ 64) {
	PLAYER.pos.x = 0
	mapscroll(1,0)
	}

PLAYER.pos.y += ymove
if (PLAYER.pos.y < 0) {
	PLAYER.pos.y = 17
	mapscroll(0,-1)
	}
else if (PLAYER.pos.y ≥ 18) {
	PLAYER.pos.y = 0
	mapscroll(0,1,0)
	}

PLAYER.pos.z += zmove
}

pseudosubroutine playervelocitycheck() velocitycheck(*entity)
	- moves you by a vector defined by velocity,
	  checking each space for friction. if friction
	  is encountered, assume it is infinate.

pseudosubroutine xymovecheck(xmove,ymove)
	- aborts if you're flying
	- checks to make sure you're not walking off a cliff,
	  asks for confirmation if you are.
	- automatically steps if only 1 block of z difference
	  to another solid block in direction of travel,
	  moving by a distance of SQRT3 if on a diagonal,
	  M_SQRT2 otherwise.
	- updates your direction
	- if you're on ice, adds your movement to your velocity.

pseudosubroutine zmovecheck(zmove)
	- checks if you can fly
	  if you can't fly, adds -grav to your z velocity
	- checks to make sure you are not flying through the ground,
	  through a solid block, or through the ceiling

pseudosubroutine newtonlaw(xmove,ymove,zmove)
	- checks if you're flying magically, on ice, or in a liquid
	- if you are, adds {-xmove,-ymove,-zmove} to your velocity
	  (half this value in liquids)

pseudosubroutine mapscroll(latmove,lonmove)
signed char latmove
signed char lonmove
{
saveroom()
WORLD.coord.lat += latmove
if (WORLD.coord.lat > 180) {
	WORLD.coord.lat += -360
	}
else if (WORLD.coord.lat ≤ -180) {
	WORLD.coord.lat += 360
	}

WORLD.coord.lon += lonmove
if (WORLD.coord.lon > 180) {
	WORLD.coord.lon += -360
	}
else if (WORLD.coord.lon ≤ -180) {
	WORLD.coord.lon += 360
	}

loadroom()
}

pseudosubroutine mapscrollz(depmove,hole)
bool depmove
bool hole
{
saveroom()

WORLD.coord.dep += ( (depmove) ? -1 : 1)

if (WORLD.coord.dep > 100) {
	WORLD.coord.dep = 199 - WORLD.coord.dep
	WORLD.coord.lon += 180
	if (WORLD.coord.lon > 180) {
		WORLD.coord.lon += -360
		}
	//latitude does not change, because doughnut
	}

else if (WORLD.coord.dep < -100) {
	WORLD.coord.dep = -100
	}

loadroom()

if (depmove) {
	if (!hole) {
		PLAYER.pos.x = ROOM.upstair.x
		PLAYER.pos.y = ROOM.upstair.y
		}
	PLAYER.pos.z = CEILING
	}
else {
	if (!hole) {
		PLAYER.pos.x = ROOM.downstair.x
		PLAYER.pos.y = ROOM.downstair.y
		}
	PLAYER.pos.z = 0
	}
}

pseudosubroutine mapwarp(latmove,lonmove,depmove,tocoord)
signed char latmove
signed char lonmove
signed char depfrom
coord3 tocoord
{
saveroom()

if (depmove > 100) {
	depmove = 199 - depmove
	lonmove += 180
	//latitude does not change, because doughnut
	}

WORLD.coord.dep = depmove

WORLD.coord.lat = latmove
if (WORLD.coord.lat > 180) {
	WORLD.coord.lat += -360
	}
else if (WORLD.coord.lat ≤ -180) {
	WORLD.coord.lat += 360
	}

WORLD.coord.lon = lonmove
if (WORLD.coord.lon > 180) {
	WORLD.coord.lon += -360
	}
else if (WORLD.coord.lon ≤ -180) {
	WORLD.coord.lon += 360
	}

loadroom()

if ((tocoord.x > 63) || (tocoord.y > 17) || (tocoord.z > CEILING)) {
	PLAYER.pos.x = ROOM.home.x
	PLAYER.pos.y = ROOM.home.y
	PLAYER.pos.z = ROOM.home.z
	}
else {
	PLAYER.pos.x = tocoord.x
	PLAYER.pos.y = tocoord.y
	PLAYER.pos.z = tocoord.z
	}
}

pseudosubroutine saveroom()
/* overwrites files in tmp
 * tar's the files and saves the archive in the savefile
 * frees any data that is no longer neccisary
 */

pseudosubroutine loadroom()
/* unarchives files to tmp
 * loads files into memory
 */

pseudosubroutine saveworld()
pseudosubroutine loadworld()
/* same as saveroom/loadroom; except
 * manipulates files for planes
 */

pseudosubroutine savestate()
pseudosubroutine loadstate()
//saves or loads globals

unsigned char pseudosubroutine castshadow(xpos,ypos,zpos)
unsigned char xpos
unsigned char ypos
unsigned char zpos
{
if (zpos == 0) {
	return zpos
	}
else if !(mapderef(xpos,ypos,zpos-1).liquid) {
	underline(xpos,ypos,zpos)
	return zpos
	} else {
	zpos--
	for (;zpos!=0;zpos--) {
		if (mapderef(xpos,ypos,zpos-1).solid {
			underline(xpos,ypos,zpos)
			if !(mapderef(xpos,ypos,zpos-1).liquid) {
				return zpos
				}
			}
		}
	underline(xpos,ypos,zpos)
	return zpos
	}

bool maskfetch(zcoord,ycoord,xcoord,mask)
unsigned char zcoord
unsigned char ycoord
unsigned char xcoord
shadowmask mask
{
switch (zcoord) : {
	case 0 : return mask[ycoord][xcoord].a;
	case 1 : return mask[ycoord][xcoord].b;
	case 2 : return mask[ycoord][xcoord].c;
	case 3 : return mask[ycoord][xcoord].d;
	case 4 : return mask[ycoord][xcoord].w;
	case 5 : return mask[ycoord][xcoord].x;
	case 6 : return mask[ycoord][xcoord].y;
	case 7 : return mask[ycoord][xcoord].z;
	default : return 0;
	}
}

maskwrite(zcoord,ycoord,xcoord,mask,value)
unsigned char zcoord;
unsigned char ycoord;
unsigned char xcoord;
shadowmask mask;
bool value;
{
switch (zcoord) : {
	case 0 : mask[ycoord][xcoord].a = value; break;
	case 1 : mask[ycoord][xcoord].b = value; break;
	case 2 : mask[ycoord][xcoord].c = value; break;
	case 3 : mask[ycoord][xcoord].d = value; break;
	case 4 : mask[ycoord][xcoord].w = value; break;
	case 5 : mask[ycoord][xcoord].x = value; break;
	case 6 : mask[ycoord][xcoord].y = value; break;
	case 7 : mask[ycoord][xcoord].z = value; break;
	default : return 1;
	}
return 0;
}

.conf file interface:
...
:COMMAND is a command
key=data is a key-value pair
...
!bool is a false value
+bool is a true value
^bool is a balanced ternary value
...
"string" is a string
/foo/bar/baz is a path
~/quux/garply is also a path
...
1234 is a decimal interger
-1234 is a negative decimal interger
12.34 is a float
-12.35 is a negative float
$1234 is a hex interger
@1234 is an octal interger
%1010 is a binary interger 
\a is the unicode address of a character
... 
¶ is an include directive
comments may take several forms:
#foo
//foo
;foo
§foo
/*foo*/
[foo]

pseudo text:
print at most 4 lines of 1 message before prompting acknowlage

main () {
if (NEW) {
	checkglobal()
	NEW = false
	}
checkevents() //check event triggers
player_act() //player's turn
purs_iter() //iterate through persuer entities
ent_iter() //iterate through local entities
}

pseudo <purs|ent>_iter () {
enttyp* ptr = <head>
while (ptr != NULL) {
	<purs|ent>_act(&ptr) //&ptr's turn
	ptr = ptr->next
	}
}

pseudo render() {
/* flush THESHADOWKNOWS and SHINEALIGHT
 * cast shadows and record the player's shadow
 * illuminate the player according to their view range
 * illuminate all lights in the room.
 * get the player's view information. only draw tiles that can be seen.
 * draw each layer of the room one at a time, making sure the player and their shadow are not covered, and doing out-of-view substitution.
 * draw the player
 * draw other entitys that can be seen
 * add shadows
 */