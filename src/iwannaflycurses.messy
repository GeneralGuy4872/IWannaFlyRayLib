#error NOT READY FOR COMPILATION
/* to preserve the file history,
 * this file will eventually become main.h, main.c, or util.c
 * a dummy.h and dummy.c will provide externs and macros for linkage.
 * some of the larger comment blocks will be moved to man, info, and/or doc
 *
 * the bulk of it's contents, however, will be moved.
 *
 * workflow:
 * outline blackboxes top-down (-ish)
 * outline pseudocode top-down (-ish)
 * write real code bottom-up
 * structs are made both top-down (specific) and bottom-up (generic)
 * changes must be propogated both down and up
 */

/******************************
 * IWANNAFLY (working title)  *
 * Top-down 3D Rogue-like     *
 * Game engine with C API &   *
 * Custom Extension Language, *
 * using NCurses and MIDI     *
 ******************************/

/* Hey, you. yeah, you. who do you think I'm talking to; the mouse?
 *
 * you found the seeecret extended documentation, aka the commentated
 * source code! the sorce code's witty comments are intended to supplement
 * other documentation, as well as give a deeper understanding of the
 * program because, ya'know, source code.
 *
 * note to imaginary future packagers: if packaged in binary form, a dummy header might
 * still be required to support the obfuscated C syntax that is recommended for use
 * with this library. if you don't know what "obfuscated" C is, look at the original
 * unix v7 source of ye old bourne shell for the definative example.
 *
 * the engine should be compiled as a shared object, and installed according to the
 * values set in paths.h
 *
 * a game compiled for the engine should obey the following conventions:
 * - it should provide the bulk of it's functions in a shared library in a private
 *	application directory
 * - it should provide special use functions, such as events, as seperate shared objects,
 *	to be dynamically loaded at runtime.
 * - it should provide special use constants likewise
 *	blocks of text, however, should be regular nfo or txt
 * - it should store any dynamic constants in the savefile, as r<wordsize>, hex, tsv, csv, ini, txt, nfo
 * - it should provide at least the following applications (in $PATH) :
 *	- the game itself
 *	- a seperate program for generating a new savefile
 *		- should use (int argc, char *argv[]) to provide bypassing of dotfile,
 *		  path to a non-default dotfile, overrides of race, class, alignment prefs,
 *		  and other flags as desired. parsed by a different parser from the dotfile.
 *	- a savefile editor
 *
 * enviromental requirements:
 * - UTF-8 terminal of at least 24*80 characters
 *	"Fixed" font is recommended (specifically because
 *		it is a raster font; monospaced raster fonts are more uniform in width than the majority of vector so-called "monospaced" fonts;
 *		it is unicode, having a wide range of characters; and
 *		it is extreamly common, being the default font for the linux console, xterm, and urxvt)
 * - ANSI SGR escape codes and 16 colors outside of NCurses
 *	The engine will recognise the term enviroment and can sent xterm-style OSC strings if they are supported as well
 * - NCurses with support for A_BOLD, A_ITALIC, A_UNDERLINE, A_DIM, A_BLINK, A_REVERSE, A_INVIS, 8 colors, and 64 color pairs
 * - Full Keyboard
 *	(most keyboard layouts with all ASCII characters *should*
 *	work, but only QWERTY (US-ANSI) was used in design because
 *	I don't have access to any others, so at best controls may
 *	be strange on them.
 *	want to eventually guaruntee support for other keymappings;
 *	not just for other QWERTY layouts, but also for QWERTZ, AZERTY,
 *	and Dvorak, by request and/or the ability to remap keys
 *	by dotfiles.)
 * - Mouse (once pseudo-raycasting is implemented for looking afar)
 *
 * XTerm is the recommended X Terminal Emulator (the primary one used in testing),
 * but the raw TTY Console set up in UTF8 locale will work just as well,
 * maybe even better if memory is an issue. At first glance, A Vt241 or Vt3*0
 * seem to meet all the requirements, but note: they predate unicode.
 * 
 * Controls:
 * - number keys move in xy
 * - arrow keys move in x or y
 * - < and > move in z
 * - page up or page down, followed by a direction, move in xyz 
 * - home starts flying
 * - end stops flying
 * - spacebar or 5 idle
 * - ! shows or hides sense trouble
 * - . pick up items
 * - \ initiates the command console
 * more tbd
 *
 * new saved worlds will be generated by a seperate program.
 *
 * depending on RAM or Disk usage of the final program, it may be necissary
 * to run early versions in the system console to prevent resource starvation,
 * or to use a dedicated memory stick for the save files for the same reason.
 * if such requirements arise, they will be considered a severe flaw and work
 * will focus on fixing them as soon as possible.
 *
 * This program is divided into 3 layers:
 *
 * the API layer is the part that provides functions to help with events.
 *	this is the only part you should need to know to compile your own
 *	games that can get fairly complex. these alse include the internal
 *	utilitys for character encoding conversion, input buffering, room
 *	generation and pathfinding algorithems, dice, warping, dying, error,
 *	and the internal implementation of cat.
 *
 * while the API functions have a simple enough calling convention,
 * there is no garuntee that the code underneath is not hundreds of lines long.
 * the sequence to bring the engine up is:
 *
 * termcheck()
 * enginesplash(name of game,game version,story revision)
 * <your startup stuff here>
 * FIXCURSES
 * <more of your startup stuff here>
 * promptload()
 * engineloop()
 *
 * the middle layer, or the guts, is where the engine actually happens, and
 *	it isn't pretty. if you want to change how the game works,
 *	it's going to get messy. this is where the functions for
 *	the RPG system itself, loading and saving, turns, shadows,
 *	3D rendering, and room changing are placed. these should not
 *	usually called directly by events, only by other builtin
 *	functions; some are only called by main.
 *
 * the backend consists of shims between generalized internal representations of
 *	a thing, and the actual way that a library or driver expects it to be
 *	formatted. the following are/will be considered part of this layer:
 *	- anything underneath a call to a parser
 *	- what goes on inside of the midi threads
 *	- the code underneath the savefile handling calls
 *
 * The API should always be backwards-compatable with all versions, from beta to doomsday.
 * The Guts may have breaking changes between MAJOR versions, but not otherwise.
 * The Backend depends on things beyond my control, and should be considered non-dependable.
 *	special cases should be noted, that the savefile format and language version have
 *	their own versioning system. this still may be broken if the flex-yacc or
 *	compression libraries of the build enviroment are changed from expectations,
 *	but is a good start.
 *
 * an extension language interpreter will be provided
 * for the API, implemented using flex/byacc; one might use the
 * Generic C Preprocessor or M4 to aid in writing stand-alone
 * plugins, but these are not built into the language itself
 * and are not avalible on the CLI as a result
 *
 * an runcontrol-file interpreter will be writen this way as well,
 * to be used by the new savefile generator. it will have syntax
 * inspired by .nethackrc
 *
 * lastly, a nonstructured language will be provided for defining midi streams
 * in a human readable format.
 *
 * At some point in the far future, once the engine has reached Beta,
 * a complementery Tileset version of the engine will be created using
 * the X Toolkit, XPixMap, and the Athena Widgets, while retaining the
 * mostly the same API.
 *
 * GPLv2 or later, All Wrongs Reserved
 */

/**standard libraries**/
#ifndef _XOPEN_SOURCE_EXTENDED
#define _XOPEN_SOURCE_EXTENDED
#endif
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#define SQRT3 1.732050807568877293528
#include <limits.h>
#include <time.h>
#include <string.h>
#include <ctype.h>
#include <uchar.h>
#include <dlfcn.h>

/**system libraries**/
#include <unistd.h>
#include <signal.h>
#include <locale.h>
//#include <regex.h>
//#include <glob.h>
//#include <sys/types.h>
//#include <sys/ioctl.h>
//#include <fcntl.h>
//#include <sys/stat.h>
//#include <errno.h>

/**compression libraries**/
#include <libtar.h>
#include <zlib.h>
#include <libbz2.h>

/**ncurses libraries**/
#include <ncursesw/ncurses.h>
//#include <menu.h>
/**curses libforms**/
//#include <forms.h>

// need to find a MIDI library.

#ifndef OK
#define OK 0
#endif

#ifndef ERR
#define ERR -1
#endif

#ifndef EOF
#error now you're just TRYING to break stuff...
#endif

#ifndef NULL
#warning ... ...wh ... ... how??
#define NULL ((void*)0)
#endif

#define TRUE true
#define FALSE false
#define T true
#define NIL ((intptr_t)0)	/*should be false and NULL equivilant, might be kept even if the others are purged*/

mvaddch16(int x,int y,char16_t raw) {
const wchar_t wch = raw;
mvaddnwstr(13,16,&wch,1);
}

addch16(char16_t raw) {
const wchar_t wch = raw;
addnwstr(&wch,1);
}

/* some output modes that will be used:
 *
 * using narrow characters with printw or addch
 * using wide characters with these functions
 * setting attributes with attrset, attron, attroff, and chgat
 *	uses A_DIM, A_BOLD, A_ITALIC, A_UNDERLINE, A_REVERSE, A_BLINK, A_INVIS,
 *	and 64 color pairs made from 8 colors
 * using the above custom functions to put wide characters on
 * the screen using addstr, addnstr, addwstr, addnwstr to print strings
 * pausing curses and dumping an entire file with printf
 */

/*ENVIROMENTALS*/
#define BUFFER_MAX 512
#define FLOPPYSIZE 1474560
#define DRUMSIZE 16384
#define BGCOLORS 8
#define FGCOLORS 8
char16_t TILDEWIDE
#define BLINKY "\033[5m_\033[25m"
char* TERM

/*VERSION*/
#define ENGINE_VERSION "Prealpha"
#define RULES_VERSION "Prealpha"
#define API_VERSION "Prealpha"
#ifndef SAVE_VERSION
#define SAVE_VERSION "MISSING"
#endif
#ifndef EXT_PARS_VERSION
#define EXT_PARSE_VERSION "MISSING"
#endif
#ifndef RUNCOM_VERSION
#define RUNCOM_VERSION "MISSING"
#endif
#ifndef MIDIBAS_VERSION
#define MIDIBAS_VERSION "MISSING"
#endif
#ifndef MIDI_TYPE
#define MIDI_TYPE "MISSING"
#endif

/*FUNCTION MACROS*/
#define BACKGROUND 010
#define MAX(A,B) (A > B ? A : B)
#define MIN(A,B) (A < B ? A : B)
#define INTERVAL(A,N,B) MIN(MAX(A,N),B)
#define COORDSUB(Z,Y,X) ((MAX_Y * Z) + (MAX_X * Y) + X)

// kludge so that stdio and ncurses play nice together
#define RESET "\033c\033[2J\033[0H"
#define BREAKCURSES clear();refresh();endwin();printf(RESET);fflush(stdout);
#define FIXCURSES printf(RESET);fflush(stdout);initialize();while (fgetc(stdin) != '\n');refresh;

// prettify the tokens my eyes don't parse
#define ≥ >=
#define ≤ <=
#define → ->
#define forever for (;;)
/* ɛ̩̍ will be used for "and", the conjunction, in comments where logical && would give a meaning that
 * could be validly, but incompatibly, interpreted as compleatly different from what is intended.
 * if confusion arises from or, similar mesures will be implemented for it, too.
 */

/*TYPES*/
//ensure size names work on all systems
#define uint unsigned int
#define sint signed int
#define uchar uint8_t
#define schar int8_t
#define ushort uint16_t
#define sshort int16_t
#define umint uint32_t
#define smint int32_t
#define ulong unsigned long
#define slong signed long
#define ullong uint64_t
#define sllong int64_t

/* the 3D version of Iwannafly started off as a general RT-RPG library that
 * then became narrowed to a specific game. this version was originally
 * supposed to be the same game reworked for ncurses,
 * but is now becoming closer to the general library concept,
 * similar to a RPG ruleset that allows creation of
 * your own setting and plot (you know the one).
 * a default one will be provided, however.
 */

//anonomous pointers, could be anything. they're anonomous.
struct drum {
	char data[DRUMSIZE]
	sshort top
	}

void* drumalloc (ptr,amount)
struct drum ptr
size_t amount
{
if ((ptr→top + amount) ≤ (DRUMSIZE)) {
	void* output = ptr→data[ptr→top]
	ptr→top += amount
	return output
	}
else {return NULL}
}

drumpop (ptr,amount)
struct drum ptr
size_t amount
{
ptr→top = MAX(ptr→top - amount,0)
}

setlocale(LC_ALL, "");

initialize() {
	initscr();
	cbreak();
	noecho();
	start_color();
	keypad(stdscr, true);
	}

for (uchar bg = 0; bg < BGCOLORS; bg++) {
	for (uchar fg = 0; fg < FGCOLORS; fg++) {
		init_pair((BACKGROUND * bg) + fg, fg, bg);
		}
	}

char16_t setwidetilde() {
forever {
	move(12,4); printw("is this tilde between the lines? (y,n)")
	
	mvaddch(14,14,"-")
	mvaddch(14,15,"-")
	mvaddch(14,16,"~")
	mvaddch(14,17,"-")
	mvaddch(14,18,"-")
	
	char got = getch()
	
	switch (got) : {
		case 'y' : return '~';
		case 'n' : return = 0x223C;
		default : printf("\a"); fflush(stdout); break;
		}
	}
}

/* backslash enters console mode. characters are fetched and printed
 * with ncurses, as well as stored in a temporary file.
 *
 * once the enter key is pressed, the temp file is rewound.
 * a flex-generated parser is used to process the tokens.
 *
 * interpretation mode will change depending on the syntax.
 * invalid commands may produce the response
 * "Don't know how to <command>", amoungst others.
 *
 * a command will be provided to dump objects.
 * text fields will show both their raw value and their text
 * value in the correct encoding. using this comand to get
 * out-of-character information is cheating, but no penalty
 * can be implemented, as it would effect it's functionality.
 *
 * The internal debugger may produce intentional segfaults,
 * which indicate a garbage pointer was dereferenced
 * these should be called "dead canaries" in bugreports.
 * these are useful in tracking down the most illusive of
 * heisenbugs, as even if they cannot be directly observed,
 * their modus operandi can be determined.
 *
 * only a number of expected variables may be dumped this way;
 * true debugging should use GDB.
 */

enum cli_argstypes
/* used to specify the type of the buffer that tokens are
 * parsed into. types can be:
 *
 * argstype_wish (*heldobjtyp) (*heldobjtyp)[2] (*heldobjtyp)[4]
 * argstyp_ent symtabref argstyp_equip equipenum
 *
 * container types will also allocate suitable contents
 * once objid has been resolved
 */

typedef cli_func *int(*void)

enum commandenum
cli_func commandtable[256]
cli_argstypes commandargs[256]

struct argstyp_wish {
uchar stack
objid type
void* data
}

struct argstyp_ent {
bool shift
uchar race
bool stoned
}

struct argstyp_equip {
equipenum slot
heldobjtyp* item
}

struct stringlistyp {
(self) *prev
(self) *next
char* text
}
/* used to store a list of strings
 * may be from a data object, or
 * stored in a tsv
 */

struct filelinetyp {
(self) *prev
(self) *next
ushort lineno
char* text
}
// used by the line editor

struct eventstringtyp {
(self) *prev
(self) *next
eventdata eventident
char* text
}
// like stringlistyp, but also has a field for eventident

/* typedef struct Rune {
 * umint sym : 24;
 * bool bold : 1;
 * bool italic : 1;
 * bool under : 1;
 * bool strike : 1;
 * bool over : 1;
 * bool reverse : 1;
 * bool blink : 1;
 * bool invis : 1;
 * } Rune; //not needed
 */

uint util__roll (num,side,low)
uchar num;	//number of dice to roll
uchar side;	//sides on each die
bool low;	//low number on each die
{
uint accum;
uint tmp;
for (uchar n = 0;n<num;n++) {
	tmp = (rand() % side) + low;
	accum += tmp;
	}
return accum;
}
//XdN is (X,N,0), XDN is (X,N,1)

sshort util__bonus (num)
uchar num;
{
sshort accum;
schar tmp;
for (uchar n = 0;n<num;n++) {
	tmp = (rand() % 3) - 1;
	accum += tmp;
	}
return accum;
}

#define util__flip (rand() % 2)

#define MISSING_FILE(F) fprintf(stderr,"File \"%s\" not found",F); move(22,2); attrset(COLOR_PAIR((BACKGROUND*COLOR_RED)+COLOR_WHITE); printw("File Error : \"%s\"",F); attroff(COLOR_PAIR((BACKGROUND*COLOR_RED)+COLOR_WHITE);

/*implicit*/file_cat (path)
const char *path;
{
FILE *openfile = fopen(path,"r");
int lines;
if (openfile == NULL) {
	MISSING_FILE(path);
	ERROR_GRAPHIC("File not found",0,0,0,0,false);
	return ERR;
	}
char tmpbuffer[BUFFER_MAX];
BREAKCURSES
for (bool n = true;n;noop()) {
	if (fgets(tmpbuffer,BUFFER_MAX,openfile) == NULL) {
		n = false;
		} else {
		printf(tmpbuffer);fflush(stdout);
		lines++;
		}
	}
FIXCURSES
fclose(openfile);
return lines;
}

/*implicit*/file_cat_nocurses (path)
const char *path;
{
FILE *openfile = fopen(path,"r");
int lines;
if (openfile == NULL) {
	MISSING_FILE(path);
	ERROR_GRAPHIC("File not found",0,0,0,0,false);
	return ERR;
	}
char tmpbuffer[BUFFER_MAX];
for (bool n = true;n;noop()) {
	if (fgets(tmpbuffer,BUFFER_MAX,openfile) == NULL) {
		n = false;
		} else {
		printf(tmpbuffer);fflush(stdout);
		lines++;
		}
	}
fclose(openfile);
return lines;
}


/* should also output __FILE__ ɛ̩̍ __LINE__, which will likely be the program's version of
 * undecipherable hex codes to anyone not extreamly fammiliar with the source. less severe
 * errors will prompt for [Q]uit, [A]bort, or [Z] continue. more severe ones will prompt
 * [Q]uit, [A]bort, [Z] restart. When other keyboard layout options are supported, QAZ will
 * be replaced with the left column of letters (under 1). replacements for QAZ might be:
 * QAY, AQW, "A:, FUJ. if Q or A are present in this group, they will be [Q]uit ɛ̩̍ [A]bort,
 * swapping places with the other option. otherwise, the quit-abort-option3 order will be kept.
 */
ERROR_GRAPHIC(string,sign1,num1,sign2,num2,hard)
char* string
char sign1 sign2
intptr_t num1 num2
bool hard
{
char* opt3
if (hard) {
	attrset(COLOR_PAIR((BACKGROUND*COLOR_YELLOW)+COLOR_RED)
	opt3 = "Restart"
	}
else {
	attrset(COLOR_PAIR(BACKGROUND*COLOR_YELLOW)
	opt3 = "Continue"
	}

move(0,0); printw("*┐  Error!")
move(1,0); printw("▗█▖  \"%s\"",string)
switch sign1 : {
case 'u' : {move(2,0); printw("███ N1 = %u",num1);break;}
case 'i' : {move(2,0); printw("███ N1 = %+i",num1);break;}
case 'p' : {move(2,0); printw("███ N1 = %p",num1);break;}
case 'X' : {move(2,0); printw("███ N1 = $%08X",num1);break;}
default : {move( 2,0); printw("███");break;}
}
switch sign2 : {
case 'u' : {move(3,0); printw("▝█▘ N2 = %u",num2);break;}
case 'i' : {move(3,0); printw("▝█▘ N2 = %+i",num2);break;}
case 'p' : {move(3,0); printw("▝█▘ N2 = %p",num2));break;}
case 'X' : {move(3,0); printw("▝█▘ N2 = $%08X",num2);break;}
default : {move( 3,0); printw("▝█▘");break;}
}
move( 5,0); printw("File: %s",__FILE__)
move( 6,0); printw("Line: %i",__LINE__)

move( 8,0); printw("[Q]uit?")
move( 9,0); printw(" [A]bort?")
move(10,0); printw("  [Z] %s?",opt3)

/* keytrap stuff here
 * if hard, SIGTRAP
 */
}

/*GLOBALS*/
#define GRAV 3.2174	/*if you backtrack this to determine the size of a grid unit, you're trying to hard*/
playertyp PLAYER
coord3 PLAYERSHD	//position of player's shadow, for renderer
latlontyp WORLD
roomtyp* ROOM
#define MAX_X 64
#define MAX_Y 24	//MAX_X ≥ MAX_Y ≥ MAX_Z
#define MAX_Z 16
#define CEILING ROOM→ceiling
#define ROOF 201	//it is decreed: mortals shall fly no higher. (this means you!)
#define EQUATOR 360	//the number of rooms in the circumfrence of the sphere
int(latlontyp)* ROOMGENCALL[ROOF + 1][EQUATOR/2 + 1][EQUATOR]
shadowmask SHADOWKNOWS
shadowmask SHINEALIGHT
ullong TURN
nibbles TIMER
schar ALARM = -1
turntyp DATE
uchar ROOMTURN
ullong KILLS
char* SAVEPATH
followtype *FOLLOW_ptr	//pursuers, i.e. paid assasins, ninjas, the reaper...
eventtyp *EVNT_ptr	//FOO_ptr refers to the doubly linked list's head. the tail is FOO_ptr→prev
placetyp *PLACE_ptr
stringlistyp *HINT_ptr
eventstringtyp *HEYLISTEN_ptr
eventdatobj* EVENTDATA_ptr
bitfield globools
#define NEW globools.a
#define FIRST globools.b
#define DAY globools.c
#define NIGHT globools.d
#define MORN globools.w
#define NOON globools.x
#define EVE globools.y
#define MIDNIT globools.z

/* buffered room loading for future implementation:
 * roomtyp* ROOMARRAY[3][3][3]
 * #define ROOM ROOMARRAY[1][1][1]
 * #define ROOM_NORTH ROOMARRAY[1][0][1]
 * #define ROOM_NE ROOMARRAY[1][0][2])
 * #define ROOM_EAST ROOMARRAY[1][1][2]
 * #define ROOM_SE ROOMARRAY[1][2][2]
 * #define ROOM_SOUTH ROOMARRAY[1][2][1]
 * #define ROOM_SW ROOMARRAY[1][2][0]
 * #define ROOM_WEST ROOMARRAY[1][1][0]
 * #define ROOM_NW ROOMARRAY[1][0][0]
 * #define ROOM_UP ROOMARRAY[0][1][1]
 * #define ROOM_UP_NORTH ROOMARRAY[0][0][1]
 * #define ROOM_UP_NE ROOMARRAY[0][0][2]
 * #define ROOM_UP_EAST ROOMARRAY[0][1][2]
 * #define ROOM_UP_SE ROOMARRAY[0][2][2]
 * #define ROOM_UP_SOUTH ROOMARRAY[0][2][1]
 * #define ROOM_UP_SW ROOMARRAY[0][2][0]
 * #define ROOM_UP_WEST ROOMARRAY[0][1][0]
 * #define ROOM_UP_NW ROOMARRAY[0][0][0]
 * #define ROOM_DOWN ROOMARRAY[2][1][1]
 * #define ROOM_DOWN_NORTH ROOMARRAY[2][0][1]
 * #define ROOM_DOWN_NE ROOMARRAY[2][0][2]
 * #define ROOM_DOWN_EAST ROOMARRAY[2][1][2]
 * #define ROOM_DOWN_SE ROOMARRAY[2][2][2]
 * #define ROOM_DOWN_SOUTH ROOMARRAY[2][2][1]
 * #define ROOM_DOWN_SW ROOMARRAY[2][2][0]
 * #define ROOM_DOWN_WEST ROOMARRAY[2][1][0]
 * #define ROOM_DOWN_NW ROOMARRAY[2][0][0]
 * 
 * masks to select rooms
 * #define UP_ROOMS_MASK ((umint) 0xFF400000)
 * #define DOWN_ROOMS_MASK ((umint) 0x000002FF)
 * #define NORTH_ROOMS_MASK ((umint) 0xC10C10C1)
 * #define SOUTH_ROOMS_MASK ((umint) 0x1C01C01C)
 * #define EAST_ROOMS_MASK ((umint) 0x70070070)
 * #define WEST_ROOMS_MASK ((umint) 0x07007007)
 * #define ALL_ROOMS_MASK ((umint) 0xFF4FF2FF)
 * 
 * #define ROOM_NORTH_MASKBIT ((umint) 0x00080000)
 * #define ROOM_NE_MASKBIT ((umint) 0x00040000)
 * #define ROOM_EAST_MASKBIT ((umint) 0x00020000)
 * #define ROOM_SE_MASKBIT ((umint) 0x00010000)
 * #define ROOM_SOUTH_MASKBIT ((umint) 0x00008000)
 * #define ROOM_SW_MASKBIT ((umint) 0x00004000)
 * #define ROOM_WEST_MASKBIT ((umint) 0x00002000)
 * #define ROOM_NW_MASKBIT ((umint) 0x00001000)
 * #define ROOM_UP_MASKBIT ((umint) 0x00400000)
 * #define ROOM_UP_NORTH_MASKBIT ((umint) 0x80000000)
 * #define ROOM_UP_NE_MASKBIT ((umint) 0x40000000)
 * #define ROOM_UP_EAST_MASKBIT ((umint) 0x20000000)
 * #define ROOM_UP_SE_MASKBIT ((umint) 0x10000000)
 * #define ROOM_UP_SOUTH_MASKBIT ((umint) 0x08000000)
 * #define ROOM_UP_SW_MASKBIT ((umint) 0x04000000)
 * #define ROOM_UP_WEST_MASKBIT ((umint) 0x02000000)
 * #define ROOM_UP_NW_MASKBIT ((umint) 0x01000000)
 * #define ROOM_DOWN_MASKBIT ((umint) 0x00000200)
 * #define ROOM_DOWN_NORTH_MASKBIT ((umint) 0x00000080)
 * #define ROOM_DOWN_NE_MASKBIT ((umint) 0x00000040)
 * #define ROOM_DOWN_EAST_MASKBIT ((umint) 0x00000020)
 * #define ROOM_DOWN_SE_MASKBIT ((umint) 0x00000010)
 * #define ROOM_DOWN_SOUTH_MASKBIT ((umint) 0x00000008)
 * #define ROOM_DOWN_SW_MASKBIT ((umint) 0x00000004)
 * #define ROOM_DOWN_WEST_MASKBIT ((umint) 0x00000002)
 * #define ROOM_DOWN_NW_MASKBIT ((umint) 0x00000001)
 */

#define GOOD_MASK 0700
#define LAWFUL_MASK 0444
#define EVIL_MASK 0007
#define CHAOTIC_MASK 0111

#define NEUT_HORIZ_MASK 0070
#define NEUT_VERT_MASK 0222

#define LAW_GOOD_BIT 0400
#define NEUT_GOOD_BIT 0200
#define CHAOS_GOOD_BIT 0100
#define LAW_NEUT_BIT 0040
#define TRUE_NEUT_BIT 0020
#define CHAOS_NEUT_BIT 0010
#define LAW_EVIL_BIT 0004
#define NEUT_EVIL_BIT 0002
#define CHAOS_EVIL_BIT 0001

#define LAW_GOOD_WIDEMSK 0764
#define CHAOS_GOOD_WIDEMSK 0731
#define LAW_EVIL_WIDEMSK 0467
#define CHAOS_EVIL_WIDEMSK 0137
#define NEUTRAL_WIDEMSK 0272

#define ELE_WATER_BIT 0x80
#define ELE_ICE_BIT 0x40
#define ELE_AIR_BIT 0x20
#define ELE_ELEC_BIT 0x10
#define ELE_FIRE_BIT 0x08
#define ELE_METAL_BIT 0x04
#define ELE_EARTH_BIT 0x02
#define ELE_TREE_BIT 0x01

#define ELE_WATER_WIDEMSK 0xC1
#define ELE_ICE_WIDEMSK 0xE0
#define ELE_AIR_WIDEMSK 0x70
#define ELE_ELEC_WIDEMSK 0x38
#define ELE_FIRE_WIDEMSK 0x1C
#define ELE_METAL_WIDEMSK 0x0C
#define ELE_EARTH_WIDEMSK 0x07
#define ELE_TREE_WIDEMSK 0x83

#define LIGHT_BIT 04
#define DARK_BIT 02
#define ENTROPY_BIT 01

/*end GLOBALS*/

getlinebuffer (y,x)
uchar y x
{
char* LINEBUFFER = calloc(BUFFER_MAX,sizeof(char))
move(y,x)
int ch
forever {
	ch = getch();
	if ((ch > UCHAR_MAX) || (ch < 0)) {
		switch ch : {
			case KEY_ENTER : move(y,x); fputc('\n',LINEBUFFER); rewind(LINEBUFFER); return 0;
			case KEY_BACKSPACE : move(y,x); rewind(LINEBUFFER); return 4;
			case KEY_HOME : move(y,x); rewind(LINEBUFFER); break;
			case KEY_LEFT : move(y,x); rewind(LINEBUFFER); break;
			case KEY_SLEFT : move(y,x); rewind(LINEBUFFER); break;
			default : break;
			} break;
		}
	else if (ch < ' ') {
		switch ch : {
			case 0x17 : move(y,x); rewind(LINEBUFFER); return 4;
			case '\n' : move(y,x); fputc('\n',LINEBUFFER); rewind(LINEBUFFER); return 0;
			case '\b' : move(y,x); rewind(LINEBUFFER); return 4;
			default: break;
			}
		}
	else {
		fputc(ch,LINEBUFFER);
		printw(ch);
		}
	}
free(LINEBUFFER)
}

umint getsixteen (y,x)
uchar y x
{
char hexbuffer[8] = "00000000"
move(y,x-5);printw("[    -    ]");
int ch
uchar subscript = 0
schar offset = subscript < 4 ? subscript-4 : subscript-3
bool exiterr
forever {
	ch = getch();
	if ((ch > UCHAR_MAX) || (ch < 0)) {
		switch ch : {
			case KEY_ENTER : goto(fin);
			case KEY_BACKSPACE : subscript = INTERVAL(0,subscript-1,7); offset = subscript < 4 ? subscript-4 : subscript-3; break;
			case KEY_LEFT : subscript = INTERVAL(0,subscript-1,7); offset = subscript < 4 ? subscript-4 : subscript-3; break;
			case KEY_RIGHT : subscript = INTERVAL(0,subscript+1,7); offset = subscript < 4 ? subscript-4 : subscript-3; break;
			case KEY_HOME : subscript = 0; offset = subscript < 4 ? subscript-4 : subscript-3; break;
			case KEY_SLEFT : subscript = 0; offset = subscript < 4 ? subscript-4 : subscript-3; break;
			case KEY_HOME : subscript = 7; offset = subscript < 4 ? subscript-4 : subscript-3; break;
			case KEY_SRIGHT : subscript = 7; offset = subscript < 4 ? subscript-4 : subscript-3; break;
			default : break;
			} break;
		}
	else {
		switch ch : {
			case '\n' : goto(fin);
			case '\b' : subscript = INTERVAL(0,subscript-1,7); offset = subscript < 4 ? subscript-4 : subscript-3; break;
			case ' ' : subscript = INTERVAL(0,subscript+1,7); offset = subscript < 4 ? subscript-4 : subscript-3; break;
			default: if (isxdigit(ch)) {hexbuffer[subscript] = ch; printw(ch);}; subscript = INTERVAL(0,subscript+1,7); offset = subscript < 4 ? subscript-4 : subscript-3; break;
			}
		}
	move(y,x+offset);
	}
fin:
return (umint) strtoul(hexbuffer,NULL,16);
}

struct turntyp:
uchar sec : 6
uchar min : 6
uchar hour : 5
uchar day : 5
uchar weekday : 3
uchar month : 4
ushort year : 11

bool ticktock() {
TURN++;
TIMER.lo++;
if ((TIMER.lo == TIMER.hi) && (ALARM ≥ 0)) {ALARM++}
if (ROOMTURN < 200) {ROOMTURN++;}
DATE.sec += 6;
if (DATE.sec ≥ 60) {
	DATE.sec = 0;
	DATE.min++;
	if (DATE.min ≥ 60) {
		DATE.min = 0;
		DATE.hour++;
		if (DATE.hour ≥ 24) {
			DATE.hour = 0;
			DATE.weekday++
			if (DATE.weekday ≥ 7) {DATE.weekday = 0;}
			DATE.day++;
			if (DATE.day ≥ 30) {
				DATE.day = 0;
				DATE.month++;
				if (DATE.month ≥ 12) {
					DATE.month = 0;
					DATE.year++;
				}
			}
		}
	}

MIDNIT = ((DATE.hour == 0) && !(DATE.min))
MORN = ((DATE.hour == 6) && !(DATE.min))
NOON = ((DATE.hour == 12) && !(DATE.min))
EVE = ((DATE.hour == 18) && !(DATE.min))
DAY = ((6 ≤ DATE.hour) && (DATE.hour < 18))
NIGHT = ((DATE.hour < 6) || (18 ≤ DATE.hour))
}

//cartesian projection, →x ↓y ↑z (+y=-z)

struct coord3:
uchar x
uchar y
uchar z

struct coord2:
uchar x
uchar y

struct scoord3:
schar x
schar y
schar z

struct scoord2:
schar x
schar y

struct mapcoord3:
uchar x : 6
uchar y : 5
uchar z : 4
bool w : 1

struct nibbles {
uchar lo : 4
uchar hi : 4
}

struct vector2:
float x
float y

struct vector3:
float x
float y
float z
/* used for velocity, a parameter that holds
 * motion that carries accross turns. this motion
 * is not always cleared after being done; horizontal
 * velocity persists until a tile with friction is
 * encountered, while downwards vertical velocity 
 * accumulates and persists until the ground is encountered.
 */

struct polar {
uchar az : 3	//azimuth
schar el : 2	//elevation
schar slope : 3	//negative is inverse slope, most negative is undefined. defines a cone.
uchar r : 5	//radius
bool omni : 1	//omnidirectional
bool not : 1	//invert the mask defined by slope
bool behind : 1	//EQUATOR/2 degrees are added to azimuth
}
/* amoungst other uses, defines the cone of vision
 * and used to generate magic beams
 *
 * for all azimuths:
 *
 * 701
 * 6 2
 * 543
 *
 * for all elevations:
 *
 * +1
 *  0  ?-2?
 * -1
 */

notetyp {
(self) next
uchar evnt : 4
uchar chan : 4
uchar note : 8
uchar velo : 8
clock_t delay
}
/* for interfacing with a raw midi library
 *
 * delay is not part of the midi data, rather,
 * it tells how long to wait until sending the
 * next packet. set to 0 to send immidiately.
 */

blittyp {
(self) next
uchar x : 7
uchar y : 5
uchar fg : 3
uchar bg : 3
bool dim
bool bold
bool italic
bool under
bool reverse
bool blink
clock_t delay
}

struct setcoord3:
(self) *prev
(self) *next
uchar x
uchar y
uchar z

//some specific use cases require spheres. these are simply numeric types.

struct diceodds:
uchar num : 3
uchar side : 5
uchar tobeat : 8

struct latlontyp {
uchar dep : 8	//0 ≤ dep ≤ 201
schar lat : 8	//-90 ≤ lat ≤ 90
sshort lon : 9	//-180 ≤ lon < 179
bool shift : 1	//are you plane shifted?
bool moon : 1	//are you on the moon?
uchar az : 3	//azimuth on a plane chart
schar el : 2
}
/* in-game altitude is given as the distance from layer 100
 *
 * when combined with shift, moon becomes outer planes
 *
 * az	elemental	afterlife	corrilation
 * 0	water		neutral good	nurturer
 * 1	ice		chaotic good	the ends justify the means
 * 2	air		chaotic neutral	princess stealing
 * 3	electricity	chaotic evil	force lightning
 * 4	fire		neutral evil	obviously
 * 5	metal		lawful evil	greed
 * 6	earth		lawful neutral	stubborn
 * 7	trees		lawful good	knowladge
 *
 * az rotates by 45 degree steps and el by 90 degree steps.
 * a nonzero el causes az to gimbal lock.
 * also best not to think about where exactly -2 is pointing.
 *
 * el	"		"		"
 * +1	light		true neutral	enlightenment
 * -1	darkness	uncomitted	meh, I'll think of one later
 * -2	entropy		oathbreakers	abandon all hope ye who enter here
 *
 * errors related to this section may generate one of 2 errors:
 * "fell off the edge of the world", N1=±lat,N2=±lon
 * "froze to death on pluto", N1=+az,N2=±el
 */

struct placetyp {
(self) *prev
(self) *next
eventdata eventident	//7FFF is removeable
char* name
latlontyp latlon
coord3 pos
}

struct cylinder:
uchar r : 7
uchar norm : 2
uchar h : 4
bool up : 1
bool down : 1
bool show : 1
 /* cylinders, (the shape, not this datatype) are used extensively.
  * players move in cylindrical coordinate space.
  * event areas are specified as cylinders
  * monster aggro ranges are a cylinder
  */

struct moneytyp {
ushort gp : 17
uchar cp : 7
}

#define GOLDMAX = 130999
#define COPPERMAX = 99

struct aligntyp:
good : b1
evil : b1
law : b1
chaos : b1
nogood : b1
noevil : b1
nolaw : b1
nochaos : b1
/* used as a mask.
 * starting alignment must be one of the high nibble (those bit flags | true neutral if more than 1 is selected.)
 * alignment may NEVER enter any of the low nibble, marked "no"
 *
 * there are other ways that alignment masks may be specified,
 * all of which have finer grained control.
 */

struct bitfield:
a : 1
b : 1
c : 1
d : 1
w : 1
x : 1
y : 1
z : 1

typedef char* stabs[256] //symbol table strings
typedef uchar symtabref //beware of missingno glitches!

enum item_enum
enum spell_enum
enum weap_enum
enum arm_enum
enum shld_enum
enum baub_enum
stabs itemstabs //stuff that doesn't go anywhere else; i.e. arrows, keys, quest items
stabs spellstabs //spells
stabs weapstabs //weapons
stabs armstabs //armor
stabs shldstabs //shield, cannon, greeves
stabs baubstabs //rings, amulets, bracelets, tiaras
miscitembasetyp* itemtable[256]
basespelltyp* spelltable[256]
baseweaptyp* weaptable[256]
basearmortyp* armtable[256]
baseshldtyp* shldtable[256]
baubtyp* baubtable[256]

char* legendstabs[20] = {"truthseeker","sword of justice","excalibur","thunderbolt"/*torch of smiting*/,"sickle of chaos"/*+drain*/,"stormbringer"/*+drain*/,"devilfork"/*+fire*/,"partisen of tyrants","deathscyth"/*+drain*/,"sunray"/*spear + solar flare*/,"nightedge"/*sword + moonbeam*/,"staff of merlin"/*staff of magic missile*/,"firebrand"/*sword + fireball*/,"tesla's mace"/*+spark*/,"stormgale"/*bow*/,"frostpike"/*+frostbite*/,"trident of the seas"/*+tsunami*/,"staff of the forest"/*staff of animante kudzu*/,"groundshaker"/*+earthquake*/,"imperial baton"/*staff of antagonizing*/}
legendtyp legendtable[20]

char* psystabs[8] = {"detect alignment","charm","hold","sleep","mind blast","passify","unhinge","terrify"}

/*blackbox*/psionic(id)
uchar id
//switch case for each psionic ability

typedef multiclasstyp:
(self) *prev
(self) *next
classtyp class

typedef classobjtyp:
classtyp class
magictyp element

typedef classtyp {
uchar role : 2
uchar class : 3
ushort align : 9
bool charismatic : 1
bool scorned : 1

char* roguestabs[8] = {"changeling","rogue","thief","pirate","ninja","assasin","tourist","ronan"}
char* fighterstabs[8] = {"fighter","knight","paladin","valkyrie","viking","samuri","ranger","monk"}
char* magicuserstabs[8] = {"magic-user","wizard","illusionist","enchanter","black mage","red mage","psion","necromancer"}
char* healerstabs[8] = {"healer","cleric","priest","druid","alchemist","scholar","white mage","seer"}

paffect	classtable[4][8]

enum mon1_enum
stabs mon1stabs =
{"human",	"elf",		"dwarf",	"gnome",	"hobbit",	"half elf",	"drow",		/*avian*/,	"half orc",	"half dragon",	/*half celestial*/,	"tiefling",	"half air elemental",		"half water elemental",	"half earth elemental",		"half fire elemental",
"merfolk",	"seaelf",	"satyr",	"fairy",	"pixie",	"naiad",	"naga",		"dryad",	"orc",		"kobald",	"centaur",		"sphinx",	"half electric elemental",	"half ice elemental",	"half nature elemental",	"half metal elemental",
...};

ptrtab mon1table
/* contains all polymorphable monsters, of type BASENTYPE.
 * all C0 controls should be valid starting races, or left empty,
 * any polymorphable race can BECOME your base race...
 * 
 * if you become polylocked to a non-player race, your class will be removed.
 * becoming polylocked to one of the C0 entrys has no negative effects.
 * commands can change your base race without negative side effects
 *
 * polymorph autocomplete is implemented using switches.
 *
 * entities can only be polymorphed into things in their own table.
 * this is due to a software limitation that will not be fixed,
 * as it enables species to easily be sorted into polymorphable
 * and non polymorphable by placing them on the low or high tables
 */
enum mon2_enum
stabs mon2stabs = {"grue",	...
/*$FA*/,	"Justice"/*not invincible*/,	"Retribution"/*not invincible*/,	"Justice"/*invincible*/,	"Retribution"/*invincible*/,	"Death"};
ptrtab mon2table

/* MONSTERS BY LETTER
 * &: horned devil, balrog, pit feind, imp, homunculus, jubilix, drider
 * @: human, elf, half elf, drow, seaelf
 * A: astral, ætherial, celestial, archon
 * a: newt, salamander, frog, 
 * B: bear, polar bear, bugbear, owlbear,
 * b: mockingbird, parakeet, parrot, macaw, cockatoo, songbird, sparrow, starling,
 * C: satyr, centaur,
 * c: raven, rook, jackdaw, crow, jay, magpie,
 * D: wyrm, great wyrm, (△red,↯copper,◬white,*cyan,▽blue,♠green,⍫brown,$gold,☽black,☼silver,∅purple) dragon, hydra,
 * d: hellhound, wolf, dire wolf, dog, fox, cyote,
 * E: <elementals>, stalker,
 * e: floating eye,
 * F: turkey, rooster, chicken, peacock, duck, goose, swan, albatross, gull, dodo,
 * f: panther, lion, tiger, manticore, cat, lynx, bobcat,
 * G: ghost, banshee, revenent, barrow wight,
 * g: gremlin, gargoyle, winged gargoyle,
 * H: giant, cyclops,
 * h: dwarf, gnome, hobbit,
 * I: giant ant, giant roach, giant scarab, giant wasp, giant scorpion, giant spider,
 * i: ant, roach, scarab, wasp, scorpion, spider, firefly
 * J: djinn,
 * j: lichen, yellow mold, green mold, black mold, gelatinous cube, green slime, brown pudding, black pudding, ocher jelly, spotted jelly, blue jelly,
 * K: chickatrice, cockatrice, pyrolisk,
 * k: kobold,
 * L: skeleton, lich,
 * l: leprachaun,
 * M: gorgon,
 * m: <mummies>
 * N: naga,
 * n: merfolk, naiad, dryad,
 * O: orc, half orc, uruk-hai, ogre,
 * o: ostrich, emu, moa,
 * P: fairy, pixie,
 * p: dolphin, narwhal, orca, beluga,
 * Q: elephant, mammoth, rhino,
 * q: cow, pig, buffalo,
 * R: eagle, falcon, owl, kite, vulture, phoenix,
 * r: rat, dire rat, raccoon, platypus,
 * S: cracken, shark, octopus, giant squid,
 * s: copperhead, cobra, rattlesnake, python,
 * T: lurker above, trapper, wallmaster, rust monster,
 * t: troll,
 * U: umber hulk,
 * u: unicorn, pegasus, griphon, hippogriph,
 * V: vampire, wolfman,
 * v: bat,
 * W: half dragon, half celestial, tiefling, avian, erinys, harpy, tengu,
 * w: purple worm, nightcrawler,
 * X: velociraptor, tyrannasaurus,
 * x: monitor, alligator, crocodile, skink,
 * Y: yeti, bigfoot,
 * y: ape, monkey, gorilla,
 * Z: mind flayer,
 * z: <zombies>
 * {: (flesh, straw, clay, stone, glass, paper, leather) golem, (gold, copper) automaton, hungry chest, chest monster,
 * £: justice. (has Beethoven's 5th as a lietmotif. is lawful.)
 * ¶: da fuzz. (are lawful.)
 * ⑄: retribution. (has Summer - Presto as a lietmotif. is chaotic.)
 * ∈: <half elementals>
 * ∞: grue.
 * ☠: death. (has Toccata and Fugue in D minor as a lietmotif. is true neutral.)
 * ♞: quarterhorse, draft horse, miniature horse, zebra, nightmare,
 * ⏍: hungry chest, chest monster,
 */

struct the8stats:	//8* 5D6
stren : 5
psy : 5
dex : 5
con : 5
fort : 5
intl : 5
wis : 5
bluff : 5

struct conlangtype:
symtabref id : 5
bool r : 1
bool w : 1
bool x : 1	//can be spoken

char* conlangtab[32] = {"common language","middle elvish","old elvish","dwarvish", "gnomish","gothic","orkish","draconic", "fey","celestic","demonic","blackspeech", "skyspeak","waterspeak","earthspeak","firespeak",
	"thieves cant",/*?*/,/*?*/,/*?*/, /*?*/,/*?*/,/*?*/,/*?*/, /*?*/,/*?*/,/*?*/,/*?*/, "electric","icespeak","treespeak","metallic"}

struct playertyp:
classobjtyp class
multiclasstyp *MULTICLASS
symtabref baserace
symtabref polyrace
shiftertyp polycounter
coord3 loc
polar facing
vector3 velo
float carryover	//leftover moves; never exceeds 2
paffectyp permenent
effectyp fromequip
scoord2 align
ushort hp	//they're fun and easy to...wait
ushort mp
uchar air
ushort uptime
umint xp
uchar lvl
sshort food
moneytyp gold
heldobjtyp *lang_ptr
heldobjtyp *spell_ptr
heldobjtyp *bag_ptr
bitfield psyattack
subobjtyp weap_left	//weapon
subobjtyp weap_right	//weapon
subobjtyp shield	//shld
subobjtyp bow	//weapon
subobjtyp armor	//armor
subobjtyp cape	//armor
oneobjtyp helm	//any item
subobjtyp gloves	//armor
subobjtyp cannon	//shld
subobjtyp boots	//armor
subobjtyp greev	//shld
subobjtyp amul	//baub
subobjtyp ringl	//baub
subobjtyp ringr	//baub
subobjtyp wristl	//baub
subobjtyp wristr	//baub

enum equipenum = {ENUM_WEAP_LEFT,ENUM_WEAP_RIGHT,ENUM_SHIELD_ENUM_BOW,ENUM_ARMOR,ENUM_CAPE,ENUM_HELM,
ENUM_GLOVES,ENUM_CANNON,ENUM_BOOTS,ENUM_GREEV,ENUM_AMUL,ENUM_RING_LEFT,ENUM_RING_RIGHT,ENUM_WRIST_LEFT,
ENUM_WRIST_RIGHT}

/*blackbox*/update_player
/* resets .fromequip , then iterates through the entire equipment list to regenerate it.
 * must be called every time equipment is changed to ensure that it is up to date
 * effects in .permenent can only be removed by finding something that affects the opposite change
 * changes to your starting alignment or role are generally rare and disasterous, as they represent
 * the corruption of the character in some way. changes to your race may also be inconvenient,
 * but not necissarily bad. (I.E. late game events may change a player into a powerful
 * non-starting race as part of the story, such as a drider, full elemental, or dragon.)
 *
 * this may be done automatically when you sleep.
 */

/*blackbox*/inventsort
/* compresses stackable items into stacks, sorts items by objid and itemid.
 * more computationally expensive than update_player.
 */

/*blackbox*/force_global
/* forces some queued globals to be loaded. takes a very long time, but can
 * sometimes be necissary if the global buffer is bogged down.

int itemswap (item1,item2)
heldobjtyp *item1
heldobjtyp *item2
{
heldobjtyp *prev1 = item1→prev
heldobjtyp *prev2 = item2→prev
heldobjtyp *next1 = item1→next
heldobjtyp *next2 = item2→next
if (item1→next = item2) {
	prev1→next = item2
	item2→prev = prev1

	item2→next = item1
	item1→prev = item2

	next2→prev = item1
	item1→next = next2
	}
if (item2→next = item1) {
	prev2→next = item1
	item1→prev = prev2

	item1→next = item2
	item2→prev = item1

	next1→prev = item2
	item2→next = next1
	}
else {
	prev1→next = item2
	item2→prev = prev1

	next1→prev = item2
	item2→next = next1

	prev2→next = item1
	item1→prev = prev2

	next2→prev = item1
	item1→next = next2
	}
}

struct basentyp:
aligntyp alignmask
aggrotyp aggro	//here, shiftable denotes a monster's aggro state is locked. also gives the value that patience is set to when a monster calms down, the value that cooldown is set to when it is angered, and the default AI.
paffectyp base
venomtyp venom
uchar spd	//distance calculations use M_SQRT2 for diagonals
uchar hplvl
uchar mplvl
uchar xplvl
uchar airmax	//how long you can hold your breath
symtabref lang0 : 6
symtabref lang1 : 6
uchar vocal[4]
symtabref spell0
symtabref spell1
symtabref spell2
symtabref spell3
bitfield psyattack
char16_t unichar
bool unaligned : 1
bool keepindark : 1
bool mindless : 1
bool incoporeal : 1
schar size : 2
uchar color : 6
/* entitys of size 1 or -2 cannot use armor.
 * entitys of larger size automaticly win grapples.
 * entitys of 2 sizes smaller can be picked up and thrown.
 * entitys of size 1 can instakill entitys of size -2. squish.
 * size 1: dragon, size 0: human, size -1: dwarf, size -2: pixie
 */

struct aggrotyp:
bool shiftable : 1	//nowhere else to put it.
uchar patience : 3
uchar ai_type : 4
uchar anger : 7
bool unhinged : 1

struct enttyp:
(self) *prev
(self) *next
char* name
classobjtyp class
aggrotyp aggro
symtabref race
coord3 loc
polar facing
vector3 velo
float carryover
paffectyp paffect
effectyp effect
ushort hp
uchar air
ushort xp
uchar lvl
moneytyp gold
oneobjtyp loot
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
oneobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct npctyp:
(self) *prev
(self) *next
char* name
eventdata eventident
classobjtyp class
setcoord3* path
symtabref race
coord3 loc
polar facing
conlangtyp lang
char* lines
char* gibber

struct followtyp:
(self) *prev
(self) *next
char* name
eventdata eventident
classobjtyp class
aggrotyp aggro
symtabref baserace
symtabref polyrace
shiftertyp polycounter
coord3 loc
polar facing
vector3 velo
float carryover
paffectyp permenent
effectyp fromequip
scoord2 align
ushort hp
ushort mp
uchar air
umint xp
uchar lvl
sshort food
moneytyp gold
heldobjtyp *spell_ptr
bitfield psyattack
oneobjtyp holding
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
oneobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct spawntyp:
classobjtyp class
aggrotyp aggro
symtabref baserace
paffectyp paffect
effectyp effect
oneobjtyp loot
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
oneobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct oneobjtyp {
objid type
void* data
}

struct heldobjtyp:
(self) *prev
(self) *next
uchar stack //stack+1 items are present. lumping them together is a complicated operation. 
objid type
void* data

struct subobjtyp:
symtabref itemid : 8
bool cursed : 1
bool oxide : 1
bool burned : 1
schar bonus : 5
uchar metadata : 8 //secondary symtabref for legendary objects

struct magictyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
uchar lde : 3
bool planer : 1

struct shiftertyp {
uchar polytimer : 8	//time remaining in the current polymorph. if non-zero, polyrace is used instead of baserace.
uchar polydepth : 4	//polymorphing more than 10 times without returning to your base form first change your base form to the 15th one
uchar polycount : 4	//repeating the same polymorph 10 times will make it permenant
uchar altertimer : 8	//time remaining in the current alteration.
uchar gills : 4	//using an alteration spell, including intrensics from polymorph spells, 10 times will make them permenent.
uchar lungs : 4	//these counters can be reset by rest or spells
uchar wings : 4
uchar tail : 4
uchar claws : 4
uchar fangs : 4
bodytyp alterations	//keeps track of changes. if a change becomes permenent, it is moved to paffect.
}
/* non-player, non-follower entitys do not have this field,
 * and any polymorph or alteration is permenent. this may be
 * changed in future if memory footprint allows.
 */

struct spelltyp:
symtabref itemid
diceodds odds
uchar prof

struct basespelltyp:
bool poly : 1
bool self : 1
uchar lvl : 6
magictyp type : 8
schar cost_typ : 2 //0 = at will, 1 = gold, -1 = mp, -2 = hp
uchar cost_amnt : 6
potiontyp effect
missiletyp delivery
symtabref polyref

struct psytyp:
schar cost_typ : 2 //0 = at will, 1 = gold, -1 = mp, -2 = hp
uchar cost_amnt : 6
potiontyp effect
missiletyp delivery

struct missiletyp:
bool psion : 1
bool vamp : 1
uchar damage : 8
schar recoil : 7
uchar spread : 2 //0 = line, 1 = narrow (1:3), 2 = wide (1:2), 3 = very wide (1:1)
uchar splash : 3 //radius of damage on impact
bool spz : 1 //spread and splash in the z plane.
bool dig : 1 
//if (.spread != 0), slope = 4-.spreaad

struct baseweaptyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool illum : 1
uchar skill : 3
uchar damage : 8

legendtyp:
paffectyp magic
symtableref base
symtableref spell
legendflagtyp flags

legendflagtyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool unbreak : 1
bool infinate : 1
bool spelled : 1
bool vamp : 1
bool drain : 1
bool interest : 1
bool useless : 1
uchar powermag : 5

struct basearmortyp:
effectyp effect
uchar def
uchar spdef
uchar extfort

struct baseshldtyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool reflect : 1
bool entro : 1
bool light : 1
bool dark : 1
effectyp effect
uchar def : 8
uchar spdef : 8

struct bodytyp:
bool gills : 1	//effects breathing underwater
bool wings : 1	//effects flying
bool tail : 1	//effects unarmed attacks, swimming, flying
bool claws : 1	//effects unarmed attacks, writing
bool hoof : 1	//effects walking, swimming, unarmed attacks
bool talon : 1	//effects walking, swimming, unarmed attacks 
bool fangs : 1	//effects unarmed attacks
bool quad : 1	//effects walking, swimming, unarmed attacks
bool nolegs : 1	//effects walking, swimming, unarmed attacks
bool noarms : 1	//effects walking, swimming, unarmed attacks, writing
bool nolungs : 1	//effects breathing above water
bool noswim : 1	//effects swimming
bool atktail : 1	//effects unarmed attacks, swimming, flying
bool atkwing : 1	//effects unarmed attacks, swimming, flying
schar atkbite : 2	//effects unarmed attacks; +1 = swallow, -1 = bite, -2 = bite ɛ̩̍ breath

struct venomtyp {
elixtyp claws
elixtyp talon
elixtyp fangs
elixtyp tail
elixtyp passive
}

struct stattyp:
dizzy : u4
psn : u4
prlz : u4
frz : u4
brn : u4
stone : u4
slp : u8
invis : u8
blind : u8
eaten : u8

struct elixtyp:
dizzy : b
psn : b
prlz : b
frz : b
brn : b
stone : b
slp : b
invis : b

struct cursetyp:
stattyp type
uchar polytimer
symtabref poly

struct resistyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool stoneproof : 1
bool polyproof : 1
bool sleepproof : 1
bool poisonproof : 1

struct sensetyp:
bool trouble : 1
bool invis : 1
bool infra : 1
bool blind : 1
bool good : 1
bool evil : 1
bool law : 1
bool chaos : 1

struct effectyp:
the8stats eight
bodytyp shape
stattyp stat
resistyp resist
senstyp sense
skilltyp skill
magictyp asp
schar atk
schar spatk
schar def
schar spdef

struct paffectyp
the8stats eight
bodytyp shape
elixtyp ails_ya
elixtyp curse
resistyp resist
senstyp sense
skilltyp skill
magictyp asp
schar atk
schar spatk
schar def
schar spdef

struct potiontyp:
bodytyp shape
elixtyp ails_ya
cursetyp curse
resistyp resist
senstyp sense
sshort hp
sshort mp
diceodds odds

struct skilltyp:
uchar sword : 3 //+skill to sword-type weapon attack
uchar knife : 3 //+skill to knife-type weapon attack
uchar stave : 3 //+skill to stave-type weapon attack
uchar spear : 3 //+skill to club-type weapon attack
uchar whip : 3 //+skill to whip-type weapon range (unused range added to attack)
uchar club : 2 //+skill to club-type weapon attack
uchar bow : 4 //+(2 * skill) to bow-type weapon range
uchar throw : 4 //+(2 * skill) to javalin-type weapon range
uchar monk : 4 //+(2*skill) to unarmed attack, unlocks more modes of attack.
uchar shield : 3 //skill in (damage-defense)+abs(damage-defense) chance of blocking
uchar locks : 3 //1 in 2^(lock.level - (skill)) chance of picking
uchar caster : 6 //-(skill-1)/4 to casting cost, +(skill-1)/4 to spatk and spdef, unlocks spells, 0 is non-caster
bool swim : 1 //learned in shallow water; may be lost by polymorphing to a form with different locomotion.
bool walk : 1 //learned on land; may be lost by polymorphing to a form with different locomotion.
uchar fly : 2 //0 = never had wings, 1 = slow falling, 2 = cannot gain altitude, 3 = free flight. lvl1 learned by falling

/* damage = MAX( incoming-defense , 0 )
 *
 * polyshock = -abs(base.hplvl-poly.hplvl) * !util__roll(1,20,0)
 * ⎧if n < -HPMAX     : Instakill (deathmessage: miscalculated a crucial equivilant-exchange parameter,hath choose...poorly)
 * ⎪if n = -HPMAX     : Stoning
 * ⎨if -HPMAX < n < 0 : abs(n) Damage (deathmessage: could not withstand the cost of transmutation)
 * ⎪if n = 0          : stun for 1D16 (standardmessage: your mind reels from the transformation...)
 * ⎩if n > 0          : success
 *
 * writing =
 * succeed if 4D6 < dex if !talons, plus 1 in 20 odds of breaking pen on fail
 * succeed if 6D6 < dex if talons, plus coinflip odds of breaking pen on fail
 */

readtyp:
uchar locale : 6
bool multiuse : 1
bool scroll : 1
uchar subject : 2 //0 = cooking, 1 = weapons, 2 = language, 3 = spellcraft
uchar uses : 6
*void contents

char* wandmaterials[16] = {"oak","ash","yew","honeylocust","silver","bronze","iron","orichalcum","marble","bone","dragon fang","unicorn horn","glass","lead crystal","adamantine","stardust"} //stoning → marble

wandtyp:
uchar matter : 4
uchar uses : 4
symtabref bound : 8

char* baubmaterials[8] = {"yew","bronze","silver","gold","soapstone","ivory","obsidian","stardust"} //stoning → soapstone

baubtype :
schar type : 2 //0=ring, 1=bracelet, -1=amulet, -2=tiara
uchar matter : 3
uchar color : 3
paffectyp enchnt

struct roomtyp: //top-down display of a 3d space
latlontyp latlon
tileset *hightiles
schar* tiledata[][MAX_Y][MAX_X]
uchar ceiling
shadowmask seen
encontyp *encon_ptr
enttyp *ent_ptr
npctyp *npc_ptr
mapobjtyp *obj_ptr
lightyp *lamp_ptr
setcoord3 *path_ptr
coord2 downstair
coord2 upstair
coord3 home
bool do_upstair : 1
bool do_downstair : 1
bool visited : 1
bool blank : 1
bool shadefloor : 1
uchar floorcolor : 3
uchar meta //may be used by events
/* if invalid coords are given for a warp (typically {$FF,$FF}),
 * then the player is dumped at the location indicated by home.
 *
 * if the player has invalid coords, then the error string "fell out of terminal",N1=x,N2=y is generated.
 */

struct subroomtyp: //used by mapgen
schar tiledata[MAX_Z][MAX_Z][MAX_Z]	//cube of MAX_Z
coord3 dim
enttype *ent_ptr
mapobjtyp *obj_ptr
lightyp *lamp_ptr

/*      .r8 : binary data that is organized into 8 bit segments
 *     .r16 : binary data that is organized into 16 bit segments
 *     .r32 : binary data that is...you get the picture, right?
 *     .hex : binary data that is unorganized
 *     .csv : UTF-8 text record deliminated with commas and line breaks
 *     .tsv : UTF-8 text record deliminated with tabs and line breaks
 *     .ini : UTF-8 text record of key=value pairs deliminated with line breaks
 *      .so : a shared object. a game may use as many of these as it wants. Placing single-use functions in LD_LOAD_PATH is DISCOURAGED; they should be placed in the game's private files.
 *     .dat : internal data from inside a savefile
 *     .txt : UTF-8 text document. usually stored in the program's static files, which is CAT-ed to provide dialouge; also used in dumps of primatives
 *     .nfo : UTF-8 text document (not CP437) containing SGR sequences. otherwise identical to txt.
 *  .tar.gz : each room is saved as a tar.gz file, as are linked lists and the player
 * .tar.bz2 : each plane is saved as a tar.bz2 file.
 *     .sav : a save file. formatted as a .tar.bz2 file tree
 *   .man.# : a linux manpage
 *  .mdoc.# : a bsd manpage
 *          : documentation
 *    .html : documentation
 * .texinfo : documentation
 *       .d : everything relating to a struct is stored in the same directory, and pointers to structs are stored as subdirectories with the name of that field. the tail element in a linked list has no subdirectory named "next"; "prev" pointers are "../" implicitly.
 *     .*rc : a configuration file, parsed with the runcommander
 *    .dump : a debugger data dump, with a format somwhere between JSON, INI, and C-like pseudocode. essentialy a dat file in readable (and non-raw) format.
 *
 * if the following new extensions collide with anything, I will change them. I specifically chose ones that were not a TLA or EFLA to try and avoid this, because there have been TDMTLA since before I came along.
 * .iwfcext : a plugin. "iwfc" should be replaced with the abbiviation of the final name.
 * .midibas : midiBASIC, to be parsed by the midi generator into a .h file. Represents a different subset of general midi than regular midi files, but does so in a human readable format.
 */

/* dat file format:
 * BOM ESC ! @ IWannaFLyCurses DataFile NUL = Magic Cookie (no spaces)
 * SOH name STX string ETX SEPERATOR = a text field
 * SOH name DLE 16bit_length raw_data SEPERATOR = a numeric field
 * SOH name ACK SEPERATOR = a boolean field that is true
 * SOH name NAK SEPERATOR = a boolean field that is false
 * SOH name XON path XOFF SEPERATOR = a pointer to the data at path
 * SOH name SUB 8bit ... = array dimension
 *	an array will consist of either multiple bodys chained together without SEPERATOR or
 *	SOH name inbetween, or a single pointer to a r# or tsv file
 * SOH name SOH name ... = a struct field
 * EM = end of data
 * 
 * seperator may be one of FS, GS, RS, or US;
 * lower levels are used to indicate a suboordinate struct
 */

struct mapgen_bordertyp {
tileset *hightiles_n
schar north[MAX_Z][MAX_X]
tileset *hightiles_s
schar south[MAX_Z][MAX_X]
tileset *hightiles_e
schar east[MAX_Z][MAX_Y]
tileset *hightiles_w
schar west[MAX_Z][MAX_Y]
tileset *hightiles_ne
schar northeast[MAX_Z]
tileset *hightiles_nw
schar northwest[MAX_Z]
tileset *hightiles_se
schar southeast[MAX_Z]
tileset *hightiles_sw
schar southwest[MAX_Z]
tileset *hightiles_u
schar up[MAX_Y][MAX_X]
tileset *hightiles_d
schar down[MAX_Y][MAX_X]
}
/* only used during mapgen, freed immediatly since it's so huge
 * up and down do not need secondary directions as the map cannot be scrolled that way
 */

typedef ushort shadowmask[MAX_Y][MAX_X]
typedef bitfield starfield[MAX_Y][MAX_X/8]

struct petaltyp {
starfield acute
starfield grave
}

bitfield starfield_generator() {
uchar xor_rand = (uchar) (random() ^ (~random() + 1))
bitfield output
output.a = (bool) (xor_rand | 0x80)
output.b = (bool) (xor_rand | 0x40)
output.c = (bool) (xor_rand | 0x20)
output.d = (bool) (xor_rand | 0x10)
output.w = (bool) (xor_rand | 0x08)
output.x = (bool) (xor_rand | 0x04)
output.y = (bool) (xor_rand | 0x02)
output.z = (bool) (xor_rand | 0x01)
return output
}

starfield_step(tube)
starfield tube
{
xiter = MAX_X / 8
for (uchar n = MAX_Y;n;n--) {
	for (uchar x = 0;x < xiter;x++) {
		tube[n][m] = tube[n-1][m]
		}
	}
for (uchar x = 0;x < xiter;x++) {
	tube[0][m] = starfield_generator()
	}

typedef tilemeta* tileset[128]

struct tilemeta {
bool ladder : 1
bool solid : 1
bool liquid : 1
bool conductive : 1
bool burns : 1
bool hypotherm : 1
bool sharp : 1
bool entropy : 1

bool freezes : 1
bool melts : 1
bool petrif : 1

bool dig : 1
bool fence : 1

symtabref freeze : 7
symtabref melt : 7
symtabref stone : 7
uchar density : 7

bool blink : 1
uchar color : 6

char16_t unichar : 16
}
/* tiles can be effected by stuff happening around them.
 *
 * if a tile is flammable, a fire is summoned when fire magic
 * enters the space or 1d6 chance if there is fire within 1 taxicab of it.
 *
 * if a tile is conductive, then electricity is summoned for the instant
 * that electrical magic strikes it, and propagates through contiguous tiles.
 *
 * if a tile can freeze, it's symtabref is changed to the number indicated by ice.
 * when ice magic intersects it.
 *
 * if a tile can melt, it's symtabref is changed to the number indicated by melt
 * when fire or electrical magic intersect it.
 *
 * if a tile can be petrified, it is changed to the tile indicated by stone.
 *
 * if a tile can be dug, using a ↧digging tool on it will remove it
 * digging something triggers updates which cause gravity to affect gases (!liquid,!solid),
 * liquids(+liquid,!solid), and granulars(+liquid,+solid), wherin less dense
 * tiles will swap with more dense ones. this effect travels outwards, to the edge of the room,
 * but will not be applied to the border tiles. granulars are always more dense than liquids,
 * and liquids are always more dense than gases.
 */

/*pseudocode*/getsym
	{
	if (sym < 0)
		{
		cursesprint(.hightiles[sym^-128]) //xor intentional
		}
	else
		{
		cursesprint(.lowtiles[sym])
		}
	}

mapobjflags:
hidden : 1
moves : 1
bool rclass : 1
uchar class : 4
ushort alignment : 9

struct mapobjtyp:
(self) *prev
(self) *next
eventdata eventident
coord3 pos
objid type
void* data
mapobjflags flags

struct lamptyp:
(self) *prev
(self) *next
coord3 pos
uchar lum

struct signtyp {
char16_t unichar
conlangtyp lang
char* lines
char* gibber
}

struct chestyp:
heldobjtyp *bag_ptr
cursetyp trap
locktype locked

struct doortyp {
bool open : 1
uchar hp : 7
locktype lock : 8

struct locktype {
bool locked : 1
bool level : 3
bool pin1 : 1
bool pin2 : 1
bool pin3 : 1
bool pin4 : 1
trapflag flags : 8
/* lockpicking requires the player to enter
 * 0 and + in the correct order to turn the
 * tumblers. in addition to making the correct
 * guess, one must make a skill check:
 * 1 in 2^(lock.level - (skill/2)) chance
 *
 * lockpicking will play an ascending chromatic
 * scale on a loop, starting on C3 and ending
 * at G3, on synthbass (triangle wave)
 */

struct encontyp {
(self) *prev
(self) *next
eventdata eventident
uchar tobeat	//of 10D20
spawntyp spawn

struct miscitembasetyp:
bool key : 1
bool pick : 1
bool dig : 1
bool music : 1
bool light : 1
bool book : 1
bool spark : 1
bool quest : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool stoneproof : 1
bool arrow : 1
bool poisoned : 1
bool unbreak : 1
uchar uses : 8
uchar metadata : 8

struct eventdata {	//48-bit persistant event data
uchar identnumber : 15
bool uses_race : 1
bool uses_role : 1
bool uses_class : 1
uchar race : 5
uchar role : 2
uchar class : 3
ushort align : 9
uchar element : 8
uchar lde : 3
}

struct eventdatobj {	//list of events
(self)* prev
(self)* next
eventdata data
}

struct eventtyp:
(self) *prev
(self) *next
const char* requires	//path to a shared object, or NULL
eventdata eventdatavals
triggertyp whenthis
int(short,short,char,char,char,eventdata)* ifthis
int(short,short,char,char,char,eventdata)* dothis
const char* name
cylinder dim
umint duration
/* events call raw C functions, without any sort of restrictions on what they have
 * access to beyond what the program can give it. the idea is to provide a full
 * turing-complete interface by which the game's world can be altered according
 * to actions taken by the player. another use would be to show a cutscene rendered
 * with raw curses calls; an elaborate example of curses used in that manner
 * will be found in the game's introduction cutscene.
 */

enum triggerenum {ALWAYS_FLAG,ILLUM_FLAG,LOOK_FLAG,FARLOOK_FLAG,BUMP_FLAG,HIT_FLAG,FIRST_FLAG,NEW_FLAG,DAY_FLAG,TIME_FLAG,MORN_FLAG,NOON_FLAG,EVE_FLAG,MIDNITE_FLAG,DAY_FLAG,NIGHT_FLAG}

struct triggertyp {
triggerenum key : 4
uchar value : 4
}

struct qglobobj: //queued global object
(self) *prev
(self) *next
eventdata eventident
qglobflags flags
latlontyp latlon
coord3 pos
objid type
void* data

struct qglobflags {
race : 8
race-specific : 1
role : 2
class : 3
lawfulgood : 1
neutralgood : 1
chaoticgood : 1
lawfulneutral : 1
trueneutral : 1
chaoticneutral : 1
lawfulevil : 1
neutralevil : 1
chaoticevil : 1
canforceload : 1
}

struct traptyp:
(self) *prev
(self) *next
eventdata eventident
char16_t unichar
coord3 loc
ushort duration
magictyp element
stattyp stat
cursetyp curse
diceodds odds
trapflags flags
senstyp sense
sshort hp
sshort mp

struct trapflags:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool tamperproof : 1
bool stoneproof : 1
bool warded : 1
bool mode : 1
aligntyp attacks : 8	//if mode is true, will only attack entitys that are of an alignment that is undefined or true; if mode is false, will not attack entitys with alignment that is undefined or false
bool multiuse : 1
bool magic : 1	//whether the trap is a mechanism or a rune
uchar color : 6


struct subwarptyp {
eventdata eventident
bool perm : 1
bool blink : 1
uchar color : 6
coord3 loc
setcoord3 *dest
sshort duration	//negative are uses, positive are turns
}

struct warptyp:
eventdata eventident
bool perm : 1
bool blink : 1
uchar color : 6
latlontyp glob_loc
coord3 loc
latlontyp glob_dest
setcoord3 *dest
sshort duration

char* gemcolors[8] = {"jet","sapphire","emerald","turquoise","ruby","amythest","heliodor","diamond"} //stoning has no effect
/* cut varys by color:
 * diamond = {uncut,cushion-cut,princess-cut,perfect-cut}
 * beryls,emerald={uncut,oval-cut,emerald-cut,teardrop} redundancy of emerald-cut emerald is redundant
 * amythest={geode,prismatic,cushion-cut,teardrop}
 * jet,turquoise={piece of,byzantine,polyhedral,carved relif in}
 */

struct gemstonetyp:
uchar color : 3
uchar quality : 2
uchar cut : 2

struct meattyp:
symtabref race : 8
bool hightable : 1
uchar sellby : 7
uchar amount : 8

struct foodtyp:
symtabref itemid
symtabref metadata
uchar sellby
uchar amount

foodbasetyp:
effectyp effect
diceodds odds
uchar keepsfor
uchar hp
uchar nutri

bool always(ushort,ushort,ushort,ushort){return true}

enum objid:
WEAPON_FLAG : contains subobjtyp calling baseweaptyp
POTION_FLAG : contains potiontyp
READ_FLAG : contains readtyp
FOOD_FLAG : contains subobjtyp containing foodtyp
MEAT_FLAG : contains subobjtyp containing meattyp
ARMOR_FLAG : contains subobjtyp calling basearmortyp
SHLD_FLAG : contains subobjtyp calling baseshldtyp
BAUB_FLAG : contains subobjtyp calling baubtyp
CONLANG_FLAG : contains conlangtyp
SPELL_FLAG : contains spelltyp
MISC_FLAG : contains symtabref
GEM_FLAG : contains gemstonetyp
TRAP_FLAG : contains traptyp
EVENT_FLAG : contains eventtyp
QGLOB_FLAG : contains qglobobj
WARP_FLAG : contains warptyp
SUBWARP_FLAG : contains subwarptyp
CHEST_FLAG : contains chestyp
DOOR_FLAG : contains doortyp
LOCK_FLAG : contains locktyp (gates are this)
MONEY_FLAG : contains moneytyp
SPAWN_FLAG : contains spawntyp
SIGN_FLAG : contains signtyp

/*blackbox*/radius
/* uses floats to define a circle,
 * terminating when there is not enough
 * value left to move another whole block.
 * one function won't cover all use cases.
 */

each layer is drawn translated +1y for each layer above the player and -1y for each layer below.
a shadow is drawn under the player
layers are drawn from ground to sky; if the player or their shadow would be covered by a tile,
drawing is stopped and the player is drawn if they have not been already
fluid tiles are transparent.

to avoid confusion, by default the player always uses a unique character: ☻

an UNDERLINE is a shadow

note: unicode symbols are (mostly) used be their appearence, not by their meaning
) is a sword or dagger. ⍏ are polearms. \ is a staff. ¦ is a club. : is a mace. ℓ is a whip. ( is a bow. ⇤ is an arrow. ⍖ is a writing instrument.
⟦ is armor. [ is clothing. ] is a shield. ⟧ are cannons or greeves. % is meat. ⊞ is food (don't shoot it). $ is gold. ¢ is copper.
? is a misc item. ✥ is a shurkin. ↧ is a digging tool. ⌥ is a key or lockpick. ♫ is a lyre. ƒ is a violin. ♪ is a different music instrument.
¿ are potions (fragile). ∫ is a scroll. ⊒ is a book. ∩ is a tablet. ° is a ring. º is a bracelet. ª is an amulet. ^ is a crown.
/ is a wand. ♮ is a ladder. ⋎ is a fountain or gyser. ⍾ is a bell. ⎋ is a clockface. ♠ ♣ ‡ are trees. ⋏ is fire. ♜ is a pedestal.
∿ is shallow liquid. ≈ is deep liquid's surface. ∬ is a waterfall. ~ is a liquid (as seen while submerged).  ≣ is a staircase. 
⌁ is electricity. * is ice. ⎈ spider web. ⌬ beehive. ↥ are spikes. ⎙ ⍝ ⎍ ∎ ⎅ are tombstones or signs. ␥ is glass.
! is trouble. ⌑ is a light source. ⌸ is a door. ⍯ is a locked door. ⎕ is an open door. = is a gate. ≠ is a locked gate. ∷ is an open gate.
• is a boulder. . is a rock. ⁂ is a rockslide. ◇ is a gemstone. ◊ is a giant magic crystal. ⑆ are footprints.
∪ is a sink. ⏍ is a chest. ↯ (cyan) is the thunderbolt. ∅ is a spacetime anomaly (do not touch). < > are level stairs. ⌘ is home.
← ↑ → ↓ ↖ ↗ ↘ ↙ are flying projectiles. ⇐ ⇑ ⇒ ⇓ ⇖ ⇗ ⇘ ⇙ are ballistae. ✪ is a rune. ː ⍽ are traps.
# █ ▓ ▒ ░ ▞ ▚ (etc) are thick walls or floor. ≋ is a cloud (do not walk on them; keep your head out of them).
˜ ␣ are holes. ' is a stalagtite or icicle. , is a plant. ; is a grain or sunflower (impassable).
box drawings are low walls or columns. ⑉ ⋮ are iron bars. · is an ember or star. ` ´ ˇ are flower petals.
¬ (blinking) is stale air (unbreathable). ≃ is stagnent water (unbreathable). ☣ ‽ is gas.
" deliminates text.
⍰ is a missingno.

the symbol for gemstone and giant crystal has been the source of much headache,
but any truly monospace font should render their relative sizes correctly;
if the font is only pretending to be monospace (like the default github font),
you'll have bigger issues of non-uniform characters warping and tearing
the world's projection grid. it is for this reason that the recommended font
is a raster one, as raster fonts tend to be more uniform.

box drawings:
 ╒╤╕     ╔╦╗
 ╞╪╡flat ╠╬╣upright
 ╘╧╛     ╚╩╝

A_DIM is used to provide 16 colors
A_ITALIC symbols are petrified (statues).
A_BLINK is a tile that is out of view
A_BOLD symbols are highlighted
A_INVIS is not able to be seen
A_REVERSE video is a magic spell's area of effect
A_UNDERLINE is the shadow of an entity

text that is cat-ed from an nfo file, or otherwise printed using stdio, will not be restricted to ncurses formatting,
and will use the full range of ANSI SGR escape codes

rune symbols
◬ air, ⍫ earth, △ fire, ▽ water, ⍰ missingno
※ ice, ↯ (yellow) electricity, ♤ metal, ♻ nature
☣ status effect, ‽ stoning, ∅ entropy
☼ light, ☽ dark, § polymorph, ↹ planer
♥ healing

magic AOE symbols
≋ air, • earth, ⋏ fire, ≈ water
* ice, ⌁ electricity, ↥ metal, ♠ nature
☣ status effect, ‽ stoning, ∅ entropy
⌑ light, ⎈ dark, § polymorph

directional symbols:
←, ↑, →, ↓, ↖, ↗, ↘, ↙, direction in XY;
! far side; ↧, ↥, direction in Z;
↹ different plane;
◬, ⍫, △, ▽, ※, ↯, ♤, ♻, ☼, ☽, ∅, inner planes;
LG, NG, CG, LN, CN, LE, NE, CE, TN, ×, ☠, outer planes;

STYLE GUIDE:
the following nonstandard punctuation may be used in dialouge (list not exaustive) :  ‽ explosive disbelief  ⸮ rhetorical  .ˢ sarcasm  ♪ playful  ♥ careing  ♩♯ taunt  ↯ explosive anger  ☠ foul oath
nonstandard punctuation should be established in obvious, unambiguous, context before being used to disambiguate sentence meaning later on.
monospaced raster fonts presented light-on-dark can be unappealing to the uninitiated, so every opportunity should be taken to make the text more appealing.
other nonstandard punctuation that is not used to disambiguate meaning (♪, ♥, ♩♯, ↯, ☠) helps to paint the medium, making the dialouge come alive;
for the same reason, dialouge should be colored and styled as appropriate whenever possible.

foods (* = uses meta)
hardtak tortilla cornmeal cornbread
flour cheese wine bread
mead ale scotch ethenol
grapes fig date plum
apple banana apricot papaya
orange pear pinapple coconut
kiwi dragonfruit durin peach
grapefruit lemon lime citron
spinach artichoke asparagus bamboo
cucumbers zuccini pickles squash
carrot corn potato celery
brocoli lettuce cabbage kale
cauliflower raddish turnip beets
rhubarb pumpkin avacodo jalapenos
beans greenbeans tomato eggplant
blackolives greenolives garlic onions
watercress chives ketchup mustard
parsly sage rosmary thyme
basil oregano allspice nutmeg
salt bellpeppers peppercorns redpepper
vanillabean cinnimonstick cocoabean sugarbeet
walnut pecan cashew peanut
sunflowerseed pistachio almond chestnuts
cranberrys blueberrys raspberry blackberry
strawberry cherry peppermint pawpaw
sugarcane syrup* molasses honey
seseme poppy fennel eyeofnewt
mushroom* truffel penecillin yeast
barly wheat rye rice
ginger sasafrass blueraspberries bubbles 
geletin starch creamoftartar bakingpowder
vinager bakingsoda calciumhydroxide hemlock
popcorn nachos cookies milk*
pasta(uncooked) pasta ramen(uncooked) ramen*
dumplings(uncooked) dumplings* tofu(uncooked) tofu
meatballs marinara alfredosauce parmisian
lasagnia* pizza* spaghetti alfredo
spaghetti&meatballs ramen&dumplings chickenalfredo brocllialfredo
guacamole nachos* chili salsa
pie* cake* soda* chips
salad* hotdog* hamburger* fries
vanilla cinnimon chocolate sugar
cocoapowder cocoabutter cocoaliquor fudge
egg fat* caramel butterscotch
sourcream butter/shortening* mayo dressing*
pie* pie_alamode* englishfruitcake bread*
cake* pancake* waffle* stackofpancakes*
frozenpancake frozenwaffle flavoredmilk* juice*
roast* gravy foo&gravy* foo_chicken*
bakedpotato loadedbakedpotato mashpotatos tatties&neeps
sunnysideup overeasy scrambled hardboiled
bacon* sausage* jerky* spam
nutbrittle* trailmix rasin* peanutbuttersandwich*
baconlettucetomatosandwich clubsandwich fingersandwich* coldcutsandwich*
milkshake* icecream* sorbet* icecreamfloat*
icecreamcone* banannasplit neopolitan rockyroad
gumdrop* hardcandy* candycane filledchocolate*
jelly* jam* preserves* peanutbutter
icecube snow ember blacksoup
broth* stew* ration mistake

/*ROTTEN pseudocode*/playermove(xmove,ymove,zmove)
schar xmove
schar ymove
schar zmove
{
velocitycheck()
xymovecheck(xmove,ymove)
zmovecheck(zmove)

PLAYER.pos.x += xmove
if (PLAYER.pos.x < 0) {
	PLAYER.pos.x = mapscroll(-1,0).x
	
	}
else if (PLAYER.pos.x ≥ MAX_X) {
	PLAYER.pos.x = mapscroll(1,0).x
	}

PLAYER.pos.y += ymove
if (PLAYER.pos.y < 0) {
	PLAYER.pos.y = mapscroll(0,-1).y
	}
else if (PLAYER.pos.y ≥ MAX_Y) {
	PLAYER.pos.y = mapscroll(0,1).y
	}

PLAYER.pos.z += zmove
}

/*blackbox*/playervelocitycheck() velocitycheck(*entity)
	/* if you have a nonzero velocity vector, when you try to move
	 * you travel in a direction determined by the mean vector of
	 * your move and your velocity. each turn, your velocity reduces
	 * by 1+.5n on land, 1+.75n underwater, and is cancled compleatly
	 * in a direction if you hit something.
	 */

/*blackbox*/movecheck(xmove,ymove,zmove)
	/* if you are flying {
	 *	checks your flying skill and restricts your movement accordingly
	 *		if you have no flying skill, grav is added to your -Z velocity
	 *	checks to make sure that you are not flying through a solid block
	 *	checks to make sure you are not landing in water if you can't swim
	 *		asks if you are sure
	 *	}
	 * if you are walking {	
	 *	checks to make sure you are not walking off a cliff without wings
	 *		asks if you are sure
	 *	checks to make sure you are not walking into deep water if you can't swim
	 *		asks if you are sure
	 *	automatically climbs 1-high blocks that are not fences
	 *	}
	 * updates your direction 	
	 * if you leave the room by any means, creates a mapscrolltyp of the apropriate value and calls mapscroll
	 * subtracts the appropriate value from your remaining move
	 * }
	 */

/*blackbox*/newtonlaw(xmove,ymove,zmove)
	- checks if you're flying magically, on ice, or in a liquid
	- if you are, adds {-xmove,-ymove,-zmove} to your velocity
	  (half this value in liquids)

/*rotten pseudocode*/mapwarp(destination,tocoord)
latlontyp destination
coord3 tocoord
{
saveroom()

WORLD = destination

mapscroll(NOSCROLL)

loadroom(WORLD)

if ((tocoord.x > MAX_X) || (tocoord.y > MAX_Y) || (tocoord.z ≥ CEILING)) {
	PLAYER.pos.x = ROOM.home.x
	PLAYER.pos.y = ROOM.home.y
	PLAYER.pos.z = ROOM.home.z
	}
else {
	PLAYER.pos.x = tocoord.x
	PLAYER.pos.y = tocoord.y
	PLAYER.pos.z = tocoord.z
	}
}

/*blackbox*/loading()
	/* clears screen
	 * prints "  LOADING..." on line 13
	 * prints a hint on line 22.
	 *   hints are stored in a struct
	 */

struct mapscrollargs {
schar latmove : 2
schar lonmove : 2
schar depmove : 2
bool stair : 1
bool home : 1
}

mapscrollargs NOSCROLL = {0,0,0,false,false}

/*implicit*/mapscroll(args)
mapscrollargs args
{
BREAKCURSES
if (IS_XTERM) {printf("\033]2;IWannaFlyCurses - %s: loading...\033\\",GAMENAME);}
printf("loading...");
fflush(stdout);
FIXCURSES
saveroom(NULL)
freeroom(NULL)
WORLD.coord.lat += args.latmove
if (WORLD.coord.lat > EQUATOR/4) {
	WORLD.coord.lat = EQUATOR/2 - WORLD.coord.lat
	WORLD.coord.lon += EQUATOR/2
	if (WORLD.coord.lon > EQUATOR/2) {
		WORLD.coord.lon += -EQUATOR
		}
	}
else if (WORLD.coord.lat < -EQUATOR/4) {
	WORLD.coord.lat = -EQUATOR/2 - WORLD.coord.lat
	WORLD.coord.lon += EQUATOR/2
	if (WORLD.coord.lon > EQUATOR/2) {
		WORLD.coord.lon += -EQUATOR
		}
	}

WORLD.coord.lon += args.lonmove
if (WORLD.coord.lon ≥ EQUATOR/2) {
	WORLD.coord.lon += -EQUATOR
	}
else if (WORLD.coord.lon < -EQUATOR/2) {
	WORLD.coord.lon += EQUATOR
	}

if ((args.depmove < 0) && (WORLD.coord.dep = 0)) {
	depmove = 1
	WORLD.coord.lat = -WORLD.coord.lat
	if (WORLD.coord.lon == -EQUATOR/2) {WORLD.coord.lon = 0}
	else {WORLD.coord.lon = -WORLD.coord.lon}
	}
else if ((args.depmove > 0) && (WORLD.coord.dep = ROOF)) {
	/* death message (one of the following):
	 * flew too close to the sun
	 * was smited for rising too high
	 * grew too proud
	 * passed out in space and burned up on reentry
	 * froze to death in outer space
	 * became lost...in...spaaace!
	 */
	}
WORLD.coord.dep += args.depmove
if (depmove ≥ 0) : {
	if (home) {
		PLAYER.pos.x = ROOM.home.x
		PLAYER.pos.y = ROOM.home.y
	else if (stair) {
		PLAYER.pos.x = ROOM.downstair.x
		PLAYER.pos.y = ROOM.downstair.y
		}
	PLAYER.pos.z = 0
	}
else {
	if (home) {
		PLAYER.pos.x = ROOM.home.x
		PLAYER.pos.y = ROOM.home.y
	else if (stair) {
		PLAYER.pos.x = ROOM.upstair.x
		PLAYER.pos.y = ROOM.upstair.y
		}
	PLAYER.pos.z = CEILING
	}

ROOM = loadroom(WORLD)

NEW = true
FIRST = !(visited)
ROOM.visited = true

BREAKCURSES
if (IS_XTERM) {printf("\033]2;IWannaFlyCurses - %s: %i°%c, %i°%c, %i\033\\",GAMENAME,abs(WORLD.lat),WORLD.lat > 0 ? 'N' : (WORLD.lat < 0 ? 'S' : ' '),WORLD.lon > 0 ? 'E' : ((WORLD.lon < 0) && !(WORLD.lon == -180) ? 'W' : ' '),WORLD.dep - 100);
FIXCURSES
render();
}

/*blackbox*/saveroom(roomtyp*)
//saves the room pointed to, or the current room if NULL

/*implicit*/freeroom(roomptr)
roomtyp* roomptr
{
if (roomptr == NULL) {roomptr = ROOM}
	{
	encontyp* current = roomptr→encon_ptr→prev
	encontyp* previous = roomptr→encon_ptr→prev→prev
	roomptr→encon_ptr→prev→next = NULL
	roomptr→encon_ptr→prev = NULL
	while (previous != NULL) {
		free(current)
		current = previous
		previous = previous→prev
		}
	free(current)
	current = NULL
	}
	{
	setcoord3* current = roomptr→encon_ptr→prev
	setcoord3* previous = roomptr→encon_ptr→prev→prev
	roomptr→encon_ptr→prev→next = NULL
	roomptr→encon_ptr→prev = NULL
	while (previous != NULL) {
		free(current)
		current = previous
		previous = previous→prev
		}
	free(current)
	current = NULL
	}
	{
	enttyp* current = roomptr→encon_ptr→prev
	enttyp* previous = roomptr→encon_ptr→prev→prev
	roomptr→encon_ptr→prev→next = NULL
	roomptr→encon_ptr→prev = NULL
	while (previous != NULL) {
		free(current)
		current = previous
		previous = previous→prev
		}
	free(current)
	current = NULL
	}
	{
	mapobjtyp* current = roomptr→encon_ptr→prev
	mapobjtyp* previous = roomptr→encon_ptr→prev→prev
	roomptr→encon_ptr→prev→next = NULL
	roomptr→encon_ptr→prev = NULL
	while (previous != NULL) {
		free(current)
		current = previous
		previous = previous→prev
		}
	free(current)
	current = NULL
	}
	{
	lightyp* current = roomptr→encon_ptr→prev
	lightyp* previous = roomptr→encon_ptr→prev→prev
	roomptr→encon_ptr→prev→next = NULL
	roomptr→encon_ptr→prev = NULL
	while (previous != NULL) {
		free(current)
		current = previous
		previous = previous→prev
		}
	free(current)
	current = NULL
	}
	return free(roomptr)
}

roomtyp* loadroom(latlontyp)
//loads room indicated by WORLD

/*blackbox*/saveworld()
/*blackbox*/loadworld()
//sync and load the files for planes

/*blackbox*/loadgame()
/*blackbox*/savegame()
//loading and saving of the entire file

/*blackbox implicit*/dump(datatypenum,void*)
// used by the debugger to dump data.

/*pseudocode implicit*/castshadow(xpos,ypos,zpos)
uchar xpos
uchar ypos
uchar zpos
{
if (zpos == 0) {
	return zpos
	}
else if (mapderef(xpos,ypos,zpos-1).solid) {
	underline(xpos,ypos,zpos)
	return zpos
	}
else {
	zpos--
	for (;zpos!=0;zpos--) {
		if (mapderef(xpos,ypos,zpos-1).solid) {
			underline(xpos,ypos,zpos)
			return zpos
			}
		else if (mapderef(xpos,ypos,zpos-1).liquid) {
			underline(xpos,ypos,zpos)
			}
		}
	underline(xpos,ypos,zpos) //escape zpos==0
	return zpos
	}

bool maskfetch(zcoord,ycoord,xcoord,mask)
uchar zcoord
uchar ycoord
uchar xcoord
shadowmask mask
{
switch (zcoord) : {
	case 0 : return (bool) (mask[ycoord][xcoord] & 0x8000);
	case 1 : return (bool) (mask[ycoord][xcoord] & 0x4000);
	case 2 : return (bool) (mask[ycoord][xcoord] & 0x2000);
	case 3 : return (bool) (mask[ycoord][xcoord] & 0x1000);
	case 4 : return (bool) (mask[ycoord][xcoord] & 0x0800);
	case 5 : return (bool) (mask[ycoord][xcoord] & 0x0400);
	case 6 : return (bool) (mask[ycoord][xcoord] & 0x0200);
	case 7 : return (bool) (mask[ycoord][xcoord] & 0x0100);
	case 8 : return (bool) (mask[ycoord][xcoord] & 0x0080);
	case 9 : return (bool) (mask[ycoord][xcoord] & 0x0040);
	case 0xA : return (bool) (mask[ycoord][xcoord] & 0x0020);
	case 0xB : return (bool) (mask[ycoord][xcoord] & 0x0010);
	case 0xC : return (bool) (mask[ycoord][xcoord] & 0x0008);
	case 0xD : return (bool) (mask[ycoord][xcoord] & 0x0004);
	case 0xE : return (bool) (mask[ycoord][xcoord] & 0x0002);
	case 0xF : return (bool) (mask[ycoord][xcoord] & 0x0001);
	default : return false;
	}
}

/*implicit*/maskset(zcoord,ycoord,xcoord,mask,value)
uchar zcoord;
uchar ycoord;
uchar xcoord;
shadowmask mask;
bool value;
{
if (value) {
	switch (zcoord) : {
		case 0 : return mask[ycoord][xcoord] |= 0x8000;
		case 1 : return mask[ycoord][xcoord] |= 0x4000;
		case 2 : return mask[ycoord][xcoord] |= 0x2000;
		case 3 : return mask[ycoord][xcoord] |= 0x1000;
		case 4 : return mask[ycoord][xcoord] |= 0x0800;
		case 5 : return mask[ycoord][xcoord] |= 0x0400;
		case 6 : return mask[ycoord][xcoord] |= 0x0200;
		case 7 : return mask[ycoord][xcoord] |= 0x0100;
		case 8 : return mask[ycoord][xcoord] |= 0x0080;
		case 9 : return mask[ycoord][xcoord] |= 0x0040;
		case 0xA : return mask[ycoord][xcoord] |= 0x0020;
		case 0xB : return mask[ycoord][xcoord] |= 0x0010;
		case 0xC : return mask[ycoord][xcoord] |= 0x0008;
		case 0xD : return mask[ycoord][xcoord] |= 0x0004;
		case 0xE : return mask[ycoord][xcoord] |= 0x0002;
		case 0xF : return mask[ycoord][xcoord] |= 0x0001;
		default : return ERR;
		}
	}
else {
	switch (zcoord) : {
		case 0 : return mask[ycoord][xcoord] &= ~0x8000;
		case 1 : return mask[ycoord][xcoord] &= ~0x4000;
		case 2 : return mask[ycoord][xcoord] &= ~0x2000;
		case 3 : return mask[ycoord][xcoord] &= ~0x1000;
		case 4 : return mask[ycoord][xcoord] &= ~0x0800;
		case 5 : return mask[ycoord][xcoord] &= ~0x0400;
		case 6 : return mask[ycoord][xcoord] &= ~0x0200;
		case 7 : return mask[ycoord][xcoord] &= ~0x0100;
		case 8 : return mask[ycoord][xcoord] &= ~0x0080;
		case 9 : return mask[ycoord][xcoord] &= ~0x0040;
		case 0xA : return mask[ycoord][xcoord] &= ~0x0020;
		case 0xB : return mask[ycoord][xcoord] &= ~0x0010;
		case 0xC : return mask[ycoord][xcoord] &= ~0x0008;
		case 0xD : return mask[ycoord][xcoord] &= ~0x0004;
		case 0xE : return mask[ycoord][xcoord] &= ~0x0002;
		case 0xF : return mask[ycoord][xcoord] &= ~0x0001;
		default : return ERR;
		}
	}
}

bool langetx(race,id)
basentyp race
uchar id
{
div_t tmp = div(id,8)
if (tmp.quot > 3) {ERROR_GRAPHIC("math: out of bounds",'u',id,'u',31,false); return false}
switch (tmp.rem) : {
	case 0 : return (bool) (race.vocal[tmp.quot] & 0x80);
	case 1 : return (bool) (race.vocal[tmp.quot] & 0x40);
	case 2 : return (bool) (race.vocal[tmp.quot] & 0x20);
	case 3 : return (bool) (race.vocal[tmp.quot] & 0x10);
	case 4 : return (bool) (race.vocal[tmp.quot] & 0x08);
	case 5 : return (bool) (race.vocal[tmp.quot] & 0x04);
	case 6 : return (bool) (race.vocal[tmp.quot] & 0x02);
	case 7 : return (bool) (race.vocal[tmp.quot] & 0x01);
	default : ERROR_GRAPHIC("math: invalid remainder",'u',temp.rem,'u',8,true); raise(SIGTRAP);
	}
}

engineloop () {
TILDEWIDE = setwidetilde()
forever {
	if (NEW) {
		checkglobal(NEW_FLAG,true)
		NEW = false
		}
	checkevents()	//check event triggers
	player_act()	//player's turn
	follow_iter()	//iterate through follower entities
	ent_iter()	//iterate through local entities
	encounter(1D6,1d100)	//generate up to 1D6 of monster number 1d100, iff encounter != NULL
	}
}

/*pseudocode*/ <follow|ent>_iter () {
<ent|follow>typ* ptr = <head>
while (ptr != NULL) {
	<follow|ent>_act(&ptr) //&ptr's turn
	ptr = ptr→next
	}
}

/*pseudocode*/encounter(count,tableid)
uchar count
uchar tableid
{
encontyp *ptr = ROOM.encon_head
for (;tableid != 0;tableid--) {
	ptr = ptr→next
	}
uchar try;
for (;count != 0;count--) {
	try = mainh_roll(10,20,1)
	if (try > ptr→tobeat) {
		summonfunc(ptr→spawn)
		}
	}
}

/*blackbox*/render() {
/* flush THESHADOWKNOWS and SHINEALIGHT
 * translate the view so that the player is on line 13
 * cast shadows and record the player's shadow
 * illuminate the player according to their view range
 * illuminate all lights in the room.
 * get the player's view information. only draw tiles that can be seen.
 * draw each layer of the room one at a time, making sure the player and their shadow are not covered, and doing out-of-view substitution.
 * draw the player
 * draw other entitys that can be seen
 * add shadows
 */

termcheck() {
TERM = getenv("TERM");
if (strstr(TERM,"xterm") != NULL) {
	IS_XTERM = true
	}


/*pseudocode*/enginesplash(GAME_NAME,GAME_VERSION,STORY_REV)
const char* GAME_NAME GAME_VERSION STORY_REV
{
	if (IS_XTERM = true) {
	printf("\033]1;IWannaFlyCurses\033\\");
	printf("\033]2;IWannaFlyCurses - %s\033\\",GAMENAME);
	}
printf(RESET);
printf(" \033[1;95m~~ IWANNAFLY ROGUELIKE ENGINE ~~\033[m\n\033[97m          engine version: %s\n          rules revision: %s\n            API revision: %s\n        savefile version: %s\nextension parser version: %s\n    runcommander version: %s\n       midibasic version: %s\n       midi backend type: %s\n\n \033[96m - %s -\033[m\n\033[97m  game version: %s\nstory revision: %s\n\n\033[37mCompiled on %s\n\033m\a",ENGINE_VERSION,RULES_VERSION,API_VERSION,SAVE_VERSION,EXT_PARSE_VERSION,RUNCOM_VERSION,MIDIBAS_VERSION,MIDI_TYPE,GAME_NAME,GAME_VERSION,STORY_REV,__DATE__);
fflush(stdout);
sleep(4);
printf(RESET);
printf("\033[1;32m\tEngine Copyright (C) 2019- \"GeneralGuy4872\"\n\n\tThis program is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU General Public License\n\tas published by the Free Software Foundation; either version 2\n\tof the License, or (at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see \n\t\033[m\033[4;94mhttps://www.gnu.org/licenses/\033[m\033[1;32m.\a");
fflush(stdout);
sleep(4);
printf(RESET);
printf("\033[92mLibraries linked:\nNCurses by Zeyd M Ben-Halim,\n           Eric S. Raymond,\n           Thomas E Dickey\n           and the Free Software Foundation\nLibTar by Mark D. Roth\nZlib by Jean-loup Gaully and Mark Adler\nLibBZip2 by Julian Steward\n");
fflush(stdout);
sleep(4);
printf(RESET);
printf("\033[92mAlgorithems Implemented:\nDijkstra's Algorithem\nPrim's Algorithem\nKruskal's Algorithem and Kruskal's Reverse Algorithem\nBorůvka's Algorithm\nRolling Dice\nSierpiński Attractor\nPerlin Noise\a");
fflush(stdout);
sleep(4);
}

main() {
termcheck();
enginesplash("Default Game","Prealpha","Rough Draft");
printf(RESET);printf(BLINKY);
fflush(stdout);
sleep(4);
printf(RESET);
file_cat_nocurses(STATIC_PATH"scene.nfo");	//...okay, it's the story of every JRPG ever, but the story of the 3D game didn't have a wide enough scope. I'll write more later, when I'm in that mindset.
printf("\a");
fflush(stdout);
sleep(4);
printf(RESET);printf(BLINKY);
fflush(stdout);
sleep(4);
printf(RESET);
puts("\033[3mSo it begins...\033[23m\a");
fflush(stdout);
sleep(4);
FIXCURSES
do_intro_movie();
promptload();
engineloop();
}

/*blackbox*/exitengine()
/* at exit:
 * 	prompt save, y: saveworld
 * 	free files
 * 	exit curses
 * register atexit, catch SIGINT and route to safe quit
 */

void death(path/to/epitaphs)
/* kills player with epitaph from list
 * records high score
 * saves
 * exit with atexit
 */

uint stringlen (input)
char* input
{
uint n = 0
while (input[n] != 0) {n++}
return n + 1
}

stringlistyp* loadstringlist(path)
const char* path
{
stringlistyp* newnode

FILE* list = fopen(path)
char buffer[BUFFERMAX]
stringlistyp* output = malloc(sizeof(stringlistyp))
fgets(buffer,BUFFERMAX - 1,list)
output→prev = output
output→next = output
output→text = calloc(stringlen(buffer),sizeof(char))
strcpy(output→text,buffer)

stringlistyp* new
while (EOF != fgets(buffer,511,list)) {
	new = malloc(sizeof(stringlistyp))
	fgets(buffer,BUFFERMAX - 1,list)
	output→prev = output
	output→next = output
	output→text = calloc(stringlen(buffer),sizeof(char))
	strcpy(output→text,buffer)
	output→prev→next = new
	new→prev = output→prev
	new→next = output
	output→prev = new
	}
}

char* getname()
{
char buffer[BUFFERMAX]
char* buffer

BREAKCURSES
printf("name")
puts(BLINKY)
fgets(buffer,BUFFERMAX - 1,stdin)
output = calloc(stringlen(buffer),sizeof(char))
strcpy(output,buffer)
FIXCURSES
return output
}

/*pseudocode*/resizetest
/*IF window is too small THEN PRINT
 * "The terminal is too small."
 * "Please increase the number of " ("rows"|"columns"|"rows and columns")
 * "to avoid segmentation violations."
 * "Press any key to continue"BLINKY
 */
