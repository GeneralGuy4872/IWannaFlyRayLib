#error NOT READY FOR INITIAL COMPILATION
/* to preserve the file history,
 * this file will eventually become main.h, main.c, or util.c
 * a dummy.h and dummy.c will provide externs and macros for linkage.
 * some of the larger comment blocks will be moved to man, info, and/or doc
 *
 * the bulk of it's contents, however, will be moved.
 *
 * comments may be deleted, may be moved into documentation, or may stay with what they describe
 *
 * workflow:
 * outline blackboxes top-down (-ish)
 * outline pseudocode top-down (-ish)
 * write real code bottom-up
 * structs are made both top-down (specific) and bottom-up (generic)
 * changes must be propogated both down and up
 *
 * optimized for memory footprint. speed is not a concern at the moment.
 * C++ was considered and partialy implemented, but mangling made it unsuitable
 *
 * the programming paradigm I am using throughout the project is based on the way my mind works
 * rather than a specific programming paradigm; it contains elements from several, including some
 * nonstructured paradigmes.
 *
 * the program also uses various memory management paradigms,
 * including linked lists, stacks, queues, and page swapping.
 *
 * example: loading a room's file is swapping it into memory.
 * once it is loaded, the pointer is placed on the top of
 * the stack of loaded rooms, and the stack's depth counter
 * is increased. when the counter reaches the limit, the
 * stalest room is dropped. when warping, the room stack
 * is checked before an attempt is made to load another
 * room; when a room is recalled, it is moved to the top
 * of the stack, therefore less stale rooms are able to be
 * fetched faster than more stale rooms.
 *
 * additional indirection layers are used in an attempt to
 * prevent larger data structures from being duplicated
 *
 * most function calls provide an (obfuscation|abstraction) layer,
 * and before attempting to understand a function you should trace
 * down all the functions it calls. many functions use dynamic memory
 * operations, such as malloc and free; these side effects are what
 * causes the program state to change as the game unfolds. The
 * datastructures that are being manipulated are the same ones that
 * are serialized and saved in the savefiles; listed in the GLOBALS
 * section
 */

/******************************
 * IWANNAFLY (working title)  *
 * Top-down 3D Rogue-like     *
 * Game engine with C API     *
 * using NCurses, with        *
 * extensions in Perl         *
 ******************************/

/* Hey, you. yeah, you. who do you think I'm talking to; the mouse?
 *
 * you found the seeecret extended documentation, aka the commentated
 * source code! the sorce code's witty comments are intended to supplement
 * other documentation, as well as give a deeper understanding of the
 * program because, ya'know, source code.
 *
 * The engine provides the C libraries and Perl modules/scripts needed to write a game.
 *
 * a game using the engine should provide the following:
 * - A newgame initializer perl script
 * - Any shared resources needed by events
 *	the resource files MUST follow the following naming conventions:
 *	- .pl for a perl script
 *	- .pm for a perl module
 *	- .so for a shared object
 *	- .hex or .hex## for packed unsigned byte arrays, where ## is a power of 8
 *	- .bin or .bin## for packed signed byte arrays, where ## is a power of 8
 *	- .r8 for a room's tilemap
 *	- .json for a JSON file
 *	- .dumper for a Data::Dumper file
 *	- .tsv or .tab for tab seperated values
 *	- .csv for comma seperated values (structs)
 *	- .ans for a line-seperated record
 *	- .txt for a plaintext block of text
 *	- .nfo for an ansi escaped block of text
 *
 * enviromental requirements:
 * - UTF-8 terminal of at least 24*80 characters
 *	"Fixed" font is recommended (specifically because
 *		it is a raster font; monospaced raster fonts are more uniform in width than the majority of vector so-called "monospaced" fonts;
 *		it is unicode, having a wide range of characters; and
 *		it is extreamly common, being the default font for the linux console, xterm, and urxvt)
 * - ANSI SGR escape codes and 16 colors outside of NCurses
 *	The engine will recognise the term enviroment and can sent xterm-style OSC strings if they are supported as well
 * - NCurses with support for A_BOLD, A_ITALIC, A_UNDERLINE, A_DIM, A_BLINK, A_REVERSE, A_INVIS, 8 colors, and 64 color pairs
 * - Full Keyboard
 *	(most keyboard layouts with all ASCII characters *should*
 *	work, but only QWERTY (US-ANSI) was used in design because
 *	I don't have access to any others, so at best controls may
 *	be strange on them.
 *	want to eventually guaruntee support for other keymappings;
 *	not just for other QWERTY layouts, but also for QWERTZ, AZERTY,
 *	and Dvorak, by request and/or the ability to remap keys
 *	by dotfiles.)
 *
 * XTerm is the recommended X Terminal Emulator (the primary one used in testing),
 * but the raw TTY Console set up in UTF8 locale will work just as well,
 * maybe even better if memory is an issue. At first glance, A Vt241 or Vt3*0
 * seem to meet all the requirements, but note: they predate the invention of unicode.
 * 
 * Controls:
 * - number keys move in xy
 * - + or - followed by a number move in xyz
 * - < > strafe
 * - backspace retreats (winged creatures also take flight)
 * - spacebar advances
 * - ? turns around
 * - tab lunges
 * - arrow keys, page up, page down, render a flat orthographic projection looking in that direction (free action)
 *	When in multiview mode:
 *	only visable tiles are rendered, other tiles are skipped instead of being rendered blinky.
 *	- number keys are indexed to camera, i.e. if facing west, 8 moves west and 2 moves east.
 *	- : look at a tile.
 * - home renders a top-down perspective at a -45 degree angle from the z axis,
 *	culling the first layer which obstructs the player from view and above (free action)
 * - end renders only the plane including the player. takes a slice perpindicular to the camera. (free action)
 * - 5 idles
 * - Insert toggles wings and 'z's
 * - Delete toggles shadows
 * - F1 shows sense trouble. (free action)
 * - F2 shows sense alignment. (free action)
 * - F3 shows see invisible. (free action)
 * - F4 shows the direction entities are facing (free action)
 * - F5 shows the normal view (free action)
 * - . pick up items
 * - \ initiates command entry. free action itself, but most commands are not.
 * more tbd
 *
 * new saved worlds may be generated by a perl script, which would call the system's tar near the end of execution.
 *
 * depending on RAM or Disk usage of the final program, it may be necissary
 * to run early versions in the system console to prevent resource starvation,
 * or to use a dedicated memory stick for the save files for the same reason.
 * if such requirements arise, they will be considered a severe flaw and work
 * will focus on fixing them as soon as possible.
 *
 * commands are implemented by a Perl::Safe read,exec loop
 *
 * This program is divided into 3 layers:
 *
 * the API layer is the part that provides functions to help with events.
 *	this is the only part you should need to know to compile your own
 *	games that can get fairly complex. these alse include the internal
 *	utilitys for character encoding conversion, input buffering, room
 *	generation and pathfinding algorithems, dice, warping, dying, error,
 *	and the internal implementation of cat.
 *
 * while the API functions have a simple enough calling convention,
 * there is no garuntee that the code underneath is not hundreds of lines long.
 * the sequence to bring the engine up is:
 *
 * termcheck()
 * enginesplash(name of game,game version,story revision)
 * <your startup stuff here>
 * FIXCURSES
 * <more of your startup stuff here>
 * promptload()
 * engineloop()
 *
 * autogeneration of newgame initializers is pending; mainly because no newgame initializer exists to model one off yet.
 *
 * the middle layer, or the guts, is where the engine actually happens, and
 *	it isn't pretty. if you want to change how the game works,
 *	it's going to get messy. this is where the functions for
 *	the RPG system itself, loading and saving, turns, shadows,
 *	3D rendering, and room changing are placed. these should not
 *	usually called directly by events, only by other builtin
 *	functions; some are only called by main.
 *
 * the backend consists of shims between generalized internal representations of
 *	a thing, and the actual way that a library or driver expects it to be
 *	formatted. the following are/will be considered part of this layer:
 *	- anything underneath a call to a parser
 *	- what goes on inside of the midi threads
 *	- the code underneath the savefile handling calls
 *
 * The API should always be backwards-compatable with all versions, from beta to doomsday.
 * The Guts may have breaking changes between MAJOR versions, but not otherwise.
 * The Backend depends on things beyond my control, and should be considered non-dependable.
 *	special cases should be noted, that the savefile format and language version have
 *	their own versioning system. this still may be broken if the flex-yacc or
 *	compression libraries of the build enviroment are changed from expectations,
 *	but is a good start.
 *
 * the goal of all things regarding RNG will not be cryptographic security;
 * contrarawise, an option to manually seed will be added so that
 * an exact game may be repeated. when perl is called, C's rand will
 * be used as the argument to perl's srand via XS.
 *
 * At present, communication between Perl and C is expected to use
 * controlled heap leaks, via xs. This has a potential to create real
 * memory leaks and is less than ideal, but is a quick kludge solution
 * to bypass C scope and thread safety in order to emulate a memory
 * structure more ideal for the scope of the game, namely the flat layouts
 * of ancient video game consoles. the Perl-side API has all the same
 * tools given to it as are required by the C-side API, including malloc
 * and free, to facilitate this. A side effect of this memory organization
 * choice is that YOU MUST COLLECT (most of) YOUR OWN GARBAGE with free().
 * in Perl, free may or may not be eventually implemented as a method as
 * well as a first-class sub.
 *
 * a nonstructured language will be provided for defining midi streams
 * in a human readable format.
 *
 * At some point in the far future, once the engine has reached Beta,
 * a complementery Tileset version of the engine will be created using
 * the X Toolkit, XPixMap, and the Athena Widgets, while retaining the
 * mostly the same API.
 *
 * A version targeting the upcoming Atari VCS may be contemplated
 *
 * GPLv2 or later unless noted.
 * Perl code dual-liscensed with the Artistic Liscense unless noted.
 */

/**standard libraries**/
#ifndef _XOPEN_SOURCE_EXTENDED
#define _XOPEN_SOURCE_EXTENDED
#endif
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#define SQRT3 1.732050807568877293528
#include <limits.h>
#include <time.h>
#include <string.h>
#include <ctype.h>
#include <uchar.h>
#include <dlfcn.h>

/**system libraries**/
#include <unistd.h>
#include <signal.h>
#include <locale.h>
//#include <regex.h>
//#include <glob.h>
//#include <sys/types.h>
//#include <sys/ioctl.h>
//#include <fcntl.h>
//#include <sys/stat.h>
//#include <errno.h>

/**compression libraries**/
#include <libtar.h>
#include <zlib.h>
#include <libbz2.h>

/**perl libraries**/
#define PERL_NO_GET_CONTEXT
#include <EXTERN.h>
#include <perl.h>

/**ncurses libraries**/
#include <ncursesw/ncurses.h>
//#include <menu.h>
/**curses libforms**/
//#include <forms.h>

// need to find a MIDI library.

#ifndef __GNUC__
#warning WARNING - for best results, please use a compiler that supports GNU C.
#define __attribute__(X) /**/
#endif

/**local libraries**/
#include "macro.h"
#include "constants.h"

mvaddch16(int x,int y,char16_t raw,attr_t attrs) {
const wchar_t wch = raw;
attrset(attrs);
mvaddnwstr(x,y,&wch,1);
}

addch16(char16_t raw,attr_t attrs) {
const wchar_t wch = raw;
attrset(attrs);
addnwstr(&wch,1);
}

/* some output modes that will be used:
 *
 * using narrow characters with printw or addch
 * using wide characters with these functions
 * setting attributes with attrset, attron, attroff, and chgat
 *	uses A_DIM, A_BOLD, A_ITALIC, A_UNDERLINE, A_REVERSE, A_BLINK, A_INVIS,
 *	and 64 color pairs made from 8 colors
 * using the above custom functions to put wide characters on
 * the screen using addstr, addnstr, addwstr, addnwstr to print strings
 * pausing curses and dumping an entire file with printf
 */

/*ENVIROMENTALS*/
char16_t TILDEWIDE
char* TERM

/* ɛ⃓ will be used for "and", the conjunction, in comments where logical && would give a meaning that
 * could be validly, but incompatibly, interpreted as compleatly different from what is intended.
 * if confusion arises from or, similar mesures will be implemented for it, too.
 */

/* the 3D version of Iwannafly started off as a general RT-RPG library that
 * then became narrowed to a specific game. this version was originally
 * supposed to be the same game reworked for ncurses,
 * but is now becoming closer to the general library concept,
 * similar to a RPG ruleset that allows creation of
 * your own setting and plot (you know the one).
 * a default one will be provided, however.
 */

//anonomous pointers, could be anything. they're anonomous.
struct drum {
	char data[DRUMSIZE]
	short top
	}

void* drumalloc (ptr,amount)
struct drum ptr
size_t amount
{
if ((ptr->top + amount) ≤ (DRUMSIZE)) {
	void* output = ptr->data[ptr->top]
	ptr->top += amount
	return output
	}
else {return NULL}
}

drumpop (ptr,amount)
struct drum ptr
size_t amount
{
ptr->top = MAX(ptr->top - amount,0)
}

setlocale(LC_ALL, "");

initialize() {
	initscr();
	cbreak();
	noecho();
	start_color();
	keypad(stdscr, true);
	}

for (uchar bg = 0; bg < BGCOLORS; bg++) {
	for (uchar fg = 0; fg < FGCOLORS; fg++) {
		init_pair((BACKGROUND * bg) + fg, fg, bg);
		}
	}

char16_t setwidetilde() {
forever {
	move(12,4); printw("is this tilde between the lines? (y,n)")
	
	mvaddch(14,14,"-")
	mvaddch(14,15,"-")
	mvaddch(14,16,"~")
	mvaddch(14,17,"-")
	mvaddch(14,18,"-")
	
	char got = getch()
	
	switch (got) : {
		case 'y' : return '~';
		case 'n' : return = 0x223C;
		default : printf("\a"); fflush(stdout); break;
		}
	}
}

struct stringlistyp {
(self) *prev
(self) *next
char* text
}
/* used to store a list of strings
 * may be from a data object, or
 * stored in a tsv
 */

struct singlestringlistyp {
(self) * next
char * text
}

struct filelinetyp {
(self) *prev
(self) *next
ushort lineno
char* text
}
// used by the line editor

struct singlestringlistyp {
(self) * next
ushort lineno
char * text
}

/*blackbox*/loading()
	/* clears screen
	 * prints "  LOADING..." on line 13
	 * prints a hint on line 22.
	 *   hints are stored in a struct
	 * rotates the hints wheel by 1 node
	 */

uint util__roll (num,side,low)
uchar num;	//number of dice to roll
uchar side;	//sides on each die
bool low;	//low number on each die
{
uint accum;
uint tmp;
for (uchar n = 0;n<num;n++) {
	tmp = (rand() % side) + low;
	accum += tmp;
	}
return accum;
}
//XdN is (X,N,0), XDN is (X,N,1)

short util__bonus (num)
uchar num;
{
short accum;
char tmp;
for (uchar n = 0;n<num;n++) {
	tmp = (rand() % 3) - 1;
	accum += tmp;
	}
return accum;
}

#define util__flip (rand() % 2)

/*implicit*/file_cat (path)
const char *path;
{
FILE *openfile = fopen(path,"r");
int lines;
if (openfile == NULL) {
	ERRORGRAPHIC(OK,1,sizeof(char*),"Could not open file: %s",path);
	return ERR;
	}
char tmpbuffer[BUFFER_MAX];
BREAKCURSES
for (bool n = true;n;) {
	if (fgets(tmpbuffer,BUFFER_MAX,openfile) == NULL) {
		n = false;
		} else {
		printf(tmpbuffer);fflush(stdout);
		lines++;
		}
	}
FIXCURSES
fclose(openfile);
return lines;
}

// depricated
/*x should also output __FILE__ ɛ⃓ __LINE__, which will likely be the program's version of
 *x undecipherable hex codes to anyone not extreamly fammiliar with the source. less severe
 *x errors will prompt for [Q]uit, [A]bort, or [Z] continue. more severe ones will prompt
 *x [Q]uit, [A]bort, [Z] restart. When other keyboard layout options are supported, QAZ will
 *x be replaced with the left column of letters (under 1). replacements for QAZ might be:
 *x QAY, AQW, "A:, FUJ. if Q or A are present in this group, they will be [Q]uit ɛ⃓ [A]bort,
 *x swapping places with the other option. otherwise, the quit-abort-option3 order will be kept.
 */

struct blitimgcolor {
	attr_t attr[6];
	char ** img[16];
	}
	/*	|	0	[0]	[1]	[2]	attr
	 *	0	[0]	[1]	[2]	[3]	img
	 *	[3]	[4]	[5]	[6]	[7]
	 *	[4]	[8]	[9]	[10]	[11]
	 *	[5]	[12]	[13]	[14]	[15]
	 *
	 * the first row and column never have any attributes
	 * NULL img pointers are skipped, rather than acting as sentries
	 */

struct drawvector {
	ucoord3 a;
	ucoord3 b;
	char16_t ch;	// if set to \0, then assume that attr also holds an ascii symbol and switch accordingly.
	attr_t attr;
	ushort uslp;	/* how long to delay between each character; calls usleep.
			 * there is already a miniscule delay for the stepwise pathfinder calculation
			 */
	}

/* note: make function where some glyph is swept to some azimuth
 * ( char16_t unichar, attr_t attrib, uchar az ¿, float dist?, ushort uslp)
 */

/**GLOBALS**/
playertyp PLAYER
roomstackholder ROOMSTACK
#define ROOM ROOMSTACK.swapin
#define ROOM_NOT_NULL(X,Y) ((ROOM != NULL) ? X : Y)
#define WORLD	ROOM_NOT_NULL( ROOM->latlon , (latlontyp){0,0,0,0,0,0} )
#define CEILING	ROOM_NOT_NULL( ROOM->ceiling , MAX_Z )
planestackholder PLANESTACK
uint64_t TURN
nibbles TIMER
char ALARM = -1
turntyp DATE
uchar ROOMTURN
uchar ELECOLLECT[8]	//elemental collectibles
uchar QUESTCOLLECT[3]	//light/dark/entropy collectibles
uint64_t KILLS
char* SAVEPATH
followtype *FOLLOW_ptr	//pursuers, i.e. paid assasins, ninjas, the reaper...
eventtyp *EVNT_ptr	//FOO_ptr refers to the doubly linked list's head. the tail is FOO_ptr->prev. FOO_ptr->prev->next is always NULL.
placetyp *PLACE_ptr
stringlistyp *HINT_ptr
eventdatastack_ele *EVSTACK_ptr
qglobobj * GLOBOBJ_ptr
qglobev * GLOBEV_ptr
bitfield globools
#define NEW globools.a
#define FIRST globools.b
#define DAY globools.c
#define NIGHT globools.d
#define MORN globools.w
#define NOON globools.x
#define EVE globools.y
#define MIDNIT globools.z
/*end GLOBALS*/

struct turntyp:
uchar sec : 6
uchar min : 6
uchar hour : 5
uchar day : 5
uchar weekday : 3
uchar month : 4
ushort year : 11

bool ticktock() {
TURN++;
TIMER.lo++;
if ((TIMER.lo == TIMER.hi) && (ALARM ≥ 0)) {ALARM++}
if (ROOMTURN < 200) {ROOMTURN++;}
DATE.sec += 6;
if (DATE.sec ≥ 60) {
	DATE.sec = 0;
	DATE.min++;
	if (DATE.min ≥ 60) {
		DATE.min = 0;
		DATE.hour++;
		if (DATE.hour ≥ 24) {
			DATE.hour = 0;
			DATE.weekday++
			if (DATE.weekday ≥ 7) {DATE.weekday = 0;}
			DATE.day++;
			if (DATE.day ≥ 30) {
				DATE.day = 0;
				DATE.month++;
				if (DATE.month ≥ 12) {
					DATE.month = 0;
					DATE.year++;
					if (!(DATE.year)) {return true}
					else {return false}
				}
			}
		}
	}

MIDNIT = ((DATE.hour == 0) && !(DATE.min))
MORN = ((DATE.hour == 6) && !(DATE.min))
NOON = ((DATE.hour == 12) && !(DATE.min))
EVE = ((DATE.hour == 18) && !(DATE.min))
DAY = ((6 ≤ DATE.hour) && (DATE.hour < 18))
NIGHT = ((DATE.hour < 6) || (18 ≤ DATE.hour))
}

//projection, →x ↓y ↑z

typedef uchar ucoord3[3]
typedef uchar ucoord2[2]
typedef char scoord3[3]
typedef char scoord2[2]
//sentinal for an array of coord3 is {0,0,-1}

struct lightblit {
ucoord2 pos
ucoord2 size
ushort * mask
}

struct agetyp {
unsigned chrono : 16
signed bio : 8	//entity dies on overflow
unsigned rem : 8
}

struct mapcoord3:
unsigned x : 6
unsigned y : 5
unsigned z : 4
bool last : 1

struct nibbles {
unsigned lo : 4
unsigned hi : 4
}

struct racetyp {
intptr_t race : 8
intptr_t table : 4
unsigned meta : 4
	// 00-0-F is nul
}

typedef float vector2[2]
typedef float vector3[3]
/* used for velocity, a parameter that holds
 * motion that carries accross turns. this motion
 * is not always cleared after being done; horizontal
 * velocity persists until a tile with friction is
 * encountered, while downwards vertical velocity 
 * accumulates and persists until the ground is encountered.
 */

struct ray_vfx_typ {
(self) * prev
(self) * next
ucoord3 p
uchar dir	//must be a valid octant
float mag
char16_t c
attr_t a
}

struct polar {
unsigned az : 3	//azimuth
signed el : 2	//elevation
signed slope : 3	//negative is inverse slope, most negative is undefined. defines a cone.
unsigned r : 5	//radius
bool omni : 1	//omnidirectional
bool not : 1	//invert the mask defined by slope
bool behind : 1	//EQUATOR/2 degrees are added to azimuth
}
/* amoungst other uses, defines the cone of vision
 * and used to generate magic beams
 *
 * for all azimuths:
 *
 * 701
 * 6 2
 * 543
 *
 * for all elevations:
 *
 * +1
 *  0  ?-2?
 * -1
 */

/*
 * notetyp {
 * (self) next
 * unsigned evnt : 4
 * unsigned chan : 4
 * unsigned note : 8
 * unsigned velo : 8
 * clock_t delay
 * }
 * for interfacing with a raw midi library
 *
 * delay is not part of the midi data, rather,
 * it tells how long to wait until sending the
 * next packet. set to 0 to send immidiately.
 */

//some specific use cases require spheres. these are simply numeric types.

struct diceodds:
unsigned num : 3
unsigned side : 5
unsigned tobeat : 8

struct planetyp {
unsigned rho : 2
unsigned az : 3
signed el : 2
char : 0
}

struct latlontyp {
unsigned dep : 8
unsigned lat : 8
unsigned lon : 9
unsigned rho : 2	//are you plane shifted?
unsigned az : 3
signed el : 2
}
/* in-game altitude is given as the distance from layer 100
 *
 * rho 0 is the prime plane
 * rho 1 are the elemental planes
 * rho 2 are afterlives
 * rho 3 can be used for areas that are meant to not show up on a map.
 *				(said map is WIP)
 *
 * az	elemental	afterlife	corrilation
 * 0	water		neutral good	nurturer
 * 1	ice		chaotic good	the ends justify the means
 * 2	air		chaotic neutral	princess stealing
 * 3	electricity	chaotic evil	force lightning
 * 4	fire		neutral evil	obviously
 * 5	metal		lawful evil	greed
 * 6	earth		lawful neutral	stubborn
 * 7	trees		lawful good	knowladge
 *
 * az rotates by 45 degree steps and el by 90 degree steps.
 * a nonzero el causes az to gimbal lock.
 * also best not to think about where exactly -2 is pointing.
 *
 * el	"		"		"
 * +1	light		true neutral	enlightenment
 * -1	darkness	uncomitted	meh, I'll think of one later
 * -2	entropy		oathbreakers	abandon all hope ye who enter here
 *
 * errors related to this section may generate one of 2 errors:
 * "fell off the edge of the world", N1=±lat,N2=±lon
 * "froze to death on pluto", N1=+az,N2=±el
 *
 * a room stack exists that keeps a number of rooms loaded
 * if a room is not on the stack, it is loaded from the save file and
 * pushed to the stack. this may cause the stack to intentionally drop
 * the room at the bottom to prevent eating too much ram. if the file
 * does not yet exist, the room is generated according to a dispatch table
 * in a shared object. if the function and file are both NULL and the
 * room is being entered, a lost in space death is called. if only the
 * function is NULL, the file is executed in perl. if only the file is
 * NULL, no shared objects are loaded before the function is called. 
 *
 * a swap array keeps track of gating between the 23 major planes,
 * saving the player's position, but not keeping the room loaded.
 */

struct placetyp {
(self) *prev
(self) *next
eventdata eventident
char* name
latlontyp latlon
ucoord3 pos
}

struct moneytyp {
unsigned gp : 17
unsigned cp : 7
}

typedef short trackaligntyp[2]
/* neutral is the area between -10,000 and 10,000
 * alignments can be between -30,000 and 30,000
 * actions, quests, and being polymorphed into
 * certain monsters can alter your alignment
 * [0] is good/evil, [1] is lawful/chaotic
 */

struct aligntyp:
good : b1
evil : b1
law : b1
chaos : b1
nogood : b1
noevil : b1
nolaw : b1
nochaos : b1
/* used as a mask.
 * starting alignment must be one of the high nibble (those bit flags | true neutral if more than 1 is selected.)
 * alignment may NEVER enter any of the low nibble, marked "no"
 *
 * there are other ways that alignment masks may be specified,
 * all of which have finer grained control.
 */

struct bitfield:
a : 1
b : 1
c : 1
d : 1
w : 1
x : 1
y : 1
z : 1

char* itemstabs[256] //stuff that doesn't go anywhere else; i.e. arrows, keys, quest items
char* spellstabs[256] //spells
char* weapstabs[256] //weapons
char* armstabs[256] //armor
char* shldstabs[256] //shield, cannon, greeves
char* baubstabs[256] //rings, amulets, bracelets, tiaras
miscitembasetyp* itemtable[256]
basespelltyp* spelltable[256]
baseweaptyp* weaptable[256]
basearmortyp* armtable[256]
baseshldtyp* shldtable[256]
baubtyp* baubtable[256]

char* legendstabs[24] = {"truthseeker"/*bow*/,"sword of justice","excalibur","thunderbolt","sickle of chaos"/*+drain*/,"stormbringer"/*+drain*/,"devilfork"/*+fire*/,"partisen of tyrants"/*+coin stealing*/,"deathscyth"/*+vampiric drain*/,"sunray"/*spear + solar flare*/,"nightedge"/*sword + moonbeam*/,"staff of merlin"/*staff of magic missile*/,"firebrand"/*burn*/,"tesla's mace"/*+spark*/,"stormgale"/*bow*/,"frostpike"/*+frostbite*/,"trident of the seas"/*+tsunami*/,"staff of the forest"/*staff of animante kudzu*/,"quake hammer","bow of fire","bow of ice","bow of darkness","bow of void","bow of dawn"};
legendtyp* legendtable[24];

char* psystabs[8] = {"detect alignment","charm","psychic lock","sleep","mind blast","passify","unhinge","terrorize"}

/*blackbox*/psionic(id)
uchar id
//switch case for each psionic ability

struct multiclasstyp:
(self) *prev
(self) *next
classtyp class
magictyp element

struct classobjtyp:
classtyp class
magictyp element

struct classtyp {
unsigned role : 2
unsigned class : 3
unsigned align : 9
unsigned mastery : 2
}

char* roguestabs[8] = {"changeling","rogue","thief","pirate","ninja","assasin","tourist","ronan"}
char* fighterstabs[8] = {"fighter","knight","paladin","valkyrie","viking","samuri","ranger","monk"}
char* magicuserstabs[8] = {"magic-user","wizard","illusionist","enchanter","black mage","red mage","psion","necromancer"}
char* healerstabs[8] = {"healer","cleric","priest","druid","alchemist","scholar","white mage","seer"}

paffect	classtable[4][8]

struct montableptr {
char *nametable[256]
basentyp *ptrtable[256]
}

struct montableptr montable[16];

init__montable() {
	montable[0] = {mon1stabs,mon1table};
	montable[1] = {mon2stabs,mon2table};
	montable[2] = {mon3stabs,mon3table};
	END

char* mon1stabs[256] =
{"human",	"elf",	"dwarf",	"gnome",	"hobbit",	"half elf",	"drow",	"siren",	"half orc",	"half dragon",	/*half celestial*/,	"tiefling",	"half air elemental",	"half water elemental",	"half earth elemental",	"half fire elemental",
"merfolk",	"seaelf",	"satyr",	"fairy",	"pixie",	"naiad",	"naga",	"dryad",	"orc",	"kobald",	"centaur",	"sphinx",	"half electric elemental",	"half ice elemental",	"half nature elemental",	"half metal elemental",

basentyp* mon1table[256]
/* contains all polymorphable monsters, of type BASENTYPE.
 * all C0 controls should be valid starting races, or left empty,
 * any polymorphable race can BECOME your base race...
 * 
 * if you become polylocked to a non-player race, your class will be removed.
 * becoming polylocked to one of the C0 entrys has no negative effects.
 * commands can change your base race without negative side effects
 */

char *mon2stabs[256] = {"grue",	"newt",
basentyp* mon2table[256]

char *mon3stabs[256] = {"rook",	"raven",	"jackdaw",
basentyp* mon3table[256]

/* MONSTERS BY LETTER
 * & : horned devil, balrog, jubilix,
 * @ : human, elf, half elf, drow, seaelf, siren,
 * A : angel, astral, ætherial, celestial, archon, half celestial,
 * a : newt, salamander, frog, 
 * B : bear, polar bear, owlbear,
 * b : mockingbird, parkeet, parrot, macaw, cockatoo, songbird, sparrow, starling, jay, magpie, jackdaw,
 * C : satyr, centaur,
 * c : chickatrice, cockatrice, pyrolisk,
 * D : /(△red|↯copper|◬white|*cyan|▽blue|♠green|⍫brown|$gold|☽black|☼silver|∅grey) dragon/,
 * d : hellhound, wolf, dire wolf, dog, fox, cyote,
 * E : <elementals>, stalker,
 * e : floating eye,
 * F : panther, lion, tiger, manticore, cat, lynx, bobcat,
 * f : turkey, rooster, chicken, peacock, duck, goose, swan, gull, dodo,
 * G : ghost, banshee, revenent, barrow wight,
 * g : gremlin, gargoyle, winged gargoyle,
 * H : giant, cyclops,
 * h : dwarf, gnome, hobbit,
 * I : /giant (ant|roach|scarab|wasp|scorpion|spider)/
 * i : ant, roach, scarab, wasp, scorpion, spider, firefly,
 * J : djinn,
 * j : gelatinous cube, green slime, brown pudding, black pudding, ocher jelly, spotted jelly, blue jelly,
 * K : kracken, giant squid, octopus,
 * k : kobold,
 * L : skeleton, lich,
 * l : leprachaun,
 * M : elephant, mammoth, rhino,
 * m : <mummies>
 * N : naga, half dragon,
 * n : merfolk, naiad, dryad, sea siren,
 * O : orc, half orc, uruk-hai, ogre,
 * o : ostrich, emu, moa,
 * P : dolphin, narwhal, orca, beluga,
 * p : penguin, puffin, auk, albatross,
 * Q : fiend, drider, erinys, kerr, harpy, tiefling,
 * q : quasit, imp, homunculus,
 * R : eagle, falcon, owl, kite, vulture, phoenix, raven, rook, crow,
 * r : mouse, rat, dire rat, raccoon, badger, opossum, platypus, groundhog, 
 * S : shark, stingray, swordfish, barracuda, eel,
 * s : copperhead, cobra, rattlesnake, python, boa, viper, coral snake, king snake, anaconda,
 * T : lurker above, trapper, wallmaster, rust monster,
 * t : troll,
 * U : umber hulk,
 * u : unicorn, pegasus, griphon, hippogriph,
 * V : vampire, mind flayer, medusa, tengu,
 * v : bat,
 * W : wyrm, great wyrm, hydra,
 * w : purple worm, nightcrawler,
 * X : velociraptor, tyrannasaurus,
 * x : monitor, alligator, crocodile,
 * Y : yeti, bigfoot,
 * y : ape, monkey, gorilla, chimp, leamur,
 * Z : <zombies>
 * = : [spoiler]
 * {}: /(flesh|straw|clay|stone|glass|paper|leather) golem/, /(gold|copper|finite-state) automaton/, chest monster,
 * ? : mystery person
 * «»: bass, trout, salmon, tuna, carp, pike,
 * × : lizard, geko, skink, 
 * ÷ : lobster, crab, shrimp,
 * £ : justice. (strictly-lawful neutral)
 * ¶ : da fuzz. (lawful neutral)
 * Ω : [spoiler]
 * ⑄ : retribution. (chaotic neutral)
 * ∀ : ox, cow, pig, buffalo, goat, sheep,
 * ∄ : fear itself. (neutral somewhat-evil)
 * ⊞ : lichen, moss, green mold, slime mold, black mold
 * ∈ : <half elementals>
 * ∞ : grue.
 * ☠ : death. (true neutral)
 * ♞ : quarterhorse, draft horse, miniature horse, zebra, nightmare,
 * ⏍ : hungry chest, chest monster,
 *//*
 * ≷?≶ : feathery wings
 * <?> : batwings
 * >?< : insect wings
 * for some races, wings disappear when not flying; for others they are permenantly visable
 *
 * z : asleep
 *
 * these are rendered before (under) entities, but after tiles on each slice.
 */

struct the8stats:	//8* 5D6
stren : u5
psy : u5
dex : u5
con : u5
fort : u5
intl : u5
wis : u5
bluff : u5

struct conlangtype:
unsigned id : 5
bool r : 1
bool w : 1
bool x : 1	//can be spoken

char* conlangtab[32] = {"common language","middle elvish","old elvish","dwarvish", "gnomish","gothic","orkish","draconic", "fey","celestic","demonic","blackspeech", "skyspeak","waterspeak","earthspeak","firespeak",
	"thieves cant",/*?*/,/*?*/,/*?*/, /*?*/,/*?*/,/*?*/,/*?*/, /*?*/,/*?*/,/*?*/,/*?*/, "electric","icespeak","treespeak","metallic"}

/* note: if the compiler complains about mixing tightly packed and loosly packed fields,
 * the tightly packed ones will be split off into a seperate type with "_bitfield" affixed to
 * the name, which will be placed in a consistantly-named member at the end of the struct.
 *
 * possible names:	1."β"	2."_b"
 */

struct playertyp:
classobjtyp class
multiclasstyp *MULTICLASS
agetyp age
struct racetyp baserace[2]
struct racetyp polyrace
shiftertyp polycounter
ucoord3 pos
polar facing
vector3 velo
float carryover	//leftover moves; never exceeds 2
paffectyp permenent
effectyp fromequip
scoord2 align
ushort hp	//they're fun and easy to...wait
ushort mp
uchar air
ushort uptime
uint32_t xp
uchar lvl
short food
moneytyp gold
heldobjtyp *lang_ptr
heldobjtyp *spell_ptr
heldobjtyp *bag_ptr
bitfield psyattack
subobjtyp weap_left	//weapon
subobjtyp weap_right	//weapon
subobjtyp shield	//shld
subobjtyp bow	//weapon
subobjtyp armor	//armor
subobjtyp cape	//armor
oneobjtyp helm	//any item
subobjtyp gloves	//armor
subobjtyp cannon	//shld
subobjtyp boots	//armor
subobjtyp greev	//shld
subobjtyp amul	//baub
subobjtyp ringl	//baub
subobjtyp ringr	//baub
subobjtyp wristl	//baub
subobjtyp wristr	//baub

enum equipenum = {ENUM_WEAP_LEFT,ENUM_WEAP_RIGHT,ENUM_SHIELD_ENUM_BOW,ENUM_ARMOR,ENUM_CAPE,ENUM_HELM,
ENUM_GLOVES,ENUM_CANNON,ENUM_BOOTS,ENUM_GREEV,ENUM_AMUL,ENUM_RING_LEFT,ENUM_RING_RIGHT,ENUM_WRIST_LEFT,
ENUM_WRIST_RIGHT}

/*blackbox*/update_player
/* resets .fromequip , then iterates through the entire equipment list to regenerate it.
 * must be called every time equipment is changed to ensure that it is up to date
 * effects in .permenent can only be removed by finding something that affects the opposite change
 * changes to your starting alignment or role are generally rare and disasterous, as they represent
 * the corruption of the character in some way. changes to your race may also be inconvenient,
 * but not necissarily bad. (I.E. late game events may change a player into a powerful
 * non-starting race as part of the story, such as a drider, full elemental, or dragon.)
 *
 * this may be done automatically when you sleep.
 */

/*blackbox*/inventsort
/* compresses stackable items into stacks, sorts items by objid and itemid.
 * more computationally expensive than update_player.
 */

/*blackbox*/force_global
/* forces some queued globals to be loaded. takes a very long time, but can
 * sometimes be necissary if the global buffer is starving the system.
 */

struct basentyp:
aligntyp alignmask
aggrotyp aggro	//here, shiftable denotes a monster's aggro state is locked. also gives the value that patience is set to when a monster calms down, the value that cooldown is set to when it is angered, and the default AI.
paffectyp base
venomtyp venom
uchar spd	//distance calculations use M_SQRT2 and local SQRT3 for diagonals
uchar hplvl
uchar mplvl
uchar xplvl
uchar airmax	//how long you can hold your breath
struct conlangtyp lang0
struct conlangtyp lang1
uchar vocal[4]
_8BITPTR spell[4]
bitfield psyattack
char16_t sprite
attr_t attrs
char16_t altsprite
attr_t altattrs
bool mindless : 1
bool shadow : 1
bool incoporeal : 1
unsigned natural_element : 8
signed size : 2
signed wingtyp : 2 // 1 = fancy, -1 = <>, -2 = ><
bool permwings : 1
unsigned age_rate : 8
/* entitys of size 1 or -2 cannot use armor.
 * entitys of larger size automaticly win grapples.
 * entitys of 2 sizes smaller can be picked up and thrown.
 * entitys of size 1 can instakill entitys of size -2. squish.
 * size 1: dragon, size 0: human, size -1: dwarf, size -2: pixie
 */

struct aggrotyp:
bool unhinged : 1
unsigned patience : 3
unsigned ai_type : 4
unsigned anger : 8

struct enttyp:
(self) *prev
(self) *next
npctyp * depth
agetyp age
classobjtyp class
aggrotyp aggro
struct racetyp race[2]
ucoord3 pos
polar facing
vector3 velo
float carryover
paffectyp paffect
effectyp effect
ushort hp
uchar air
uint32_t xp
uchar lvl
moneytyp gold
oneobjtyp loot
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
oneobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct npctyp:
(self) *prev
(self) *next
ucoord3 * path
conlangtyp lang
char * describe
char * gibber
char ** lines	// heap array of pointers

struct followtyp:
(self) * prev
(self) * next
npctyp * depth
agetyp age
classobjtyp class
aggrotyp aggro
struct racetyp baserace[2]
struct racetyp polyrace
shiftertyp polycounter
ucoord3 pos
polar facing
vector3 velo
float carryover
paffectyp permenent
effectyp fromequip
scoord2 align
ushort hp
ushort mp
uchar air
uint32_t xp
uchar lvl
short food
moneytyp gold
heldobjtyp *spell_ptr
bitfield psyattack
oneobjtyp holding
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
oneobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct spawntyp:
npctyp * depth
classobjtyp class
aggrotyp aggro
struct racetyp race
paffectyp paffect
effectyp effect
oneobjtyp loot
subobjtyp weap_left
subobjtyp weap_right
subobjtyp shield
subobjtyp bow
subobjtyp armor
subobjtyp cape
oneobjtyp helm
subobjtyp gloves
subobjtyp cannon
subobjtyp boots
subobjtyp greev
subobjtyp amul
subobjtyp ringl
subobjtyp ringr
subobjtyp wristl
subobjtyp wristr

struct oneobjtyp {
objid type
void* data
}

struct heldobjtyp:
(self) *prev
(self) *next
uchar stack //stack+1 items are present. lumping them together is a complicated operation. 
objid type
void* data

struct subobjtyp:
unsigned itemid : 8
bool cursed : 1
bool oxide : 1
bool burned : 1
signed bonus : 5
intptr_t metadata : 8 //secondary _8bitPtr for legendary objects

struct magictyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
unsigned lde : 3
bool planer : 1

struct shiftertyp {
unsigned polytimer : 8	//time remaining in the current polymorph. if non-zero, polyrace is used instead of baserace.
unsigned polydepth : 4	//polymorphing more than 10 times without returning to your base form first change your base form to the 15th one
unsigned polycount : 4	//repeating the same polymorph 10 times will make it permenant
unsigned altertimer : 8	//time remaining in the current alteration.
unsigned gills : 4	//using an alteration spell, including intrensics from polymorph spells, 10 times will make them permenent.
unsigned lungs : 4	//these counters can be reset by rest or spells
unsigned wings : 4
unsigned tail : 4
unsigned claws : 4
unsigned fangs : 4
bodytyp alterations	//keeps track of changes. if a change becomes permenent, it is moved to paffect.
}
/* non-player, non-follower entitys do not have this field,
 * and any polymorph or alteration is permenent. this may be
 * changed in future if memory footprint allows.
 */

struct spelltyp:
intptr_t itemid : 8
diceodds odds
uchar prof

struct basespelltyp:
bool poly : 1
bool self : 1
unsigned lvl : 6
magictyp type
char cost_typ : 2 //0 = at will, 1 = gold, -1 = mp, -2 = hp
unsigned cost_amnt : 6
potiontyp effect
missiletyp delivery
intptr_t polyref : 8

struct psytyp:
signed cost_typ : 2 //0 = at will, 1 = gold, -1 = mp, -2 = hp
unsigned cost_amnt : 6
potiontyp effect
missiletyp delivery

struct missiletyp:
bool psion : 1
bool vamp : 1
unsigned damage : 8
signed recoil : 7
unsigned spread : 2 //0 = line, 1 = narrow (1:3), 2 = wide (1:2), 3 = very wide (1:1)
unsigned splash : 3 //radius of damage on impact
bool spz : 1 //spread and splash in the z plane.
bool dig : 1 
//if (.spread != 0), slope = 4-.spreaad

struct baseweaptyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool illum : 1
unsigned skill : 3
unsigned damage : 8

legendtyp:
paffectyp magic
symtableref base
symtableref spell
legendflagtyp flags

legendflagtyp:
bool fire : 1
bool air : 1
bool water : 1
bool earth : 1
bool entro : 1
bool light : 1
bool dark : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool warded : 1
bool unbreak : 1
bool infinate : 1
bool spelled : 1
bool vamp : 1
bool drain : 1
bool interest : 1
bool useless : 1
unsigned powermag : 5

struct basearmortyp:
effectyp effect
uchar def
uchar spdef
uchar extfort

struct baseshldtyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool reflect : 1
bool entro : 1
bool light : 1
bool dark : 1
effectyp effect
unsigned def : 8
unsigned spdef : 8

struct bodytyp:
bool gills : 1	//affects breathing underwater
bool wings : 1	//affects flying
bool tail : 1	//affects unarmed attacks, swimming, flying
bool claws : 1	//affects unarmed attacks, writing
bool hoof : 1	//affects walking, swimming, unarmed attacks
bool talon : 1	//affects walking, swimming, unarmed attacks 
bool fangs : 1	//affects unarmed attacks
bool quad : 1	//affects walking, swimming, unarmed attacks
bool nolegs : 1	//affects walking, swimming, unarmed attacks
bool noarms : 1	//affects walking, swimming, unarmed attacks, writing
bool nolungs : 1	//affects breathing above water
bool noswim : 1	//affects swimming
bool atktail : 1	//affects unarmed attacks, swimming, flying
bool atkwing : 1	//affects unarmed attacks, swimming, flying
signed atkbite : 2	//affects unarmed attacks; +1 = swallow, -1 = bite, -2 = bite ɛ⃓ breath

struct venomtyp {
elixtyp claws
elixtyp talon
elixtyp fangs
elixtyp tail
elixtyp passive
}

struct stattyp:
dizzy : u4
psn : u4
prlz : u4
frz : u4
brn : u4
stone : s6
slime : s6
slp : u8
invis : u8
blind : u8
eaten : u8

struct elixtyp:
dizzy : 1
psn : 1
prlz : 1
frz : 1
brn : 1
stone : 1
slp : 1
invis : 1

struct cursetyp:
stattyp type
uchar polytimer
intptr_t poly : 8

struct resistyp:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool stoneproof : 1
bool polyproof : 1
bool sleepproof : 1
bool poisonproof : 1

struct sensetyp:
bool trouble : 1
bool invis : 1
bool infra : 1
bool blind : 1
bool good : 1
bool evil : 1
bool law : 1
bool chaos : 1

struct effectyp:
the8stats eight
bodytyp shape
stattyp stat
resistyp resist
senstyp sense
skilltyp skill
char atk
char spatk
char def
char spdef

struct paffectyp
the8stats eight
bodytyp shape
elixtyp ails_ya
elixtyp curse
resistyp resist
senstyp sense
skilltyp skill
char atk
char spatk
char def
char spdef

struct potiontyp:
bodytyp shape
elixtyp ails_ya
cursetyp curse
resistyp resist
senstyp sense
short hp
short mp
diceodds odds

struct skilltyp:
unsigned sword : 3 //+skill to sword-type weapon attack
unsigned knife : 3 //+skill to knife-type weapon attack
unsigned stave : 3 //+skill to stave-type weapon attack
unsigned spear : 3 //+skill to club-type weapon attack
unsigned whip : 3 //+skill to whip-type weapon range (unused range added to attack)
unsigned club : 2 //+skill to club-type weapon attack
unsigned bow : 4 //+(2 * skill) to bow-type weapon range
unsigned throw : 4 //+(2 * skill) to javalin-type weapon range
unsigned monk : 4 //+(2*skill) to unarmed attack, unlocks more modes of attack.
unsigned shield : 3 //skill in (damage-defense)+abs(damage-defense) chance of blocking
unsigned locks : 3 //1 in 2^(lock.level - (skill)) chance of picking
unsigned caster : 6 //-(skill-1)/4 to casting cost, +(skill-1)/4 to spatk and spdef, unlocks spells, 0 is non-caster
bool swim : 1 //learned in shallow water; may be lost by polymorphing to a form with different locomotion.
bool walk : 1 //learned on land; may be lost by polymorphing to a form with different locomotion.
unsigned fly : 2 //0 = never had wings, 1 = slow falling, 2 = cannot gain altitude, 3 = free flight. lvl1 learned by falling

/* damage = MAX( incoming-defense , 0 )
 *
 * polyshock = base.hplvl - ((poly.hplvl * (util__roll(1,20,1) / 20)) * util__roll(1,3,0))
 * ⎧if n < -HPMAX     : Instakill (deathmessage: miscalculated a crucial equivilant-exchange parameter,hath choose...poorly)
 * ⎪if n = -HPMAX     : Stoning
 * ⎨if -HPMAX < n < 0 : abs(n) Damage (deathmessage: could not withstand the cost of transmutation)
 * ⎪if n = 0          : stun for 1D16 (standardmessage: your mind reels from the transformation...)
 * ⎩if n > 0          : success
 *
 * writing =
 * succeed if 4D6 < dex if !talons, break pen on fail if 1D20 < stren
 * succeed if 6D6 < dex if talons, break pen on fail if coinflip
 * talons can engrave without tools
 */

readtyp:
unsigned locale : 6
bool multiuse : 1
bool scroll : 1
unsigned subject : 2 //0 = cooking, 1 = weapons, 2 = language, 3 = spellcraft
unsigned uses : 6
void* contents

char* wandmaterials[16] = {"oak","ash","yew","honeylocust","silver","bronze","iron","orichalcum","marble","bone","dragon fang","unicorn horn","glass","lead crystal","adamantine","stardust"} //stoning -> marble

wandtyp:
unsigned matter : 4
unsigned uses : 4
intptr_t bound : 8

char* baubmaterials[8] = {"yew","bronze","silver","gold","soapstone","ivory","obsidian","stardust"} //stoning -> soapstone

baubtype :
signed type : 2 //0=ring, 1=bracelet, -1=amulet, -2=tiara
unsigned matter : 3
unsigned color : 3
paffectyp enchnt

struct roomneighbors {
bool north
bool south
bool east
bool west
bool up
bool down
bool upstair
bool downstair
latlontyp north
latlontyp south
latlontyp east
latlontyp west
latlontyp up
latlontyp down
}

struct roomtyp: //top-down display of a 3d space
latlontyp latlon
tileset *hightiles
char* tiledata[][MAX_Y][MAX_X]
unsigned ceiling : 4
unsigned bgcolor : 3
bool visited : 1
shadowmask seen
shadowmask light
collimaptyp collimap
encontyp *encon_ptr
enttyp *ent_ptr
eventtyp *ev_ptr
mapobjtyp *obj_ptr
ray_vfx_typ *ray_ptr
char lightsource	//must be a valid octant
ucoord3 * path_ptr
ucoord2 downstair
ucoord2 upstair
ucoord3 home
struct roomneighbors neighborhood
/* if invalid coords are given for a warp (typically {$FF,$FF}),
 * then the player is dumped at the location indicated by home.
 *
 * if the player has invalid coords, then the error string "fell out of terminal",N1=x,N2=y is generated.
 */

/* the world of the game will be referred to using two different grids of
 * discreet coordinates. the primary grid is the cell space, which is
 * interleaved octohedrally with the boundry space, such that if a given
 * diminsion in cell space has n points, the same dimension in boundry
 * space has n+1 points. the cell space referes to the cells that are
 * displayed (the "cells"), while the boundry space referes to their
 * boundries. exact boundry space coordinates are not expected to be used;
 * only planes and polytopes are meaningful in boundry space.
 *
 * some notable uses of boundry space are in describing the emulated
 * cull plane of the "camera", and as the boundries of a given room.
 */

struct subroomtyp: //used by mapgen
char tiledata[MAX_Z][MAX_Z][MAX_Z]	//cube of MAX_Z
ucoord3 dim
enttype *ent_ptr
mapobjtyp *obj_ptr

/*     *.bin : signed binary data that is organized into 8 bit segments
 *    *.bin# : signed binary data that is organized into n bit segments
 *     *.hex : unsigned binary data that is organized into 8 bit segments
 *    *.hex# : unsigned binary data that is organized into n bit segments
 *      *.r8 : the tilemap of a room
 *     *.csv : UTF-8 text record deliminated with commas and line breaks
 *     *.tsv : UTF-8 text record deliminated with tabs and line breaks
 *     *.tab : same as tsv
 *      *.so : a shared object. a game may use as many of these as it wants. Placing single-use functions in LD_LOAD_PATH is DISCOURAGED; they should be placed in the game's private files.
 *     *.ini : data from inside a savefile
 *    *.json : produced when a dump is requested
 *  *.dumper : a self-reassembling perl datastructure
 *     *.asc : UTF-8 text record delimenated by newline.
 *     *.txt : UTF-8 text document. usually stored in the program's static files, which is CAT-ed to provide dialouge; also used in dumps of primatives
 *     *.ans : UTF-8 text record containing SGR sequences deleminated by newline.
 *     *.nfo : UTF-8 text document (not CP437) containing SGR sequences. otherwise identical to asc.
 *  **.rot13 : an encrypted text file, containing major spoilers.
 *  *.tar.gz : each room is saved as a tar.gz file, as are linked lists and the player. rooms are divided into compressed files for each plane. the extra planes are tar.gz files named rho_az_el
 * *.tar.bz2 : a savefile is a tar.bz2 file. it is named %H_%M_%S__%d_%m_%Y. the 23 main planes are tar.bz files named rho_az_el
 *   *.man.# : a linux manpage
 *  *.mdoc.# : a bsd manpage
 *         * : documentation
 *    *.html : documentation
 * *.texinfo : documentation
 *      *.pl : a perl script
 *      *.pm : a perl module
 *      *.PL : a build-related perl script
 *     *.pod : perl documentation
 *       *.d : everything relating to a struct is stored in the same directory, and pointers to structs are stored as subdirectories with the name of that field. the tail element in a linked list has no subdirectory named "next"; "prev" pointers are "../" implicitly.
 *    *.conf : a configuration file.
 *     *.*rc : a user's configuration file.
 *  *.dumper : a debugger data dump, with a format somwhere between JSON, INI, and C-like pseudocode. essentialy a dat file in readable (and non-raw) format.
 *
 * if the following new extensions collide with anything, I will change them. I specifically chose ones that were not a TLA or EFLA to try and avoid this, because there have been TDMTLA since before I came along.
 * *.midibas : midiBASIC, to be parsed by the midi generator into a .h file. Represents a different subset of general midi than regular midi files, but does so in a human readable format.
 */

/* dat file format:
 * SOH name BEL = struct field key
 * STX string ETX = an ascii text field, can contain ESC
 * DLE s8bit raw_data = a numeric field, abs(n) bits long. a negative number indicates the field is signed.
 * ACK = true
 * NAK = false
 * SUB = -1
 * NUL = empty string
 * XON path XOFF = a pointer to the data at path
 * ENQ = is a pointer
 * SYN = start an array or add a diminsion to the array
 * structs are terminated with ETB
 * arrays may have up to 4 dimensions seperated with FS GS RS and US.
 * arrays are ended with EM.
 */

struct mapgen_bordertyp {
tileset *hightiles_n
char north[MAX_Z][MAX_X]
tileset *hightiles_s
char south[MAX_Z][MAX_X]
tileset *hightiles_e
char east[MAX_Z][MAX_Y]
tileset *hightiles_w
char west[MAX_Z][MAX_Y]
tileset *hightiles_ne
char northeast[MAX_Z]
tileset *hightiles_nw
char northwest[MAX_Z]
tileset *hightiles_se
char southeast[MAX_Z]
tileset *hightiles_sw
char southwest[MAX_Z]
tileset *hightiles_u
char up[MAX_Y][MAX_X]
tileset *hightiles_d
char down[MAX_Y][MAX_X]
}
/* only used during mapgen, freed immediatly since it's so huge
 * up and down do not need secondary directions as the map cannot be scrolled that way
 */

typedef ushort shadowmask[MAX_Y][MAX_X]
typedef bitfield starfield[MAX_Y][MAX_X/8]

typedef ushort collisionmapcols[MAX_Y+2][MAX_X+2]
typedef uchar collisionmapholes[MAX_Y][MAX_X/8]

struct collisionmaptyp {
	collisionmapcols solid
	shadowmask liquid
	collisionmapholes holes
	}

set_collision_map (roomtyp * this,char x,char y,char z,bool q) {
	if (z < this->ceiling) {
		if (q) {
			switch (z) : {
				case 0 : return this->collisionmap.solid[y + 1][x + 1] |= 0x8000;
				case 1 : return this->collisionmap.solid[y + 1][x + 1] |= 0x4000;
				case 2 : return this->collisionmap.solid[y + 1][x + 1] |= 0x2000;
				case 3 : return this->collisionmap.solid[y + 1][x + 1] |= 0x1000;
				case 4 : return this->collisionmap.solid[y + 1][x + 1] |= 0x0800;
				case 5 : return this->collisionmap.solid[y + 1][x + 1] |= 0x0400;
				case 6 : return this->collisionmap.solid[y + 1][x + 1] |= 0x0200;
				case 7 : return this->collisionmap.solid[y + 1][x + 1] |= 0x0100;
				case 8 : return this->collisionmap.solid[y + 1][x + 1] |= 0x0080;
				case 9 : return this->collisionmap.solid[y + 1][x + 1] |= 0x0040;
				case 0xA : return this->collisionmap.solid[y + 1][x + 1] |= 0x0020;
				case 0xB : return this->collisionmap.solid[y + 1][x + 1] |= 0x0010;
				case 0xC : return this->collisionmap.solid[y + 1][x + 1] |= 0x0008;
				case 0xD : return this->collisionmap.solid[y + 1][x + 1] |= 0x0004;
				case 0xE : return this->collisionmap.solid[y + 1][x + 1] |= 0x0002;
				case 0xF : return this->collisionmap.solid[y + 1][x + 1] |= 0x0001;
				default : return ERR;
				}
			}
		else {
			switch (zcoord) : {
				case 0 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x8000;
				case 1 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x4000;
				case 2 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x2000;
				case 3 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x1000;
				case 4 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0800;
				case 5 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0400;
				case 6 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0200;
				case 7 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0100;
				case 8 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0080;
				case 9 : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0040;
				case 0xA : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0020;
				case 0xB : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0010;
				case 0xC : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0008;
				case 0xD : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0004;
				case 0xE : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0002;
				case 0xF : return this->collisionmap.solid[y + 1][x + 1] &= ~0x0001;
				default : return ERR;
				}
			}
		}
	else if (z == this->ceiling) {
		if (q) {
			div_t tmp = div(x,8);
			switch (tmp.quot) : {
				case 0 : return this->collisionmap.holes[y][tmp.rem] |= 0x80;
				case 1 : return this->collisionmap.holes[y][tmp.rem] |= 0x40;
				case 2 : return this->collisionmap.holes[y][tmp.rem] |= 0x20;
				case 3 : return this->collisionmap.holes[y][tmp.rem] |= 0x10;
				case 4 : return this->collisionmap.holes[y][tmp.rem] |= 0x08;
				case 5 : return this->collisionmap.holes[y][tmp.rem] |= 0x04;
				case 6 : return this->collisionmap.holes[y][tmp.rem] |= 0x02;
				case 7 : return this->collisionmap.holes[y][tmp.rem] |= 0x01;
				default : return ERR;
				}
			}
		else {
			switch (zcoord) : {
				case 0 : return this->collisionmap.holes[y][tmp.rem] &= ~0x80;
				case 1 : return this->collisionmap.holes[y][tmp.rem] &= ~0x40;
				case 2 : return this->collisionmap.holes[y][tmp.rem] &= ~0x20;
				case 3 : return this->collisionmap.holes[y][tmp.rem] &= ~0x10;
				case 4 : return this->collisionmap.holes[y][tmp.rem] &= ~0x08;
				case 5 : return this->collisionmap.holes[y][tmp.rem] &= ~0x04;
				case 6 : return this->collisionmap.holes[y][tmp.rem] &= ~0x02;
				case 7 : return this->collisionmap.holes[y][tmp.rem] &= ~0x01;
				default : return ERR;
				}
			}
		}
	return ERR;}

typedef tilemeta* tileset[128]

struct tilemeta {
bool ladder : 1
bool solid : 1
bool liquid : 1
bool conductive : 1
bool burns : 1
bool hypotherm : 1
bool sharp : 1
bool entropy : 1

bool shiney : 1
bool slip : 1
signed speed : 2

bool freezes : 1
bool melts : 1
bool petrif : 1

bool dig : 1
bool fence : 1

intptr_t freeze : 8
intptr_t melt : 8
intptr_t stone : 8
unsigned density

bool blink : 1
unsigned color : 6

char16_t unichar : 16
}
/* tiles can be effected by stuff happening around them.
 *
 * if a tile is flammable, a fire is summoned when fire magic
 * enters the space or 1d6 chance if there is fire within 1 taxicab of it.
 *
 * if a tile is conductive, then electricity is summoned for the instant
 * that electrical magic strikes it, and propagates through contiguous tiles.
 *
 * if a tile can freeze, it's _8BITPTR is changed to the number indicated by ice.
 * when ice magic intersects it.
 *
 * if a tile can melt, it's _8bitPtr is changed to the number indicated by melt
 * when fire or electrical magic intersect it.
 *
 * if a tile can be petrified, it is changed to the tile indicated by stone.
 *
 * if a tile can be dug, using a ↧digging tool on it will remove it
 * digging something triggers updates which cause gravity to affect gases (!liquid,!solid),
 * liquids(+liquid,!solid), and granulars(+liquid,+solid), wherin less dense
 * tiles will swap with more dense ones. this effect travels outwards, to the edge of the room,
 * but will not be applied to the border tiles. in the default set, water has a density of 10, snow
 * has a density of -1, and air has a density of -100. 
 */

/*pseudocode*/getsym
	{
	if (sym < 0)
		{
		cursesprint(.hightiles[sym^-128]) //xor intentional
		}
	else
		{
		cursesprint(.lowtiles[sym])
		}
	}

mapobjflags:
bool hidden : 1
bool moves : 1
bool rclass : 1
unsigned class : 4
unsigned alignment : 9

struct mapobjtyp:
(self) *prev
(self) *next
eventdata eventident
ucoord3 pos
objid type
void* data
mapobjflags flags

struct signtyp {
char16_t unichar
conlangtyp lang
char* lines
char* gibber
}

struct chestyp:
heldobjtyp *bag_ptr
cursetyp trap
locktype locked

struct doortyp {
bool open : 1
unsigned hp : 7
locktype lock : 8

struct locktype {
bool locked : 1
bool level : 3
bool pin1 : 1
bool pin2 : 1
bool pin3 : 1
bool pin4 : 1
trapflag flags : 8
/* lockpicking requires the player to enter
 * 0 and + in the correct order to turn the
 * tumblers. in addition to making the correct
 * guess, one must make a skill check:
 * 1 in 2^(lock.level - (skill/2)) chance
 *
 * lockpicking will play an ascending chromatic
 * scale on a loop, starting on C3 and ending
 * at G3, on synthbass (triangle wave)
 */

struct encontyp {
(self) *prev
(self) *next
eventdata eventident
uchar tobeat	//of 10D20
spawntyp spawn

struct miscitembasetyp:
bool key : 1
bool pick : 1
bool dig : 1
bool music : 1
bool light : 1
bool book : 1
bool spark : 1
bool quest : 1
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool stoneproof : 1
bool arrow : 1
bool poisoned : 1
bool unbreak : 1
unsigned uses : 8
intptr_t metadata : 8

struct eventdata {	//48-bit persistant event data
unsigned identnumber : 15
bool uses_race : 1
bool uses_role : 1
bool uses_class : 1
unsigned race : 5
unsigned role : 2
unsigned class : 3
unsigned align : 9
unsigned element : 8
unsigned lde : 3
}

struct eventdatastack_ele {	//list of events
(self)* prev
(self)* next
eventdata data
char * heylisten
eventdatastack_garbage * head
eventdatastack_garbage * tail
}

struct eventdatastack_garbage {
(self) * next
(self) * prev
objid type
void * data
}

enum eventdatastack_objid = {
EDS_ROOMOBJ_FLAG
EDS_QGLOBOBJ_FLAG
EDS_EVENTTYP_FLAG
EDS_QGLOBEV_FLAG
EDS_ENCONTYP_FLAG
EDS_PLACETYP_FLAG
}

struct eventtyp:
(self) *prev
(self) *next
ucoord3 pos
eventdata eventdatavals
triggertyp whenthis
const char* dothis	//object to be loaded. must be a shared object with C linkage; but not necissarily one written in C. if NULL, is a built-in function.
int (*doit)(union unitype,union unitype,union unitype,union unitype)
unsigned radius : 7
bool show : 1
unsigned up : 4
unsigned down : 4
uint32_t duration

enum triggerenum {ALWAYS_FLAG,ILLUM_FLAG,LOOK_FLAG,FARLOOK_FLAG,BUMP_FLAG,HIT_FLAG,FIRST_FLAG,NEW_FLAG,DAY_FLAG,TIME_FLAG,MORN_FLAG,NOON_FLAG,EVE_FLAG,MIDNITE_FLAG,DAY_FLAG,NIGHT_FLAG}

struct triggertyp {
triggerenum key : 4
unsigned value : 4
}

struct qglobobj: //queued global object
(self) *prev
(self) *next
eventdata eventident
qglobflags flags
latlontyp latlon
ucoord3 pos
objid type
void* data

struct qglobev: //queued global event
(self) *prev
(self) *next
qglobflags flags
latlontyp latlon
ucoord3 pos
eventdata eventdatavals
triggertyp whenthis
const char* dothis	//object to be loaded. must be a shared object with C linkage; but not necissarily one written in C. if NULL, is a built-in function.
int (*doit)(union unitype,union unitype,union unitype,union unitype)
unsigned radius : 7
bool show : 1
unsigned up : 4
unsigned down : 4
uint32_t duration

struct qglobflags {
struct racetyp race
race-specific : 1
role : u2
class : u3
lawfulgood : 1
neutralgood : 1
chaoticgood : 1
lawfulneutral : 1
trueneutral : 1
chaoticneutral : 1
lawfulevil : 1
neutralevil : 1
chaoticevil : 1
canforceload : 1
}

struct traptyp:
char16_t unichar
ushort duration
magictyp element
stattyp stat
cursetyp curse
diceodds odds
trapflags flags
senstyp sense
short hp
short mp

struct trapflags:
bool fireproof : 1
bool waterproof : 1
bool elecproof : 1
bool iceproof : 1
bool tamperproof : 1
bool stoneproof : 1
bool warded : 1
bool mode : 1
aligntyp attacks : 8	//if mode is true, will only attack entitys that are of an alignment that is undefined or true; if mode is false, will not attack entitys with alignment that is undefined or false
bool multiuse : 1
bool magic : 1	//whether the trap is a mechanism or a rune
unsigned color : 6

struct subwarptyp {
bool perm : 1
bool blink : 1
unsigned color : 6
ucoord3 pos
ucoord3 * dest
short duration	//negative are uses, positive are turns
}

struct warptyp:
bool perm : 1
bool blink : 1
unsigned color : 6
latlontyp glob_loc
ucoord3 pos
latlontyp glob_dest
ucoord3 * dest
short duration

char* gemcolors[8] = {"jet","sapphire","emerald","turquoise","ruby","amythest","heliodor","diamond"} //stoning has no effect
/* cut varys by color:
 * diamond = {uncut,cushion-cut,princess-cut,perfect-cut}
 * beryls,emerald={uncut,oval-cut,emerald-cut,teardrop} redundancy of emerald-cut emerald is redundant
 * amythest={geode,prismatic,cushion-cut,teardrop}
 * jet,turquoise={piece of,byzantine,polyhedral,carved relif in}
 */

struct gemstonetyp:
unsigned color : 3
unsigned quality : 2
unsigned cut : 2

struct meattyp:
struct racetyp race
uchar sellby
uchar amount

struct foodtyp:
intptr_t itemid : 8
intptr_t metadata : 8
unsigned sellby : 8
unsigned amount : 8

foodbasetyp:
effectyp effect
diceodds odds
uchar keepsfor	//0 means non-perishable
uchar hp
uchar nutri

enum objid:
WEAPON_FLAG : contains subobjtyp calling baseweaptyp
LEGEND_FLAG : contains subobjtyp calling baseweaptyp
POTION_FLAG : contains potiontyp
READ_FLAG : contains readtyp
FOOD_FLAG : contains subobjtyp containing foodtyp
MEAT_FLAG : contains subobjtyp containing meattyp
ARMOR_FLAG : contains subobjtyp calling basearmortyp
SHLD_FLAG : contains subobjtyp calling baseshldtyp
BAUB_FLAG : contains subobjtyp calling baubtyp
CONLANG_FLAG : contains conlangtyp
SPELL_FLAG : contains spelltyp
MISC_FLAG : contains _8bitPtr
GEM_FLAG : contains gemstonetyp
TRAP_FLAG : contains traptyp
WARP_FLAG : contains warptyp
SUBWARP_FLAG : contains subwarptyp
CHEST_FLAG : contains chestyp
DOOR_FLAG : contains doortyp
LOCK_FLAG : contains locktyp (gates are this)
MONEY_FLAG : contains moneytyp
SPAWN_FLAG : contains spawntyp
SIGN_FLAG : contains signtyp

/*blackbox*/radius
/* uses floats to define a circle,
 * terminating when there is not enough
 * value left to move another whole block.
 * one function won't cover all use cases.
 * one of these class of functions will be
 * __attribute__((hot))
 */

each layer is drawn translated +1y for each layer above the player and -1y for each layer below.
a shadow is drawn under the player
layers are drawn from ground to sky; if the player or their shadow would be covered by a tile,
drawing is stopped and the player is drawn if they have not been already
fluid tiles are transparent.

to avoid confusion, by default the player always uses a unique character: ☻
if so, then ☺ is used for your dopplganger.
whether or not these symbols are used must be decided at library compile time

symbols that are white or black based on being filled or unfilled might be
switchable at startup in the same way as tilde vs tilde operator

depening on difficulty of implementing such, characters might be stored in a lookup table
that stores indexes between an anything and a unicode codepoint. this would require a byte
encoding scheme for peeking anythings between runtimes, which is problematic considering
the existing 2 ways require either names or pointers

an UNDERLINE is a shadow

note: unicode symbols are (mostly) used be their appearence, not by their meaning
) is a sword or dagger. ⍏ are polearms. \ is a staff. ¦ is a club. : is a mace. ℓ is a whip. ( is a bow. ⇤ is an arrow. ⍖ is a writing instrument.
⟦ is armor. [ is clothing. ] is a shield. ⟧ are cannons or greeves. ☜☝☞☟ is a gauntlet. % is meat. ± is food (don't shoot it). $ is gold. ¢ is copper.
⌘ is a misc item. ↧ is a digging tool. ⌥ is a key or lockpick. ♫ is a lyre. ƒ is a violin. ♪ is a lute.
¿ are potions (fragile). ∫ is a scroll. ⊒ is a book. ∩ is a tablet. ° is a ring. º is a bracelet. ª is an amulet. ^ is a crown.
/ is a wand. ♮ is a ladder. ⋎ is a fountain or gyser. ⍾ is a bell. ⎋ is a clockface. ♠ ♣ ‡ are trees. ⋏ is fire. ♜ is a pedestal.
≋ is deep liquid's surface. ∬ is a waterfall. ≈ is a shallow liquid's surface, or a deep liquid below surface. ~ (centered) is a puddle. ≣ is a staircase. 
⌁ is electricity. * is ice. ⎈ spider web. ⌬ beehive. ↥ are spikes. ⎙ ⍝ ⎍ ∎ ⎅ are tombstones or signs. ␥ is glass.
! is trouble. ☀ is a light source. ⌸ is a door or gate. ⍯ is a locked door. ⎕ is an open door. 
• is a boulder. . is a rock. ⁂ is a rockslide. ◇ is a gemstone. ◊ is a giant magic crystal. ? is somone wearing a cowled cloak.
∪ is a sink. ⏍ is a chest. ↯ is the thunderbolt. ∅ is a spacetime anomaly (do not touch). ↸ ⇲ are level stairs.
← ↑ → ↓ ↖ ↗ ↘ ↙ are flying projectiles, or facing direction. ⇐ ⇑ ⇒ ⇓ ⇖ ⇗ ⇘ ⇙ are ballistae. ✪ is a rune. ː ⍽ are traps.
# █ ▓ ▒ ░ ▞ ▚ ⑆ (etc) are thick walls or floor. ☁ ≎ are clouds (do not walk on them; keep your head out of them). ☈ is a thundercloud (hurts).
` ␣ are holes (note that ` is only used when a sunbeam is not present). ' is a stalagtite or icicle. , is a plant. ; is a grain or sunflower (impassable).
box drawings are low walls or columns. ⋯⋰⋱⋮ are iron bars. · is an ember or star.
¬ is mud. ≃ ≊ is stagnent water (unbreathable). ☿ is a pool of mercury. ♃ is a mirror. ♄ is an antimagic field.
" deliminates text.
⍰ is a missingno (invalid tile id).

a prompt at launch uses user responce to choose between using ~ or ∼ for centered tilde.
handling of solid vs outlined symbols will use the solid symbol for a forground different from the background,
and outlined to represent same color on color.

box drawings:
 ╒╤╕     ╔╦╗
 ╞╪╡flat ╠╬╣upright
 ╘╧╛     ╚╩╝

A_DIM is used to provide 16 colors
A_ITALIC symbols are petrified (statues).
A_BLINK is a tile that is out of view
A_BOLD symbols are highlighted
A_INVIS is not able to be seen
A_REVERSE video is a magic spell's area of effect
A_UNDERLINE is the shadow of an entity

text that is cat-ed from an nfo file, or otherwise printed using stdio, will not be restricted to ncurses formatting,
and will use the full range of ANSI SGR escape codes

rune symbols
◬ air, ⍫ earth, △ fire, ▽ water, ⍰ missingno
⋇ ice, ☇ electricity, ♤ metal, ♻ nature
¤ status effect, ❖ stoning, ☣ poison, ∅ entropy
☼ light, ☽ dark, § polymorph, ↹ planer
♥ healing

magic AOE symbols
≋ air, • earth, ⋏ fire, ∿ water
* ice, ⌁ electricity, ↥ metal, ♠ nature
❖ status effect, ☣ poison, ¤ stoning, ‽ entropy
☀ light, ⎈ dark, § polymorph

directional symbols:
←, ↑, →, ↓, ↖, ↗, ↘, ↙, direction in XY;
! far side; ↧, ↥, direction in Z;
↹ different plane;
◬, ⍫, △, ▽, ⋇, ↯, ♤, ♻, ☼, ☽, ∅, inner planes;
LG, NG, CG, LN, CN, LE, NE, CE, TN, UN, ☠, outer planes;

foods (* = uses meta)
hardtak tortilla cornmeal cornbread
flour cheese wine bread
mead ale scotch ethenol
grapes fig date plum
apple banana apricot papaya
orange pear pinapple coconut
kiwi dragonfruit durin peach
grapefruit lemon lime citron
spinach artichoke asparagus bamboo
cucumbers zuccini pickles squash
carrot corn potato celery
brocoli lettuce cabbage kale
cauliflower raddish turnip beets
rhubarb pumpkin avacodo jalapenos
beans greenbeans tomato eggplant
blackolives greenolives garlic onions
watercress chives ketchup mustard
parsly sage rosmary thyme
basil oregano allspice nutmeg
salt bellpeppers peppercorns redpepper
vanillabean cinnimonstick cocoabean sugarbeet
walnut pecan cashew peanut
sunflowerseed pistachio almond chestnuts
cranberrys blueberrys raspberry blackberry
strawberry cherry peppermint pawpaw
sugarcane syrup* molasses honey
seseme poppy fennel eyeofnewt
mushroom* truffel penecillin yeast
barly wheat rye rice
ginger sasafrass blueraspberries bubbles 
geletin starch creamoftartar bakingpowder
vinager bakingsoda calciumhydroxide hemlock
popcorn nachos cookies milk*
pasta(uncooked) pasta ramen(uncooked) ramen*
dumplings(uncooked) dumplings* tofu(uncooked) tofu
meatballs marinara alfredosauce parmisian
lasagnia* pizza* spaghetti alfredo
spaghetti&meatballs ramen&dumplings chickenalfredo brocllialfredo
guacamole nachos* chili salsa
pie* cake* soda* chips
salad* hotdog* hamburger* fries
vanilla cinnimon chocolate sugar
cocoapowder cocoabutter cocoaliquor fudge
egg fat* caramel butterscotch
sourcream butter/shortening* mayo dressing*
pie* pie_alamode* englishfruitcake bread*
cake* pancake* waffle* stackofpancakes*
frozenpancake frozenwaffle flavoredmilk* juice*
roast* gravy foo&gravy* foo_chicken*
bakedpotato loadedbakedpotato mashpotatos tatties&neeps
sunnysideup overeasy scrambled hardboiled
bacon* sausage* jerky* spam
nutbrittle* trailmix rasin* peanutbuttersandwich*
baconlettucetomatosandwich clubsandwich fingersandwich* coldcutsandwich*
milkshake* icecream* sorbet* icecreamfloat*
icecreamcone* banannasplit neopolitan rockyroad
gumdrop* hardcandy* candycane filledchocolate*
jelly* jam* preserves* peanutbutter
icecube snow ember blacksoup
broth* stew* ration mistake

/*blackbox*/playervelocitycheck() velocitycheck(*entity)
	/* if you have a nonzero velocity vector, when you try to move
	 * you travel in a direction determined by the mean vector of
	 * your move and your velocity. each turn, your velocity reduces
	 * by 1+.5n on land, 1+.75n underwater, and is cancled compleatly
	 * in a direction if you hit something.
	 */

/*blackbox*/movecheck(xmove,ymove,zmove)
	/* if you are flying {
	 *	checks your flying skill and restricts your movement accordingly
	 *		if you have no flying skill, grav is added to your -Z velocity
	 *	checks to make sure that you are not flying through a solid block
	 *	checks to make sure you are not landing in water if you can't swim
	 *		asks if you are sure
	 *	}
	 * if you are walking {	
	 *	checks to make sure you are not walking off a cliff without wings
	 *		asks if you are sure
	 *	checks to make sure you are not walking into deep water if you can't swim
	 *		asks if you are sure
	 *	automatically climbs 1-high blocks that are not fences
	 *	}
	 * updates your direction 	
	 * if you leave the room by any means, creates a mapscrolltyp of the apropriate value and calls mapscroll
	 * subtracts the appropriate value from your remaining move
	 * }
	 */

/*blackbox*/newtonlaw(xmove,ymove,zmove)
	- checks if you're flying magically, on ice, or in a liquid
	- if you are, adds {-xmove,-ymove,-zmove} to your velocity
	  (half this value in liquids)

roomscroll(direction,stairs)
uchar direction
bool stairs
{
switch (direction) : {
	case 0 : break;
	case ROOM_UP : saveroom(NULL);WORLD = touchroom(ROOM->neighborhood->up);

roomwarp(latlontyp)

coordjump(coordx,coordy,coordz)

/*blackbox implicit*/dump(datatypenum,void*)
// used by the debugger to dump data.

/*pseudocode implicit*/castshadow(xpos,ypos,zpos)
uchar xpos
uchar ypos
uchar zpos
{
if (zpos == 0) {
	return zpos
	}
else if (mapderef(xpos,ypos,zpos-1).solid) {
	underline(xpos,ypos,zpos)
	return zpos
	}
else {
	zpos--
	for (;zpos!=0;zpos--) {
		if (mapderef(xpos,ypos,zpos-1).solid) {
			underline(xpos,ypos,zpos)
			return zpos
			}
		else if (mapderef(xpos,ypos,zpos-1).liquid) {
			underline(xpos,ypos,zpos)
			}
		}
	underline(xpos,ypos,zpos) //escape zpos==0
	return zpos
	}

bool maskfetch(zcoord,ycoord,xcoord,mask)
uchar zcoord
uchar ycoord
uchar xcoord
shadowmask mask
{
switch (zcoord) : {
	case 0 : return (bool) (mask[ycoord][xcoord] & 0x8000);
	case 1 : return (bool) (mask[ycoord][xcoord] & 0x4000);
	case 2 : return (bool) (mask[ycoord][xcoord] & 0x2000);
	case 3 : return (bool) (mask[ycoord][xcoord] & 0x1000);
	case 4 : return (bool) (mask[ycoord][xcoord] & 0x0800);
	case 5 : return (bool) (mask[ycoord][xcoord] & 0x0400);
	case 6 : return (bool) (mask[ycoord][xcoord] & 0x0200);
	case 7 : return (bool) (mask[ycoord][xcoord] & 0x0100);
	case 8 : return (bool) (mask[ycoord][xcoord] & 0x0080);
	case 9 : return (bool) (mask[ycoord][xcoord] & 0x0040);
	case 0xA : return (bool) (mask[ycoord][xcoord] & 0x0020);
	case 0xB : return (bool) (mask[ycoord][xcoord] & 0x0010);
	case 0xC : return (bool) (mask[ycoord][xcoord] & 0x0008);
	case 0xD : return (bool) (mask[ycoord][xcoord] & 0x0004);
	case 0xE : return (bool) (mask[ycoord][xcoord] & 0x0002);
	case 0xF : return (bool) (mask[ycoord][xcoord] & 0x0001);
	default : return false;
	}
}

/*implicit*/maskset(zcoord,ycoord,xcoord,mask,value)
uchar zcoord;
uchar ycoord;
uchar xcoord;
shadowmask * maskptr;
bool value;
{
shadowmask mask = *maskptr;
if (value) {
	switch (zcoord) : {
		case 0 : return mask[ycoord][xcoord] |= 0x8000;
		case 1 : return mask[ycoord][xcoord] |= 0x4000;
		case 2 : return mask[ycoord][xcoord] |= 0x2000;
		case 3 : return mask[ycoord][xcoord] |= 0x1000;
		case 4 : return mask[ycoord][xcoord] |= 0x0800;
		case 5 : return mask[ycoord][xcoord] |= 0x0400;
		case 6 : return mask[ycoord][xcoord] |= 0x0200;
		case 7 : return mask[ycoord][xcoord] |= 0x0100;
		case 8 : return mask[ycoord][xcoord] |= 0x0080;
		case 9 : return mask[ycoord][xcoord] |= 0x0040;
		case 0xA : return mask[ycoord][xcoord] |= 0x0020;
		case 0xB : return mask[ycoord][xcoord] |= 0x0010;
		case 0xC : return mask[ycoord][xcoord] |= 0x0008;
		case 0xD : return mask[ycoord][xcoord] |= 0x0004;
		case 0xE : return mask[ycoord][xcoord] |= 0x0002;
		case 0xF : return mask[ycoord][xcoord] |= 0x0001;
		default : return ERR;
		}
	}
else {
	switch (zcoord) : {
		case 0 : return mask[ycoord][xcoord] &= ~0x8000;
		case 1 : return mask[ycoord][xcoord] &= ~0x4000;
		case 2 : return mask[ycoord][xcoord] &= ~0x2000;
		case 3 : return mask[ycoord][xcoord] &= ~0x1000;
		case 4 : return mask[ycoord][xcoord] &= ~0x0800;
		case 5 : return mask[ycoord][xcoord] &= ~0x0400;
		case 6 : return mask[ycoord][xcoord] &= ~0x0200;
		case 7 : return mask[ycoord][xcoord] &= ~0x0100;
		case 8 : return mask[ycoord][xcoord] &= ~0x0080;
		case 9 : return mask[ycoord][xcoord] &= ~0x0040;
		case 0xA : return mask[ycoord][xcoord] &= ~0x0020;
		case 0xB : return mask[ycoord][xcoord] &= ~0x0010;
		case 0xC : return mask[ycoord][xcoord] &= ~0x0008;
		case 0xD : return mask[ycoord][xcoord] &= ~0x0004;
		case 0xE : return mask[ycoord][xcoord] &= ~0x0002;
		case 0xF : return mask[ycoord][xcoord] &= ~0x0001;
		default : return ERR;
		}
	}
return ERR;
}

bool langetx(race,id) __attribute__((const))
basentyp race
uchar id
{
div_t tmp = div(id,8)
if (tmp.quot > 3) {
	ERRORGRAPHIC(SIGFPE,3,\
		0,"math: out of bounds",\
		sizeof(int),"impossible result %i > 3",tmp.quot,\
		sizeof(uchar),"(perhaps %i > 31)",id);
	return false}
switch (tmp.rem) : {
	case 0 : return (bool) (race.vocal[tmp.quot] & 0x80);
	case 1 : return (bool) (race.vocal[tmp.quot] & 0x40);
	case 2 : return (bool) (race.vocal[tmp.quot] & 0x20);
	case 3 : return (bool) (race.vocal[tmp.quot] & 0x10);
	case 4 : return (bool) (race.vocal[tmp.quot] & 0x08);
	case 5 : return (bool) (race.vocal[tmp.quot] & 0x04);
	case 6 : return (bool) (race.vocal[tmp.quot] & 0x02);
	case 7 : return (bool) (race.vocal[tmp.quot] & 0x01);
	default : ERRORGRAPHIC(SIGFPE,2,\
		0,"math: invalid remainder",\
		sizeof(int),"remainder %i from modulo 8",temp.rem);
	}
}

engineloop () __attribute__((noreturn)) {
forever {
	if (NEW) {
		checkglobal(NEW_FLAG,true)
		NEW = false
		}
	checkevents()	//check event triggers
	player_act()	//player's turn
	follow_iter()	//iterate through follower entities
	ent_iter()	//iterate through local entities
	encounter(1D6,1d100)	//generate up to 1D6 of monster number 1d100, iff encounter != NULL
	}
}

/*pseudocode*/ <follow|ent>_iter () {
<ent|follow>typ* ptr = <head>
while (ptr != NULL) {
	<follow|ent>_act(&ptr) //&ptr's turn
	ptr = ptr->next
	}
}

/*pseudocode*/encounter(count,tableid)
uchar count
uchar tableid
{
encontyp *ptr = ROOM.encon_head
for (;tableid != 0;tableid--) {
	ptr = ptr->next
	}
uchar try;
for (;count != 0;count--) {
	try = mainh_roll(10,20,1)
	if (try > ptr->tobeat) {
		summonfunc(ptr->spawn)
		}
	}
}

/*blackbox*/render() {
/* flush THESHADOWKNOWS and SHINEALIGHT
 * translate the view so that the player is on line 13
 * cast shadows and record the player's shadow
 * illuminate the player according to their view range
 * illuminate all lights in the room.
 * get the player's view information. only draw tiles that can be seen.
 * draw each layer of the room one at a time, making sure the player and their shadow are not covered, and doing out-of-view substitution.
 * draw the player
 * draw other entitys that can be seen
 * add shadows
 */

termcheck() {
TERM = getenv("TERM");
if (strstr(TERM,"xterm") != NULL) {
	IS_XTERM = true
	}

/*pseudocode*/enginesplash(GAME_NAME,GAME_VERSION,STORY_REV)
const char* GAME_NAME GAME_VERSION STORY_REV
{
	if (IS_XTERM = true) {
	printf("\033]1;IWannaFlyCurses\033\\");
	printf("\033]2;IWannaFlyCurses - %s\033\\",GAMENAME);
	}
printf(RESET);
printf(" \033[1;95m~~ IWANNAFLY ROGUELIKE ENGINE ~~\033[m\n\033[97m          engine version: %s\n          rules revision: %s\n            API revision: %s\n        savefile version: %s\nextension parser version: %s\n    runcommander version: %s\n       midibasic version: %s\n       midi backend type: %s\n\n \033[96m - %s -\033[m\n\033[97m  game version: %s\nstory revision: %s\n\n\033[37mCompiled on %s\n\033m\a",ENGINE_VERSION,RULES_VERSION,API_VERSION,SAVE_VERSION,EXT_PARSE_VERSION,RUNCOM_VERSION,MIDIBAS_VERSION,MIDI_TYPE,GAME_NAME,GAME_VERSION,STORY_REV,__DATE__);
fflush(stdout);
sleep(4);
printf(RESET);
printf("\033[1;32m\tEngine Copyright (C) 2019- \"GeneralGuy4872\"\n\n\tThis program is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU General Public License\n\tas published by the Free Software Foundation; either version 2\n\tof the License, or (at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see \n\t\033[m\033[4;94mhttps://www.gnu.org/licenses/\033[m\033[1;32m.\a");
fflush(stdout);
sleep(4);
printf(RESET);
printf("\033[92mLibraries linked:\nNCurses by Zeyd M Ben-Halim,\n           Eric S. Raymond,\n           Thomas E Dickey\n           and the Free Software Foundation\nLibTar by Mark D. Roth\nZlib by Jean-loup Gaully and Mark Adler\nLibBZip2 by Julian Steward\n");
fflush(stdout);
sleep(4);
printf(RESET);
printf("\033[92mAlgorithems Implemented:\nDijkstra's Algorithem\nPrim's Algorithem\nKruskal's Algorithem and Kruskal's Reverse Algorithem\nBorůvka's Algorithm\nRolling Dice\nSierpiński Attractor\nPerlin Noise\a");
fflush(stdout);
sleep(4);
}

init__main() {
termcheck();
TILDEWIDE = setwidetilde();
init__montable();
}

main() {
init__main();
enginesplash("Default Game","Prealpha","Rough Draft");
printf(RESET);printf(BLINKY);
fflush(stdout);
sleep(4);
printf(RESET);
file_cat_nocurses(STATIC_PATH"scene.nfo");	//...okay, it's the story of every JRPG ever, but the story of the 3D game didn't have a wide enough scope. I'll write more later, when I'm in that mindset.
printf("\a");
fflush(stdout);
sleep(4);
printf(RESET);printf(BLINKY);
fflush(stdout);
sleep(4);
printf(RESET);
puts("\033[3mSo it begins...\033[23m\a");
fflush(stdout);
sleep(4);
FIXCURSES
do_intro_movie();
promptload();
engineloop();
if (!(TRUENDING)) {
	notatruending()
	}
}

notatruending() {
	BREAKCURSES
	printf("\033[1;3;33mTHIS IS NOT A TRUE ENDING...\n");
	puts(RESET);
	quit(0);
	}
